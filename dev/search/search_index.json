{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#a-fast-conda-package-builder-rattler-build","title":"A fast conda package builder: <code>rattler-build</code>","text":"<p>The <code>rattler-build</code> tool creates cross-platform relocatable packages from a simple recipe format.  The recipe format is heavily inspired by <code>conda-build</code> and <code>boa</code>, and the output of <code>rattler-build</code> is a standard \"conda\" package that can be installed using <code>pixi</code>,  <code>mamba</code> or <code>conda</code>.</p> <p><code>rattler-build</code> is implemented in Rust, does not have any dependencies on <code>conda-build</code> or Python and works as a standalone binary.</p> <p>You can use <code>rattler-build</code> to publish packages to prefix.dev, anaconda.org, JFrog Artifactory, S3 buckets, or Quetz Servers.</p> <p>Try it out! You can experiment with rattler-build directly in your browser using our online playground.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>The recommended way of installing <code>rattler-build</code>, being a conda-package builder, is through a conda package manager. Next to <code>rattler-build</code> we are also building <code>pixi</code>.</p> <p>With <code>pixi</code> you can install <code>rattler-build</code> globally:</p> <pre><code>pixi global install rattler-build\n</code></pre> <p>Other options are:</p> CondaHomebrewArch LinuxBinary <pre><code>conda install rattler-build -c conda-forge\n\nmamba install rattler-build -c conda-forge\nmicromamba install rattler-build -c conda-forge\n\npixi global install rattler-build\npixi add rattler-build # To a pixi project\n</code></pre> <pre><code>brew install rattler-build\n</code></pre> <pre><code>pacman -S rattler-build\n</code></pre> <p><pre><code># Download the latest release from the GitHub releases page, for example the linux x86 version with curl:\ncurl -SL --progress-bar https://github.com/prefix-dev/rattler-build/releases/latest/download/rattler-build-x86_64-unknown-linux-musl\n</code></pre> You can grab version of <code>rattler-build</code> from the Github Releases.</p> Shell Completion <p>When installing <code>rattler-build</code> you might want to enable shell completion. Afterwards, restart the shell or source the shell config file.</p> BashZshPowerShellFishNushellElvish <pre><code>echo 'eval \"$(rattler-build completion --shell bash)\"' &gt;&gt; ~/.bashrc\n</code></pre> <pre><code>echo 'eval \"$(rattler-build completion --shell zsh)\"' &gt;&gt; ~/.zshrc\n</code></pre> <pre><code>Add-Content -Path $PROFILE -Value '(&amp; rattler-build completion --shell powershell) | Out-String | Invoke-Expression'\n</code></pre> <p>Failure because no profile file exists</p> <p>Make sure your profile file exists, otherwise create it with: <pre><code>New-Item -Path $PROFILE -ItemType File -Force\n</code></pre></p> <pre><code>echo 'rattler-build completion --shell fish | source' &gt;&gt; ~/.config/fish/config.fish\n</code></pre> <p>Add the following to the end of your Nushell env file (find it by running <code>$nu.env-path</code> in Nushell):</p> <pre><code>mkdir ~/.cache/rattler-build\nrattler-build completion --shell nushell | save -f ~/.cache/rattler-build/completions.nu\n</code></pre> <p>And add the following to the end of your Nushell configuration (find it by running <code>$nu.config-path</code>):</p> <pre><code>use ~/.cache/rattler-build/completions.nu *\n</code></pre> <pre><code>echo 'eval (rattler-build completion --shell elvish | slurp)' &gt;&gt; ~/.elvish/rc.elv\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Currently <code>rattler-build</code> needs some dependencies on the host system which are executed as subprocess. We plan to reduce the number of external dependencies over time by writing what we need in Rust to make <code>rattler-build</code> fully self-contained.</p> <ul> <li><code>install_name_tool</code> is necessary on macOS to rewrite the <code>rpath</code> of shared   libraries and executables to make it relative</li> <li><code>patchelf</code> is required on Linux to rewrite the <code>rpath</code> and <code>runpath</code> of shared   libraries and executables</li> <li><code>git</code> to checkout Git repositories (not implemented yet, but will require <code>git</code>   in the future)</li> <li><code>msvc</code> on Windows because we cannot ship the MSVC compiler on conda-forge   (needs to be installed on the host machine)</li> </ul>"},{"location":"#github-action","title":"GitHub Action","text":"<p>There is a GitHub Action for <code>rattler-build</code>. It can be used to install <code>rattler-build</code> in CI/CD workflows and run a build command. Please check out the GitHub Action documentation for more information.</p>"},{"location":"#the-recipe-format","title":"The Recipe Format","text":"<p>Note You can find all examples below in the <code>examples</code> folder in the codebase and run them with <code>rattler-build</code>.</p> <p>A simple example recipe for the <code>xtensor</code> header-only C++ library:</p> recipe.yaml<pre><code>context:\n  name: xtensor\n  version: 0.24.6\n\npackage:\n  name: ${{ name|lower }}\n  version: ${{ version }}\n\nsource:\n  url: https://github.com/xtensor-stack/xtensor/archive/${{ version }}.tar.gz\n  sha256: f87259b51aabafdd1183947747edfff4cff75d55375334f2e81cee6dc68ef655\n\nbuild:\n  number: 0\n  script:\n    - if: win\n      then: |\n        cmake -G \"NMake Makefiles\" -D BUILD_TESTS=OFF -D CMAKE_INSTALL_PREFIX=%LIBRARY_PREFIX% %SRC_DIR%\n        nmake\n        nmake install\n      else: |\n        cmake ${CMAKE_ARGS} -DBUILD_TESTS=OFF -DCMAKE_INSTALL_PREFIX=$PREFIX $SRC_DIR -DCMAKE_INSTALL_LIBDIR=lib\n        make install\n\nrequirements:\n  build:\n    - ${{ compiler('cxx') }}\n    - cmake\n    - if: unix\n      then: make\n  host:\n    - xtl &gt;=0.7,&lt;0.8\n  run:\n    - xtl &gt;=0.7,&lt;0.8\n  run_constraints:\n    - xsimd &gt;=8.0.3,&lt;10\n\ntests:\n  - script:\n      - if: unix or emscripten\n        then:\n          - test -d ${PREFIX}/include/xtensor\n          - test -f ${PREFIX}/include/xtensor/xarray.hpp\n          - test -f ${PREFIX}/share/cmake/xtensor/xtensorConfig.cmake\n          - test -f ${PREFIX}/share/cmake/xtensor/xtensorConfigVersion.cmake\n      - if: win\n        then:\n          - if not exist %LIBRARY_PREFIX%\\include\\xtensor\\xarray.hpp (exit 1)\n          - if not exist %LIBRARY_PREFIX%\\share\\cmake\\xtensor\\xtensorConfig.cmake (exit 1)\n          - if not exist %LIBRARY_PREFIX%\\share\\cmake\\xtensor\\xtensorConfigVersion.cmake (exit 1)\n\nabout:\n  homepage: https://github.com/xtensor-stack/xtensor\n  license: BSD-3-Clause\n  license_file: LICENSE\n  summary: The C++ tensor algebra library\n  description: Multi dimensional arrays with broadcasting and lazy computing\n  documentation: https://xtensor.readthedocs.io\n  repository: https://github.com/xtensor-stack/xtensor\n\nextra:\n  recipe-maintainers:\n    - some-maintainer\n</code></pre> <p>A recipe for the <code>rich</code> Python package (using <code>noarch</code>):</p> recipe.yaml<pre><code>context:\n  version: \"13.4.2\"\n\npackage:\n  name: \"rich\"\n  version: ${{ version }}\n\nsource:\n  - url: https://pypi.io/packages/source/r/rich/rich-${{ version }}.tar.gz\n    sha256: d653d6bccede5844304c605d5aac802c7cf9621efd700b46c7ec2b51ea914898\n\nbuild:\n  # Thanks to `noarch: python` this package works on all platforms\n  noarch: python\n  script:\n    - python -m pip install . -vv\n\nrequirements:\n  host:\n    - pip\n    - poetry-core &gt;=1.0.0\n    - python 3.10.*\n  run:\n    # sync with normalized deps from poetry-generated setup.py\n    - markdown-it-py &gt;=2.2.0\n    - pygments &gt;=2.13.0,&lt;3.0.0\n    - python 3.10.*\n    - typing_extensions &gt;=4.0.0,&lt;5.0.0\n\ntests:\n  - python:\n      imports:\n        - rich\n      pip_check: true\n\nabout:\n  homepage: https://github.com/Textualize/rich\n  license: MIT\n  license_file: LICENSE\n  summary: Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal\n  description: |\n    Rich is a Python library for rich text and beautiful formatting in the terminal.\n\n    The Rich API makes it easy to add color and style to terminal output. Rich\n    can also render pretty tables, progress bars, markdown, syntax highlighted\n    source code, tracebacks, and more \u2014 out of the box.\n  documentation: https://rich.readthedocs.io\n  repository: https://github.com/Textualize/rich\n</code></pre> <p>A recipe for the <code>curl</code> library:</p> recipe.yaml<pre><code>context:\n  version: \"8.0.1\"\n\npackage:\n  name: curl\n  version: ${{ version }}\n\nsource:\n  url: http://curl.haxx.se/download/curl-${{ version }}.tar.bz2\n  sha256: 9b6b1e96b748d04b968786b6bdf407aa5c75ab53a3d37c1c8c81cdb736555ccf\n\nbuild:\n  number: 0\n\nrequirements:\n  build:\n    - ${{ compiler('c') }}\n    - if: win\n      then:\n        - cmake\n        - ninja\n    - if: unix\n      then:\n        - make\n        - perl\n        - pkg-config\n        - libtool\n  host:\n    - if: linux\n      then:\n        - openssl\n\nabout:\n  homepage: http://curl.haxx.se/\n  license: curl\n  license_file: COPYING\n  summary: tool and library for transferring data with URL syntax\n  description: |\n    Curl is an open source command line tool and library for transferring data\n    with URL syntax. It is used in command lines or scripts to transfer data.\n  documentation: https://curl.haxx.se/docs/\n  repository: https://github.com/curl/curl\n</code></pre> <p>For the <code>curl</code> library recipe, two additional script files (<code>build.sh</code> and <code>build.bat</code>) are needed.</p> build.sh<pre><code>#!/bin/bash\n\n# Get an updated config.sub and config.guess\ncp $BUILD_PREFIX/share/libtool/build-aux/config.* .\n\nif [[ $target_platform =~ linux.* ]]; then\n    USESSL=\"--with-openssl=${PREFIX}\"\nelse\n    USESSL=\"--with-secure-transport\"\nfi;\n\n./configure \\\n    --prefix=${PREFIX} \\\n    --host=${HOST} \\\n    ${USESSL} \\\n    --with-ca-bundle=${PREFIX}/ssl/cacert.pem \\\n    --disable-static --enable-shared\n\nmake -j${CPU_COUNT} ${VERBOSE_AT}\nmake install\n\n# Includes man pages and other miscellaneous.\nrm -rf \"${PREFIX}/share\"\n</code></pre> <p>Or on Windows:</p> build.bat<pre><code>mkdir build\n\ncmake -GNinja ^\n      -DCMAKE_BUILD_TYPE=Release ^\n      -DBUILD_SHARED_LIBS=ON ^\n      -DCMAKE_INSTALL_PREFIX=%LIBRARY_PREFIX% ^\n      -DCMAKE_PREFIX_PATH=%LIBRARY_PREFIX% ^\n      -DCURL_USE_SCHANNEL=ON ^\n      -DCURL_USE_LIBSSH2=OFF ^\n      -DUSE_ZLIB=ON ^\n      -DENABLE_UNICODE=ON ^\n      %SRC_DIR%\n\nIF %ERRORLEVEL% NEQ 0 exit 1\n\nninja install --verbose\n</code></pre>"},{"location":"authentication_and_upload/","title":"Server authentication","text":""},{"location":"authentication_and_upload/#authenticating-with-a-server","title":"Authenticating with a server","text":"<p>You may want to use private channels for which you need to be authenticated. There are two ways to configure authentication: using the <code>rattler-build auth</code> command for persistent storage, or the <code>RATTLER_AUTH_FILE</code> environment variable for ephemeral use.</p>"},{"location":"authentication_and_upload/#using-rattler-build-auth-recommended","title":"Using <code>rattler-build auth</code> (recommended)","text":"<p>The <code>auth</code> command stores credentials securely in your system's keychain. This is the recommended approach for interactive use.</p> <pre><code># Login to prefix.dev with a token\nrattler-build auth login prefix.dev --token &lt;your_token&gt;\n\n# Login to anaconda.org with a conda token\nrattler-build auth login anaconda.org --conda-token &lt;your_token&gt;\n\n# Login with basic HTTP authentication (e.g., Artifactory)\nrattler-build auth login my-artifactory.com --username &lt;user&gt; --password &lt;pass&gt;\n\n# Login to an S3 bucket\nrattler-build auth login s3://my-bucket --s3-access-key-id &lt;key&gt; --s3-secret-access-key &lt;secret&gt;\n\n# Remove stored credentials\nrattler-build auth logout prefix.dev\n</code></pre> <p>Once logged in, <code>rattler-build</code> will automatically use these credentials when accessing the corresponding hosts.</p>"},{"location":"authentication_and_upload/#using-rattler_auth_file-ephemeral","title":"Using <code>RATTLER_AUTH_FILE</code> (ephemeral)","text":"<p>For CI/CD or ephemeral environments, you can use the <code>RATTLER_AUTH_FILE</code> environment variable to point to a JSON file with the following structure:</p> <pre><code>{\n    \"*.prefix.dev\": {\n        \"BearerToken\": \"your_token\"\n    },\n    \"otherhost.com\": {\n        \"BasicHTTP\": {\n            \"username\": \"your_username\",\n            \"password\": \"your_password\"\n        }\n    },\n    \"anaconda.org\": {\n        \"CondaToken\": \"your_token\"\n    },\n    \"s3://my-bucket/my-channel\": {\n        \"S3Credentials\": {\n            \"access_key_id\": \"your_access_key_id\",\n            \"secret_access_key\": \"your_secret_access_key\",\n            \"session_token\": null\n        }\n    }\n}\n</code></pre> <p>The keys are the host names. You can use wildcard specifiers here (e.g. <code>*.prefix.dev</code> to match all subdomains of <code>prefix.dev</code>, such as <code>repo.prefix.dev</code>). This will allow you to also obtain packages from any private channels that you have access to.</p> <p>The following known authentication methods are supported:</p> <ul> <li><code>BearerToken</code>: prefix.dev</li> <li><code>CondaToken</code>: anaconda.org, quetz</li> <li><code>BasicHTTP</code>: artifactory</li> <li><code>S3Credentials</code>: S3 buckets</li> </ul>"},{"location":"authentication_and_upload/#uploading-packages","title":"Uploading packages","text":"<p>If you want to upload packages, then rattler-build comes with a built-in <code>upload</code> command. There are the following options:</p> <ul> <li><code>prefix.dev</code>: you can create public or private channels on the prefix.dev   hosted server</li> <li><code>anaconda.org</code>: you can upload packages to the free anaconda.org server</li> <li><code>quetz</code>: you can host your own quetz server and upload packages to it</li> <li><code>artifactory</code>: you can upload packages to a JFrog Artifactory server</li> <li><code>s3</code>: you can upload packages to an S3 bucket</li> </ul> <p>The command is:</p> <pre><code>rattler-build upload &lt;server&gt; &lt;package_files&gt;\n</code></pre> <p>Note: you can also use the <code>RATTLER_AUTH_FILE</code> environment variable to authenticate with the server.</p>"},{"location":"authentication_and_upload/#prefixdev","title":"prefix.dev","text":""},{"location":"authentication_and_upload/#trusted-publishing-via-oidc","title":"Trusted publishing via OIDC","text":"<p><code>rattler-build</code> supports authentication with https://prefix.dev through OIDC with GitHub Actions. An API key is no longer required, rattler-build can manage the complete authentication workflow for you. You only have to set up a specific repository and workflow under \"Trusted Publishers\" on prefix.dev.</p> <p></p> <p>Here you can find an example GitHub Actions workflow</p> .github/workflows/build.yml<pre><code>permissions:\n  contents: read\n  id-token: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build conda package\n        uses: prefix-dev/rattler-build-action@v0.2.19\n\n      - name: Upload all packages\n        shell: bash\n        run: |\n          shopt -s nullglob\n          EXIT_CODE=0\n          for pkg in $(find output -type f \\( -name \"*.conda\" -o -name \"*.tar.bz2\" \\) ); do\n            if ! rattler-build upload prefix -c my-channel \"${pkg}\"; then\n              EXIT_CODE=1\n            fi\n          done\n          exit $EXIT_CODE\n</code></pre>"},{"location":"authentication_and_upload/#token","title":"Token","text":"<p>To upload to prefix.dev, you need to have an account. You can then create a token in the settings of your account. The token is used to authenticate the upload.</p> <pre><code>export PREFIX_API_KEY=&lt;your_token&gt;\nrattler-build upload prefix -c &lt;channel&gt; &lt;package_files&gt;\n</code></pre> <p>You can also use the <code>--api-key=$PREFIX_API_KEY</code> option to pass the token directly to the command. Note that you need to have created the channel on the prefix.dev website before you can upload to it.</p>"},{"location":"authentication_and_upload/#quetz","title":"Quetz","text":"<p>You need to pass a token and API key to upload to a channel on your own Quetz server. The token is used to authenticate the upload.</p> <pre><code>export QUETZ_API_KEY=&lt;your_token&gt;\nrattler-build upload quetz -u &lt;url&gt; -c &lt;channel&gt; &lt;package_files&gt;\n</code></pre>"},{"location":"authentication_and_upload/#artifactory","title":"Artifactory","text":"<p>To upload to an Artifactory server, you need to pass a username and password. The username and password are used to authenticate the upload.</p> <pre><code>export ARTIFACTORY_USERNAME=&lt;your_username&gt;\nexport ARTIFACTORY_PASSWORD=&lt;your_password&gt;\nrattler-build upload artifactory -u &lt;url&gt; -c &lt;channel&gt; &lt;package_files&gt;\n</code></pre>"},{"location":"authentication_and_upload/#anacondaorg","title":"anaconda.org","text":"<p>To upload to anaconda.org, you need to specify the owner and API key. The API key is used to authenticate the upload.</p> <p>The owner is the owner of the distribution, for example, your user name or organization.</p> <p>One can also specify a label such as <code>dev</code> for release candidates using the <code>-c</code> flag. The default value is <code>main</code>.</p> <p>You can also add the <code>--force</code> argument to forcibly upload a new package (and overwrite any existing ones).</p> <pre><code>export ANACONDA_API_KEY=&lt;your_token&gt;\nrattler-build upload anaconda -o &lt;your_username&gt; -c &lt;label&gt; &lt;package_files&gt;\n</code></pre>"},{"location":"authentication_and_upload/#s3","title":"S3","text":"<p>To upload to an S3 bucket, you need to set access key ID, secret access key and (optionally) a session token. If not using <code>rattler-build auth login s3://my-bucket --s3-access-key-id &lt;access-key-id&gt; --s3-secret-access-key &lt;secret-access-key&gt; --s3-session-token &lt;session-token&gt;</code>, you can set the corresponding <code>S3_*</code> environment variables.</p> <p>For instance, the following example uploads to a Cloudflare R2 S3 bucket:</p> <pre><code>export S3_ACCESS_KEY_ID=&lt;your_access_key_id&gt;\nexport S3_SECRET_ACCESS_KEY=&lt;your_secret_access_key&gt;\n\nrattler-build upload s3 \\\n  --channel s3://my-bucket/my-channel \\\n  --region auto \\\n  --endpoint-url https://xyz.r2.cloudflarestorage.com \\\n  --addressing-style path\n</code></pre>"},{"location":"automatic_linting/","title":"Automatic Linting in VSCode","text":"<p>Our new recipe format adheres to a strict JSON schema, which you can access on Github.</p> <p>This schema is implemented using <code>pydantic</code> and can be rendered into a JSON schema file. The YAML language server extension in VSCode is capable of recognizing this schema, providing useful hints during the editing process.</p> <p>We have published the schema on schemastore.org which means, it will be automatically picked up when the file is called <code>recipe.yaml</code>. If you give your recipe files different names, you can use the following in the first line of your recipe to get schema hints:</p> <pre><code># yaml-language-server: $schema=https://raw.githubusercontent.com/prefix-dev/recipe-format/main/schema.json\n</code></pre>"},{"location":"build_options/","title":"Advanced build options","text":"<p>There are some specialized build options to control various features:</p> <ul> <li>prefix replacement</li> <li>variant configuration</li> <li>encoded file type</li> </ul> <p>These are all found under the <code>build</code> key in the <code>recipe.yaml</code>.</p>"},{"location":"build_options/#include-only-certain-files-in-the-package","title":"Include only certain files in the package","text":"<p>Sometimes you may want to include only a subset of the files installed by the build process in your package. For this, the <code>files</code> key can be used. Only new files are considered for inclusion (ie. files that were not in the host environment beforehand).</p> recipe.yaml<pre><code>build:\n  # select files to be included in the package\n  # this can be used to remove files from the package, even if they are installed in the\n  # environment\n  files:\n    - list\n    - of\n    - globs\n</code></pre> <p>For example, to only include the header files in a package, you could use:</p> recipe.yaml<pre><code>build:\n  files:\n    - include/**/*.h\n</code></pre> <p>Glob patterns throughout the recipe file can also use a flexible <code>include</code> / <code>exclude</code> pair, such as:</p> recipe.yaml<pre><code>build:\n  files:\n    include:\n      - include/**/*.h\n    exclude:\n      - include/**/private.h\n</code></pre>"},{"location":"build_options/#glob-evaluation","title":"Glob evaluation","text":"<p>Glob patterns are used throughout the build options to specify files. The patterns are matched against the relative path of the file in the build directory. Patterns can contain <code>*</code> to match any number of characters, <code>?</code> to match a single character, and <code>**</code> to match any number of directories.</p> <p>For example:</p> <ul> <li><code>*.txt</code> matches all files ending in <code>.txt</code></li> <li><code>**/*.txt</code> matches all files ending in <code>.txt</code> in any directory</li> <li><code>**/test_*.txt</code> matches all files starting with <code>test_</code> and ending in <code>.txt</code>   in any directory</li> <li><code>foo/</code> matches all files under the <code>foo</code> directory</li> </ul> <p>The globs are always evaluated relative to the prefix directory. If you have no <code>include</code> globs, but an <code>exclude</code> glob, then all files are included except those that match the <code>exclude</code> glob. This is equivalent to <code>include: ['**']</code>.</p>"},{"location":"build_options/#always-include-and-always-copy-files","title":"Always include and always copy files","text":"<p>There are some options that control the inclusion of files in the final package.</p> <p>The <code>always_include_files</code> option can be used to include files even if they are already in the environment as part of some other host dependency. This is normally \"clobbering\" and should be used with caution (since packages should not have any overlapping files).</p> <p>The <code>always_copy_files</code> option can be used to copy files instead of linking them. This is useful for files that might be modified inside the environment (e.g. configuration files). Normally, files are linked from a central cache into the environment to save space \u2013 that means that files modified in one environment will be modified in all environments. This is not always desirable, and in that case you can use the <code>always_copy_files</code> option.</p> <p>How <code>always_copy_files</code> works</p> <p>The <code>always_copy_files</code> option works by setting the <code>no_link</code> option in the <code>info/paths.json</code> to <code>true</code> for the files in question. This means that the files are copied instead of linked when the package is installed.</p> recipe.yaml<pre><code>build:\n  # include files even if they are already in the environment\n  # as part of some other host dependency\n  always_include_files: list of globs\n\n  # do not soft- or hard-link these files, but always copy them was `no_link`\n  always_copy_files: list of globs\n</code></pre>"},{"location":"build_options/#merge-build-and-host-environments","title":"Merge build and host environments","text":"<p>In very rare cases you might want to merge the build and host environments to obtain the \"legacy\" behavior of conda-build.</p> recipe.yaml<pre><code>build:\n  # merge the build and host environments (used in many R packages on Windows)\n  merge_build_and_host_envs: bool (defaults to false)\n</code></pre>"},{"location":"build_options/#prefix-detection-replacement-options","title":"Prefix detection / replacement options","text":"<p>During installation time the \"install\"-prefix is injected into text and binary files. Sometimes this is not desired, and sometimes the user might want closer control over the automatic text/binary detection.</p> <p>The main difference between prefix replacement for text and binary files is that for binary files, the prefix string is padded with null bytes to match the length of the original prefix. The original prefix is the very long placeholder string that you might have seen in the build process.</p> <p>On Windows, binary prefix replacement is never performed.</p> recipe.yaml<pre><code>package:\n  name: mypackage\n  version: 1.0\n\nbuild:\n  # settings concerning the prefix detection in files\n  prefix_detection:\n    # force the file type of the given files to be TEXT or BINARY\n    # for prefix replacement\n    force_file_type:\n      # force TEXT file type (list of globs)\n      text: list of globs\n      # force binary file type (list of globs)\n      binary: list of globs\n\n    # ignore all or specific files for prefix replacement`\n    ignore: bool | [path] (defaults to false)\n\n    # whether to ignore binary files for prefix replacement\n    # defaults to false on Unix and (always) true on Windows\n    ignore_binary_files: bool\n</code></pre>"},{"location":"build_options/#variant-configuration","title":"Variant configuration","text":"<p>To control the variant precisely you can use the \"variant configuration\" options.</p> <p>A variant package has the same version number, but different \"hash\" and potentially different dependencies or build options. Variant keys are extracted from the <code>variants.yaml</code> file and usually any used Jinja variables or dependencies without version specifier are used as variant keys.</p> <p>Variant keys can also be forcibly set or ignored with the <code>use_keys</code> and <code>ignore_keys</code> options.</p> <p>In order to decide which of the variant packages to prefer and install by default, the <code>down_prioritize_variant</code> option can be used. The higher the value, the less preferred the variant is.</p> <p>More about variants can be found in the variant documentation.</p> <p>The following options are available in the <code>build</code> section to control the variant configuration:</p> recipe.yaml<pre><code>build:\n  # settings for the variant\n  variant:\n    # Keys to forcibly use for the variant computation\n    # even if they are not in the dependencies\n    use_keys: list of strings\n\n    # Keys to forcibly ignore for the variant computation\n    # even if they are in the dependencies\n    ignore_keys: list of strings\n\n    # used to prefer this variant less\n    down_prioritize_variant: integer (defaults to 0, higher is less preferred)\n</code></pre>"},{"location":"build_options/#dynamic-linking-configuration","title":"Dynamic linking configuration","text":"<p>After the package is built, rattler-build performs some \"post-processing\" on the binaries and libraries.</p> <p>This entails making the shared libraries relocatable and checking that all linked libraries are present in the run requirements. The following settings control this behavior.</p> <p>With the <code>rpath</code> option you can forcibly set the <code>rpath</code> of the shared libraries. The path is relative to the install prefix. Any <code>rpath</code> setting is ignored on Windows.</p> <p>The <code>rpath_allowlist</code> option can be used to allow the <code>rpath</code> to point to locations outside of the environment. This is useful if you want to link against libraries that are not part of the conda environment (e.g. proprietary software).</p> <p>If you want to stop <code>rattler-build</code> from relocating the binaries, you can set <code>binary_relocation</code> to <code>false</code>. If you want to only relocate some binaries, you can select the relevant ones with a glob pattern.</p> <p>To read more about <code>rpath</code>s and how rattler-build creates relocatable binary packages, see the internals docs.</p> <p>If you link against some libraries (possibly even outside of the prefix, in a system location), then you can use the <code>missing_dso_allowlist</code> to allow linking against these and suppress any warnings. This list is pre-populated with a list of known system libraries on the different operating systems.</p> <p>As part of the post-processing, <code>rattler-build</code> checks for overlinking and overdepending. \"Overlinking\" is when a binary links against a library that is not specified in the run requirements. This is usually a mistake because the library would not be present in the environment when the package is installed.</p> <p>Conversely, \"overdepending\" is when a library is part of the run requirements, but is not actually used by any of the binaries/libraries in the package.</p> <p>In addition to handling binary dependencies, <code>rattler-build</code> also ensures that packages containing hardcoded paths into the environment are relocatable when installed outside the of the build environment. To do this, <code>rattler-build</code> constructs a host environment with a 255 character name of the form <code>host_env_placehold[_placehold[_placehold[...]]]</code> (for details, see the internals docs). At install time, conda will find these paths and replace them in binaries with the path to the environment being installed into.</p> <p>Since this process may not be safe for all packages, and not all packages will require these modifications (if packages are already internally avoiding embedding invalid absolute paths, for example), then this process may be disabled using the <code>prefix_detection</code> options shown below.</p> recipe.yaml<pre><code>build:\n  # settings for shared libraries and executables\n  dynamic_linking:\n    # linux only, list of rpaths relative to the installation prefix\n    rpaths: list of paths (defaults to ['lib/'])\n\n    # Allow runpath / rpath to point to these locations\n    # outside of the environment\n    rpath_allowlist: list of globs\n\n    # whether to relocate binaries or not. If this is a list of paths, then\n    # only the listed paths are relocated\n    binary_relocation: bool (defaults to true) | list of globs\n\n    # Allow linking against libraries that are not in the run requirements\n    missing_dso_allowlist: list of globs\n\n    # what to do when detecting overdepending\n    overdepending_behavior: \"ignore\" or \"error\" # (defaults to \"ignore\")\n\n    # what to do when detecting overlinking\n    overlinking_behavior: \"ignore\" or \"error\" # (defaults to \"ignore\")\n\n  prefix_detection:\n    # A set of files to ignore prefix detection for altogether, see\n    ignore: list of globs\n\n    force_file_type:\n      # Force replacement of files as binary blobs regardless of their type\n      binary: list of globs\n      # Force replacement of files as text (strings) regardless of their type\n      text: list of globs\n</code></pre>"},{"location":"build_options/#python-options","title":"Python options","text":"<p>There are some additional options in the <code>python</code> section of the <code>build</code> key.</p> <p>The <code>entry_points</code> option can be used to specify entry points for the package.</p> <p>The <code>use_python_app_entrypoint</code> option can be used to specify if <code>python.app</code> which is useful for GUI applications on macOS.</p> <p>The <code>skip_pyc_compilation</code> option can be used to exclude certain files from being automatically compiled from <code>.py</code> to <code>.pyc</code>. Note that <code>noarch: python</code> packages never contain <code>.pyc</code> files. Some packages ship .py files that cannot be compiled, such as those that contain templates. Some packages also ship .py files that should not be compiled yet, because the Python interpreter that will be used is not known at build time. In these cases, conda-build can skip attempting to compile these files. The patterns used in this section do not need the ** to handle recursive paths.</p> <p>The <code>site_packages_path</code> is a specific option that is only used when build <code>python</code> itself. It will add metadata to the package record of the python package to tell the installer where the <code>site-packages</code> path is located. This is used to install noarch packages in the correct location.</p> recipe.yaml<pre><code>build:\n  python:\n    # entry points for the package\n    entry_points:\n      - bsdiff4 = bsdiff4.cli:main_bsdiff4\n      - bspatch4 = bsdiff4.cli:main_bspatch4\n\n    # use python.app entrypoint (macOS only)\n    use_python_app_entrypoint: false  # (defaults to false, only used on macOS)\n\n    # skip pyc compilation for certain files\n    skip_pyc_compilation:\n      - foo/*.py\n\n    # Option to specify whether a package is version independent (aka ABI3)\n    version_independent: true  # defaults to false\n</code></pre> <p>And an example of the <code>site_packages_path</code> option when building the python interpreter:</p> recipe.yaml<pre><code>package:\n  name: python\n  version: \"3.13.0\"\n\nbuild:\n  python:\n    # path to the site-packages folder\n    site_packages_path: \"lib/python3.13/site-packages\"\n</code></pre>"},{"location":"build_options/#python-package-version-independence","title":"Python Package Version Independence","text":"<p>Conda packages can be made version-independent in two different ways:</p>"},{"location":"build_options/#noarch-python","title":"<code>noarch: python</code>","text":"<p>Packages marked as <code>noarch: python</code> contain only pure Python code without compiled extensions. These packages work across all Python versions and platforms from a single build.</p>"},{"location":"build_options/#version_independent-true","title":"<code>version_independent: true</code>","text":"<p>Packages marked as version_independent support multiple Python versions while containing compiled extensions using Python's ABI3 compatibility. These require platform-specific builds (Windows, macOS, Linux) but remain compatible across different Python versions within each platform.</p>"},{"location":"build_options/#post-processing-of-the-package-contents-experimental","title":"Post processing of the package contents (experimental)","text":"<p>rattler-build allows you to post-process the package contents with <code>regex</code> replacements after the build has finished. This is only useful in very specific cases when you cannot easily identify new files and want to run post-processing only on new files.</p> <p>Note that this is an experimental feature and might be removed or changed in the future.</p> <p>The <code>post_process</code> key is a list of dictionaries with the following keys:</p> <ul> <li>files: list of globs to select the files from the package that you want to   modify</li> <li>regex: the regular expression to match in the file. Note that this uses Rust   regex syntax.</li> <li>replacement: the replacement string to use. Attention: note that Rust supports   expanding \"named captures\" with $name or ${name}. If you want to replace with   a env variable, you need to use <code>$${name}</code> to get <code>${name}</code> in the output.</li> </ul> recipe.yaml<pre><code>build:\n  post_process:\n    - files:\n        - *.txt\n      regex: \"foo\"\n      replacement: \"bar\"\n    - files:\n        - '*.pc'\n      regex: (?:-L|-I)?\"?([^;\\s]+/sysroot/)\n      replacement: '$${CONDA_BUILD_SYSROOT_S}'  # note this expands to `${CONDA_BUILD_SYSROOT_S}`\n</code></pre>"},{"location":"build_script/","title":"Scripts for building and testing packages","text":"<p>The <code>build.sh</code> file is the build script for Linux and macOS and <code>build.bat</code> is the build script for Windows. These scripts contain the logic that carries out your build steps. Anything that your build script copies into the <code>$PREFIX</code> or <code>%PREFIX%</code> folder will be included in your output package.</p> <p>For example, this <code>build.sh</code>:</p> build.sh<pre><code>mkdir -p $PREFIX/bin\ncp $RECIPE_DIR/my_script_with_recipe.sh $PREFIX/bin/super-cool-script.sh\n</code></pre> <p>There are many environment variables defined for you to use in build.sh and build.bat. Please see environment variables for more information.</p> <p><code>build.sh</code> and <code>build.bat</code> are optional. You can instead use the <code>build/script</code> key in your <code>recipe.yaml</code>, with each value being either a string command or a list of string commands. Any commands you put there must be able to run on every platform for which you build. For example, you can't use the <code>cp</code> command because <code>cmd.exe</code> won't understand it on Windows.</p> <p><code>build.sh</code> is run with <code>bash</code> and <code>build.bat</code> is run with <code>cmd.exe</code>.</p> recipe.yaml<pre><code>build:\n  script:\n    - if: unix\n      then:\n        - mkdir -p $PREFIX/bin\n        - cp $RECIPE_DIR/my_script_with_recipe.sh $PREFIX/bin/super-cool-script.sh\n    - if: win\n      then:\n        - mkdir %LIBRARY_BIN%\n        - copy %RECIPE_DIR%\\my_script_with_recipe.bat %LIBRARY_BIN%\\super-cool-script.bat\n</code></pre>"},{"location":"build_script/#environment-variables","title":"Environment variables","text":"<p>There are many environment variables that are automatically set during the build process.</p> <p>However, you can also set your own environment variables easily in the <code>script</code> section of your recipe:</p> recipe.yaml<pre><code>build:\n  script:\n    # Either use `content` or `file` to specify the script\n    # Note: this script only works on Unix :)\n    content: |\n      echo $FOO\n      echo $BAR\n      echo \"Secret value: $BAZ\"\n    env:\n      # hard coded value for `FOO`\n      FOO: \"foo\"\n      # Forward a value from the \"outer\" environment\n      # Without `default=...`, the build process will error if `BAR` is not set\n      BAR: ${{ env.get(\"BAR\", default=\"NOBAR\") }}\n    secrets:\n      # This value is a secret and will be masked in the logs and not stored in the rendered recipe\n      # The value needs to be available as an environment variable in the outer environment\n      - BAZ\n</code></pre>"},{"location":"build_script/#alternative-script-interpreters","title":"Alternative script interpreters","text":"<p>With <code>rattler-build</code> and the new recipe syntax you can select an <code>interpreter</code> for your script.</p> <p>So far, the following interpreters are supported:</p> <ul> <li><code>bash</code> (default on Unix)</li> <li><code>cmd.exe</code> (default on Windows)</li> <li><code>nushell</code></li> <li><code>python</code></li> <li><code>perl</code></li> <li><code>rscript</code> (for R scripts)</li> <li><code>ruby</code></li> <li><code>node</code> or <code>nodejs</code> (for NodeJS scripts)</li> </ul> <p><code>rattler-build</code> automatically detects the interpreter based on the file extension (<code>.sh</code>, <code>.bat</code>, <code>.nu</code>, <code>.py</code>, <code>.pl</code>, <code>.r</code>, <code>.rb</code>, <code>.js</code>) or you can specify it in the <code>interpreter</code> key in the <code>script</code> section of your recipe.</p> recipe.yaml<pre><code>build:\n  script: myscript.py  # automatically selects the Python interpreter\n\nrequirements:\n  build:\n    - python  # required to execute the `myscript.py` script\n</code></pre> <p>Note</p> <p>Using alternative interpreters is less battle-tested than using <code>bash</code> or <code>cmd.exe</code>. If you encounter any issues, please open an issue.</p>"},{"location":"build_script/#using-nushell","title":"Using <code>nushell</code>","text":"<p>In order to use <code>nushell</code> you can select the <code>interpreter: nu</code> or have a <code>build.nu</code> file in your recipe directory. Nushell works on Windows, macOS and Linux with the same syntax.</p> recipe.yaml<pre><code>build:\n  script:\n    interpreter: nu\n    content: |\n      echo \"Hello from nushell!\"\n\n# Note: it's required to have `nushell` in the `build` section of your recipe!\nrequirements:\n  build:\n    - nushell\n</code></pre>"},{"location":"build_script/#using-python","title":"Using <code>python</code>","text":"<p>In order to use <code>python</code> you can select the <code>interpreter: python</code> or have a <code>build.py</code> file in your recipe directory and <code>python</code> in the <code>requirements/build</code> section.</p> recipe.yaml<pre><code>build:\n  script:\n    interpreter: python\n    content: |\n      print(\"Hello from Python!\")\n\n# Note: it's required to have `python` in the `build` section of your recipe!\nrequirements:\n  build:\n    - python\n</code></pre>"},{"location":"build_script/#using-ruby","title":"Using <code>ruby</code>","text":"<p>In order to use <code>ruby</code> you can select the <code>interpreter: ruby</code> or have a <code>build.rb</code> file in your recipe directory and <code>ruby</code> in the <code>requirements/build</code> section.</p> recipe.yaml<pre><code>build:\n  script:\n    interpreter: ruby\n    content: |\n      puts \"Hello from Ruby!\"\n\n# Note: it's required to have `ruby` in the `build` section of your recipe!\nrequirements:\n  build:\n    - ruby\n</code></pre>"},{"location":"build_script/#using-nodejs","title":"Using <code>nodejs</code>","text":"<p>In order to use <code>nodejs</code> you can select the <code>interpreter: nodejs</code> (or <code>node</code>) or have a <code>build.js</code> file in your recipe directory and <code>nodejs</code> in the <code>requirements/build</code> section.</p> recipe.yaml<pre><code>build:\n  script:\n    interpreter: nodejs\n    content: |\n      console.log(\"Hello from NodeJS!\");\n\n# Note: it's required to have `nodejs` in the `build` section of your recipe!\nrequirements:\n  build:\n    - nodejs\n</code></pre>"},{"location":"build_script/#default-environment-variables-set-during-the-build-process","title":"Default environment variables set during the build process","text":"<p>During the build process, the following environment variables are set, on Windows with <code>build.bat</code> and on macOS and Linux with <code>build.sh</code>. By default, these are the only variables available to your build script. Unless otherwise noted, no variables are inherited from the shell environment in which you invoke <code>conda-build</code>. To override this behavior, see :ref:<code>inherited-env-vars</code>.</p> <code>ARCH</code> <p>Either <code>32</code> or <code>64</code>, to specify whether the build is 32-bit or 64-bit.   The value depends on the ARCH environment variable and defaults to the   architecture the interpreter running conda was compiled with.</p> <code>CMAKE_GENERATOR</code> <p>The CMake generator string for the current build   environment. On Linux systems, this is always <code>Unix Makefiles</code>. On Windows, it   is generated according to the Visual Studio version activated at build time, for   example, <code>Visual Studio 9 2008 Win64</code>.</p> <code>CONDA_BUILD=1</code> <p>Always set to indicate that the conda-build process is   running.</p> <code>CPU_COUNT</code> <p>Represents the number of CPUs on the system.</p> <code>SHLIB_EXT</code> <p>Denotes the shared library extension specific to the operating   system (e.g. <code>.so</code> for Linux, <code>.dylib</code> for macOS, and <code>.dll</code> for Windows).</p> <code>HTTP_PROXY</code>, <code>HTTPS_PROXY</code> <p>Inherited from the user's shell environment, specifying the HTTP and HTTPS   proxy settings.</p> <code>LANG</code> <p>Inherited from the user's shell environment, defining the system   language and locale settings.</p> <code>MAKEFLAGS</code> <p>Inherited from the user's shell environment. This can be used to   set additional arguments for the make command, such as -j2 to utilize 2 CPU   cores for building the recipe.</p> <code>PY_VER</code> <p>Specifies the Python version against which the build is occurring.   This can be modified with a <code>variants.yaml</code> file.</p> <code>PATH</code> <p>Inherited from the user's shell environment and augmented with the   activated host and build prefixes.</p> <code>PREFIX</code> <p>The build prefix to which the build script should install the   software.</p> <code>PKG_BUILDNUM</code> <p>Indicates the build number of the package currently being built.</p> <code>PKG_NAME</code> <p>The name of the package that is being built.</p> <code>PKG_VERSION</code> <p>The version of the package currently under construction.</p> <code>PKG_BUILD_STRING</code> <p>The complete build string of the package being built,   including the hash (e.g. py311h21422ab_0).</p> <code>PKG_HASH</code> <p>Represents the hash of the package being built, excluding the   leading 'h' (e.g. 21422ab). This is applicable from conda-build 3.0 onwards.</p> <code>PYTHON</code> <p>The path to the Python executable in the host prefix. Python is   installed in the host prefix only when it is listed as a host requirement.</p> <code>R</code> <p>The path to the R executable in the build prefix. R is installed in the   build prefix only when it is listed as a build requirement.</p> <code>RECIPE_DIR</code> <p>The directory where the recipe is located.</p> <code>SP_DIR</code> <p>The location of Python's site-packages, where Python libraries are installed.</p> <code>SRC_DIR</code> <p>The path to where the source code is unpacked or cloned. If the   source file is not a recognized archive format, this directory contains a copy   of the source file.</p> <code>STDLIB_DIR</code> <p>The location of Python's standard library.</p> <code>build_platform</code> <p>Represents the native subdirectory of the conda executable,   indicating the platform for which the build is occurring.</p> <p>Removed from <code>conda-build</code> are: - <code>NPY_VER</code> - <code>PY3K</code></p>"},{"location":"build_script/#windows","title":"Windows","text":"<p>Unix-style packages on Windows are built in a special <code>Library</code> directory under the build prefix. The environment variables listed in the following table are defined only on Windows.</p> Variable Description <code>LIBRARY_BIN</code> <code>&lt;build prefix&gt;\\Library\\bin</code>. <code>LIBRARY_INC</code> <code>&lt;build prefix&gt;\\Library\\include</code>. <code>LIBRARY_LIB</code> <code>&lt;build prefix&gt;\\Library\\lib</code>. <code>LIBRARY_PREFIX</code> <code>&lt;build prefix&gt;\\Library</code>. <code>SCRIPTS</code> <code>&lt;build prefix&gt;\\Scripts</code>. <p>Not yet supported in <code>rattler-build</code>:</p> <ul> <li><code>CYGWIN_PREFIX</code></li> <li><code>VS_MAJOR</code></li> <li><code>VS_VERSION</code></li> <li><code>VS_YEAR</code></li> </ul> <p>Additionally, the following variables are forwarded from the environment:</p> <ul> <li><code>ALLUSERSPROFILE</code></li> <li><code>APPDATA</code></li> <li><code>CommonProgramFiles</code></li> <li><code>CommonProgramFiles(x86)</code></li> <li><code>CommonProgramW6432</code></li> <li><code>COMPUTERNAME</code></li> <li><code>ComSpec</code></li> <li><code>HOMEDRIVE</code></li> <li><code>HOMEPATH</code></li> <li><code>LOCALAPPDATA</code></li> <li><code>LOGONSERVER</code></li> <li><code>NUMBER_OF_PROCESSORS</code></li> <li><code>PATHEXT</code></li> <li><code>ProgramData</code></li> <li><code>ProgramFiles</code></li> <li><code>ProgramFiles(x86)</code></li> <li><code>ProgramW6432</code></li> <li><code>PROMPT</code></li> <li><code>PSModulePath</code></li> <li><code>PUBLIC</code></li> <li><code>SystemDrive</code></li> <li><code>SystemRoot</code></li> <li><code>TEMP</code></li> <li><code>TMP</code></li> <li><code>USERDOMAIN</code></li> <li><code>USERNAME</code></li> <li><code>USERPROFILE</code></li> <li><code>windir</code></li> <li><code>PROCESSOR_ARCHITEW6432</code></li> <li><code>PROCESSOR_ARCHITECTURE</code></li> <li><code>PROCESSOR_IDENTIFIER</code></li> </ul>"},{"location":"build_script/#unix","title":"Unix","text":"<p>The environment variables listed in the following table are defined only on macOS and Linux.</p> Variable Description <code>HOME</code> Standard $HOME environment variable. <code>PKG_CONFIG_PATH</code> Path to <code>pkgconfig</code> directory, defaults to `$PREFIX/lib/pkgconfig <code>SSL_CERT_FILE</code> Path to <code>SSL_CERT_FILE</code> file. <code>CFLAGS</code> Empty, can be forwarded from env to set additional arguments to C compiler. <code>CXXFLAGS</code> Same as CFLAGS for C++ compiler. <code>LDFLAGS</code> Empty, additional flags to be passed to the linker when linking object files into an executable or shared object."},{"location":"build_script/#macos","title":"macOS","text":"<p>The environment variables listed in the following table are defined only on macOS.</p> Variable Description <code>MACOSX_DEPLOYMENT_TARGET</code> Same as the Anaconda Python macOS deployment target. Currently <code>10.9</code> for intel 32- and 64bit macOS, and 11.0 for arm64. <code>OSX_ARCH</code> <code>i386</code> or <code>x86_64</code> or <code>arm64</code>, depending on the target platform"},{"location":"build_script/#linux","title":"Linux","text":"<p>The environment variable listed in the following table is defined only on Linux.</p> Variable Description <code>LD_RUN_PATH</code> Defaults to <code>&lt;build prefix&gt;/lib</code>. <code>QEMU_LD_PREFIX</code> The prefix used by QEMU's user mode emulation for library paths. <code>QEMU_UNAME</code> Set qemu uname release string to 'uname'. <code>DEJAGNU</code> The path to the dejagnu testing framework used by the GCC test suite. <code>DISPLAY</code> The X11 display to use for graphical applications. <code>BUILD</code> Target triple (<code>{build_arch}-conda_{build_distro}-linux-gnu</code>) where build_distro is one of <code>cos6</code> or <code>cos7</code>, for Centos 6 or 7"},{"location":"bump_recipe/","title":"Bumping recipe versions","text":"<p>When maintaining conda recipes, you often need to update packages to newer versions. This involves changing the version number in your recipe and updating the SHA256 checksum for the new source archive. <code>rattler-build</code> provides the <code>bump-recipe</code> command to automate this process.</p>"},{"location":"bump_recipe/#how-it-works","title":"How it works","text":"<p>The <code>bump-recipe</code> command:</p> <ol> <li>Reads the recipe file and extracts the current version and source URL(s)</li> <li>Detects the version provider (GitHub, PyPI, crates.io) from the source URL</li> <li>Either uses a specified version or auto-detects the latest version from the provider</li> <li>Downloads the new source archive and computes its SHA256 checksum</li> <li>Updates the recipe file using simple string replacement (preserving formatting and comments)</li> </ol>"},{"location":"bump_recipe/#basic-usage","title":"Basic usage","text":"<p>Auto-detect and bump to the latest version:</p> <pre><code>rattler-build bump-recipe --recipe recipe.yaml\n</code></pre> <p>Bump to a specific version:</p> <pre><code>rattler-build bump-recipe --recipe recipe.yaml --version 2.0.0\n</code></pre> <p>Check if updates are available without modifying the recipe:</p> <pre><code>rattler-build bump-recipe --recipe recipe.yaml --check-only\n</code></pre> <p>Preview changes without writing to the file:</p> <pre><code>rattler-build bump-recipe --recipe recipe.yaml --dry-run\n</code></pre>"},{"location":"bump_recipe/#command-options","title":"Command options","text":"Option Description <code>-r, --recipe &lt;PATH&gt;</code> Path to the recipe file (default: current directory) <code>--version &lt;VERSION&gt;</code> Specific version to bump to (auto-detects if not specified) <code>--check-only</code> Only check for updates, don't modify the recipe <code>--dry-run</code> Show what would change without writing to the file <code>--include-prerelease</code> Include pre-release versions (alpha, beta, rc) when auto-detecting <code>--keep-build-number</code> Keep the current build number instead of resetting to 0"},{"location":"bump_recipe/#supported-providers","title":"Supported providers","text":"<p>The command auto-detects the version provider from your source URL:</p> Provider URL patterns API used GitHub <code>github.com/owner/repo/archive/...</code><code>github.com/owner/repo/releases/download/...</code><code>api.github.com/repos/owner/repo/tarball/...</code> GitHub Releases API (falls back to Tags) PyPI <code>pypi.io/packages/source/...</code><code>files.pythonhosted.org/packages/source/...</code> PyPI JSON API crates.io <code>crates.io/api/v1/crates/...</code><code>static.crates.io/crates/...</code> crates.io API <p>For URLs that don't match any known provider, you must specify the version manually with <code>--version</code>.</p>"},{"location":"bump_recipe/#recipe-format","title":"Recipe format","text":"<p>The command works with recipes that use Jinja2 templating in the context section:</p> recipe.yaml<pre><code>context:\n  name: mypackage\n  version: \"1.0.0\"\n\npackage:\n  name: ${{ name }}\n  version: ${{ version }}\n\nsource:\n  url: https://github.com/owner/${{ name }}/archive/v${{ version }}.tar.gz\n  sha256: 0000000000000000000000000000000000000000000000000000000000000000\n\nbuild:\n  number: 5\n</code></pre> <p>After running <code>rattler-build bump-recipe --recipe recipe.yaml --version 2.0.0</code>:</p> recipe.yaml (updated)<pre><code>context:\n  name: mypackage\n  version: \"2.0.0\"\n\npackage:\n  name: ${{ name }}\n  version: ${{ version }}\n\nsource:\n  url: https://github.com/owner/${{ name }}/archive/v${{ version }}.tar.gz\n  sha256: 1111111111111111111111111111111111111111111111111111111111111111 # automatically updated\n\nbuild:\n  number: 0 # Note: build number was reset back to `0`\n</code></pre>"},{"location":"bump_recipe/#derived-context-variables","title":"Derived context variables","text":"<p>The command supports context variables that depend on other variables:</p> recipe.yaml<pre><code>context:\n  name: mypackage\n  version: \"1.0.0\"\n  version_underscore: ${{ version | replace('.', '_') }}\n\nsource:\n  url: https://example.com/${{ name }}-${{ version_underscore }}.tar.gz\n  sha256: ...\n</code></pre> <p>When bumping to version <code>2.0.0</code>, the URL will correctly resolve to <code>https://example.com/mypackage-2_0_0.tar.gz</code> because the Jinja expressions are properly evaluated with the new version.</p>"},{"location":"bump_recipe/#build-number-reset","title":"Build number reset","text":"<p>When bumping the version, the command automatically resets the build number to 0. It detects the build number in these locations:</p> <ul> <li><code>context.number</code> or <code>context.build_number</code></li> <li><code>build.number</code></li> </ul> Before bump<pre><code>context:\n  version: \"1.0.0\"\n  build_number: 5\n\nbuild:\n  number: ${{ build_number }}\n</code></pre> After bump<pre><code>context:\n  version: \"2.0.0\"\n  build_number: 0\n\nbuild:\n  number: ${{ build_number }}\n</code></pre>"},{"location":"bump_recipe/#limitations","title":"Limitations","text":"<ul> <li>The version must be defined as a literal value in the <code>context</code> section (not as a Jinja expression)</li> <li>For generic URLs without a known provider, you must specify <code>--version</code> manually</li> </ul>"},{"location":"compilers/","title":"Compilers and cross-compilation","text":"<p>To use a compiler in your project, it's best to use the <code>${{ compiler('lang') }}</code> template function. The compiler function works by taking a language, determining the configured compiler for that language, and adding some information about the target platform to the selected compiler. To configure a compiler for a specific language, the <code>variants.yaml</code> file can be used.</p> <p>For example, in a recipe that uses a C-compiler, you can use the following code:</p> <pre><code>requirements:\n  build:\n    - ${{ compiler('c') }}\n</code></pre> <p>To set the compiler that you want to use, create a variant config that looks like the following:</p> <pre><code>c_compiler:\n  - gcc\n\n# optionally you can specify a version\nc_compiler_version:\n  - 9.3.0\n</code></pre> <p>When the template function is evaluated, it will look something like: <code>gcc_linux-64 9.3.0</code>. You can define your own compilers. For example, for Rust you can use <code>${{ compiler('rust') }}</code> and <code>rust_compiler_{version}</code> in your variant config.</p>"},{"location":"compilers/#cross-compilation","title":"Cross-compilation","text":"<p>Cross-compilation is supported by <code>rattler-build</code> and the compiler template function is part of what makes it possible. When you want to cross-compile from <code>linux-64</code> to <code>linux-aarch64</code> (i.e. intel to ARM), you can pass <code>--target-platform linux-aarch64</code> to the <code>rattler-build</code> command. This will cause the compiler template function to select a compiler that is configured for <code>linux-aarch64</code>. The above example would resolve to <code>gcc_linux-aarch64 9.3.0</code>. Provided that the package is available for <code>linux-64</code> (your build platform), the compilation should succeed.</p> <p>The distinction between the <code>build</code> and <code>host</code> sections begins to make sense when thinking about cross-compilation. The <code>build</code> environment is resolved to packages that need to run at compilation time. For example, <code>cmake</code>, <code>gcc</code>, and <code>autotools</code> are all tools that need to be executed. Therefore, the <code>build</code> environment resolves to packages for the <code>linux-64</code> architecture (in our example). On the other hand, the <code>host</code> packages resolve to <code>linux-aarch64</code> - those are packages that we want to link against.</p> <pre><code># packages that need to run at build time (cmake, gcc, autotools, etc.)\n# in the platform that rattler-build is executed on (the build_platform)\nbuild:\n  - cmake\n  - ${{ compiler('c') }}\n# packages that we want to link against in the architecture we are\n# cross-compiling to the target_platform\nhost:\n  - libcurl\n  - openssl\n</code></pre>"},{"location":"conda_forge/","title":"Publishing to conda-forge","text":"<p>conda-forge is a community-driven collection of recipes and packages for the conda ecosystem. Publishing your package to conda-forge makes it available to millions of users via <code>conda install -c conda-forge &lt;package&gt;</code>.</p>"},{"location":"conda_forge/#overview","title":"Overview","text":"<p>The conda-forge workflow consists of two phases:</p> <ol> <li>Initial submission: Submit your recipe to staged-recipes</li> <li>Maintenance: After approval, your recipe moves to its own \"feedstock\" repository</li> </ol> <pre><code>flowchart LR\n    A[\"Your Recipe&lt;br/&gt;(PR)\"] --&gt; B[\"staged-recipes&lt;br/&gt;(review)\"] --&gt; C[\"your-feedstock&lt;br/&gt;(automated)\"]</code></pre>"},{"location":"conda_forge/#prerequisites","title":"Prerequisites","text":"<p>Before submitting to conda-forge:</p> <ul> <li>Your package should be publicly available (GitHub, PyPI, crates.io, etc.)</li> <li>You have a working <code>recipe.yaml</code> that builds successfully with <code>rattler-build</code></li> <li>The package has an OSI-approved open source license</li> </ul>"},{"location":"conda_forge/#step-1-prepare-your-recipe","title":"Step 1: Prepare your recipe","text":"<p>conda-forge uses the same recipe format as <code>rattler-build</code>. If you've already built your package locally, you're most of the way there.</p>"},{"location":"conda_forge/#recipe-location","title":"Recipe location","text":"<p>Place your recipe in a folder named after your package:</p> <pre><code>recipes/\n\u2514\u2500\u2500 my-package/\n    \u2514\u2500\u2500 recipe.yaml\n</code></pre>"},{"location":"conda_forge/#required-fields","title":"Required fields","text":"<p>Ensure your recipe includes all required metadata:</p> recipe.yaml<pre><code>context:\n  version: \"1.2.3\"\n\npackage:\n  name: my-package\n  version: ${{ version }}\n\nsource:\n  url: https://github.com/owner/repo/archive/v${{ version }}.tar.gz\n  sha256: 0000000000000000000000000000000000000000000000000000000000000000\n\nbuild:\n  number: 0\n  script: python -m pip install . -vv # example for Python\n\nrequirements:\n  host:\n    - python\n    - pip\n  run:\n    - python\n\ntests:\n  - python:\n      imports:\n        - my_package\n\nabout:\n  homepage: https://github.com/owner/repo\n  license: MIT\n  license_file: LICENSE\n  summary: Short description of the package\n  description: |\n    Longer description of what the package does.\n  repository: https://github.com/owner/repo\n  documentation: https://my-package.readthedocs.io\n\nextra:\n  recipe-maintainers:\n    - your-github-username\n</code></pre>"},{"location":"conda_forge/#important-considerations","title":"Important considerations","text":"<ul> <li>License: Use SPDX identifiers and include the license file</li> <li>Tests: Include meaningful tests that verify the package works</li> <li>Maintainers: List GitHub usernames of people who will maintain the recipe</li> <li>Pinning: Don't pin exact versions unless necessary; conda-forge manages pinnings in the conda-forge pinnings.</li> </ul>"},{"location":"conda_forge/#step-2-submit-to-staged-recipes","title":"Step 2: Submit to staged-recipes","text":"<ol> <li> <p>Fork the staged-recipes repository</p> </li> <li> <p>Create a branch for your recipe:    <pre><code>git checkout -b add-my-package\n</code></pre></p> </li> <li> <p>Add your recipe to the <code>recipes/</code> directory:    <pre><code>staged-recipes/\n\u2514\u2500\u2500 recipes/\n    \u2514\u2500\u2500 my-package/\n        \u2514\u2500\u2500 recipe.yaml\n</code></pre></p> </li> <li> <p>Test locally before submitting:    <pre><code>rattler-build build --recipe recipes/my-package/recipe.yaml\n</code></pre></p> </li> <li> <p>Push and create a PR to the main staged-recipes repository</p> </li> </ol>"},{"location":"conda_forge/#pr-checklist","title":"PR checklist","text":"<p>The PR template includes a checklist. Key items:</p> <ul> <li> License file is included in the package</li> <li> Recipe builds on all target platforms</li> <li> Tests are included and pass</li> <li> Recipe follows conda-forge guidelines</li> <li> You've added yourself as a maintainer</li> </ul>"},{"location":"conda_forge/#step-3-review-process","title":"Step 3: Review process","text":"<p>After submitting:</p> <ol> <li>Automated checks run to verify the recipe builds</li> <li>conda-forge reviewers review your recipe (usually within a few days)</li> <li>Address feedback - reviewers may request changes</li> <li>Approval and merge - once approved, your PR is merged</li> </ol>"},{"location":"conda_forge/#common-review-feedback","title":"Common review feedback","text":"<ul> <li>Missing or incorrect license information</li> <li>Tests that don't adequately verify the package</li> <li>Unnecessary version pinning</li> <li>Missing dependencies</li> <li>Platform-specific issues</li> </ul>"},{"location":"conda_forge/#step-4-your-feedstock","title":"Step 4: Your feedstock","text":"<p>After your PR is merged:</p> <ol> <li>A new repository <code>conda-forge/my-package-feedstock</code> is automatically created</li> <li>You're added as a maintainer with write access</li> <li>Builds are triggered automatically for all platforms</li> <li>Packages are published to the <code>conda-forge</code> channel</li> </ol>"},{"location":"conda_forge/#maintaining-your-feedstock","title":"Maintaining your feedstock","text":""},{"location":"conda_forge/#updating-versions","title":"Updating versions","text":"<p>When a new version is released:</p> <ol> <li>Create a PR to your feedstock updating <code>recipe.yaml</code></li> <li>Update the version and sha256 checksum</li> <li>Reset build number to 0</li> <li>CI builds and publishes automatically after merge</li> </ol> <p>You can use <code>rattler-build bump-recipe</code> to help:</p> <pre><code>rattler-build bump-recipe --recipe recipe.yaml --version 1.2.4\n</code></pre>"},{"location":"conda_forge/#automated-version-updates","title":"Automated version updates","text":"<p>conda-forge has bots that can automatically create PRs when new versions are detected:</p> <ul> <li>regro-cf-autotick-bot: Detects new versions on PyPI, GitHub releases, etc.</li> <li>Version updates: Bot creates PRs that you can review and merge</li> </ul>"},{"location":"conda_forge/#rebuilding-packages","title":"Rebuilding packages","text":"<p>To rebuild with updated dependencies (without a version change):</p> <ol> <li>Increment the <code>build.number</code> in your recipe</li> <li>Create a PR to your feedstock</li> <li>Merge after CI passes</li> </ol>"},{"location":"conda_forge/#tips-for-success","title":"Tips for success","text":""},{"location":"conda_forge/#use-noarch-when-possible","title":"Use noarch when possible","text":"<p>For pure Python packages, use <code>noarch: python</code>:</p> <pre><code>build:\n  noarch: python\n</code></pre> <p>This builds once and works on all platforms, reducing CI time and maintenance.</p>"},{"location":"conda_forge/#handle-platform-differences","title":"Handle platform differences","text":"<p>Use selectors for platform-specific logic:</p> <pre><code>requirements:\n  run:\n    - if: win\n      then: pywin32\n    - if: unix\n      then: pexpect\n</code></pre>"},{"location":"conda_forge/#pin-to-conda-forge-packages","title":"Pin to conda-forge packages","text":"<p>Prefer dependencies from conda-forge over system libraries:</p> <pre><code>requirements:\n  host:\n    - openssl  # from conda-forge, not system\n</code></pre>"},{"location":"conda_forge/#resources","title":"Resources","text":"<ul> <li>conda-forge documentation</li> <li>staged-recipes repository</li> <li>conda-forge Zulip chat</li> <li>Recipe format reference</li> </ul>"},{"location":"config/","title":"Rattler-build configuration","text":"<p><code>rattler-build</code> can be configured by specifying <code>--config-file ~/.pixi/config.toml</code>. The config file is of the same format as pixi's global configuration file.</p>"},{"location":"config/#channels","title":"Channels","text":"<p>You can specify custom channels via the <code>default-channels</code> option.</p> config.toml<pre><code>default-channels = [\"conda-forge\", \"bioconda\"]\n</code></pre>"},{"location":"config/#package-format","title":"Package format","text":"<p>You can define the default package format to use for builds. It can be one of <code>tar-bz2</code> or <code>conda</code>. You can also add a compression level to the package format, e.g. <code>tar-bz2:&lt;number&gt;</code> (from 1 to 9) or <code>conda:&lt;number&gt;</code> (from -7 to 22).</p> config.toml<pre><code>[build]\npackage-format = \"conda:22\"\n</code></pre>"},{"location":"config/#mirror-configuration","title":"Mirror configuration","text":"<p>By specifying the <code>mirrors</code> section, you can instruct rattler-build to use mirrors when building. For more information, see pixi's documentation.</p> config.toml<pre><code>[mirrors]\n\"https://conda.anaconda.org/conda-forge\" = [\"https://prefix.dev/conda-forge\"]\n</code></pre>"},{"location":"config/#s3-configuration","title":"S3 configuration","text":"<p>You can configure your S3 buckets that are used during build by specifying <code>s3-options</code>. For more information, consult pixi's documentation.</p> config.toml<pre><code>[s3-options.my-bucket]\nendpoint-url = \"https://fsn1.your-objectstorage.com\"\nregion = \"US\"\nforce-path-style = false\n</code></pre>"},{"location":"converting_from_conda_build/","title":"Converting a recipe from conda-build","text":"<p>The recipe format of <code>rattler-build</code> differs in some aspects from <code>conda-build</code>. This document aims to help you convert a recipe from <code>conda-build</code> to <code>rattler-build</code>.</p>"},{"location":"converting_from_conda_build/#automatic-conversion","title":"Automatic conversion","text":"<p>To convert a recipe from <code>meta.yaml</code> to <code>recipe.yaml</code> you can use the automatic conversion utility.</p> <p>To install <code>conda-recipe-manager</code>, run</p> <pre><code>pixi global install conda-recipe-manager\n# or\nconda install -c conda-forge conda-recipe-manager\n</code></pre> <p>Then, run the conversion utility:</p> <pre><code>conda-recipe-manager convert my-recipe/meta.yaml\n</code></pre> <p>This will print the converted recipe to the console. You can save it to a file by redirecting the output:</p> <pre><code>conda-recipe-manager convert my-recipe/meta.yaml &gt; recipe.yaml\n</code></pre> <p>To learn more about the tool, or contribute, find the repository here.</p>"},{"location":"converting_from_conda_build/#converting-jinja-and-selectors","title":"Converting Jinja and selectors","text":"<p>To use <code>jinja</code> in the new recipes, you need to keep in mind two conversions. The <code>{% set version = \"1.2.3\" %}</code> syntax is replaced by the <code>context</code> section in the new recipe format.</p> <pre><code>{% set version = \"1.2.3\" %}\n</code></pre> <p>becomes</p> <pre><code>context:\n  version: \"1.2.3\"\n</code></pre> <p>To use the values or other Jinja expressions (e.g. from the variant config) you can use the <code>${{ version }}</code> syntax. Note the <code>$</code> sign before the curly braces - it makes Jinja fully compatible with the YAML format.</p> meta.yaml<pre><code># instead of\npackage:\n  version: \"{{ version }}\"\nsource:\n  url: https://example.com/foo-{{ version }}.tar.gz\n</code></pre> <p>becomes</p> recipe.yaml<pre><code>package:\n  version: ${{ version }}\nsource:\n  url: https://example.com/foo-${{ version }}.tar.gz\n</code></pre>"},{"location":"converting_from_conda_build/#converting-selectors","title":"Converting selectors","text":"<p><code>conda-build</code> has a line based \"selector\" system, to e.g. disable certain fields on Windows vs. Unix.</p> <p>In rattler-build we\u00a0use two different syntaxes: an <code>if/else/then</code> map or a inline jinja expression.</p> <p>A typical selector in <code>conda-build</code> looks something like this:</p> meta.yaml<pre><code>requirements:\n  host:\n    - pywin32  # [win]\n</code></pre> <p>To convert this to <code>rattler-build</code> syntax, you can use one of the following two syntaxes:</p> recipe.yaml<pre><code>requirements:\n  host:\n    - ${{ \"pywin32\" if win }}  # empty strings are automatically filtered\n    # or\n    - if: win\n      then:\n        - pywin32  # this list extends the outer list\n</code></pre>"},{"location":"converting_from_conda_build/#converting-the-recipe-script","title":"Converting the recipe script","text":"<p>We still support the <code>build.sh</code> script, but the <code>bld.bat</code> script was renamed to <code>build.bat</code> in order to be more consistent with the <code>build.sh</code> script.</p> <p>You can also choose a different name for your script:</p> <pre><code>build:\n  # note: if there is no extension, we will try to find .sh on unix and .bat on windows\n  script: my_build_script\n</code></pre> <p>There are also new ways of writing scripts, for example with <code>nushell</code> or <code>python</code></p> <p>Variant keys in build scripts</p> <p><code>conda-build</code> tries to analyze the build scripts for any usage of variant keys. We do not attempt that. If you want to use variant keys in your build script that are not used anywhere else you need to manually add them to your script environment, e.g.</p> recipe.yaml<pre><code>build:\n  script:\n    content: echo $MY_VARIANT\n    env:\n      MY_VARIANT: ${{ my_variant }}\n</code></pre>"},{"location":"converting_from_conda_build/#converting-the-recipe-structure","title":"Converting the recipe structure","text":"<p>There are a few differences in the recipe structure. However, the schema will tell you quite easily what is expected and you should see red squiggly lines in your editor (e.g. VSCode) if you make a mistake.</p> <p>Here are a few differences:</p> <ul> <li><code>build.run_exports</code> is now <code>requirements.run_exports</code></li> <li><code>requirements.run_constrained</code> is now <code>requirements.run_constraints</code></li> <li><code>build.ignore_run_exports</code> is now <code>requirements.ignore_run_exports.by_name</code></li> <li><code>build.ignore_run_exports_from</code> is now   <code>requirements.ignore_run_exports.from_package</code></li> <li>A <code>git</code> source now uses <code>git</code>, <code>tag</code>, ... and not <code>git_url</code> and <code>git_rev</code>, e.g.   <pre><code>git: https://github.com/foo/bar.git\ntag: 1.2.3\n</code></pre></li> </ul>"},{"location":"converting_from_conda_build/#converting-the-test-section","title":"Converting the test section","text":"<p>The <code>test</code> section is renamed to <code>tests</code> and is a list of independent tests. Each test runs in its own environment.</p> <p>Let's have a look at converting an existing test section:</p> meta.yaml<pre><code>test:\n  imports:\n    - mypackage\n  commands:\n    - mypackage --version\n</code></pre> <p>This would now be split into two tests:</p> recipe.yaml<pre><code>tests:\n  - script:\n      - mypackage --version\n  - python:\n      imports:\n        - mypackage\n      # by default we perform a `pip check` in the python test but\n      # it can be disabled by setting this to false\n      pip_check: false\n</code></pre> <p>The <code>script</code> tests also take a <code>requirements</code> section with <code>run</code> and <code>build</code> requirements. The <code>build</code> requirements can be used to install emulators and similar tools that need to run to execute tests in a cross-compilation environment.</p>"},{"location":"converting_from_conda_build/#automatic-feedstock-conversion","title":"Automatic feedstock conversion","text":"<p>Use the tool <code>feedrattler</code> by hadim to go directly from an existing conda-forge v0 recipe feedstock to the new v1 recipe used by rattler-build.</p> <p>You can install and use it directly by running <code>pixi exec</code>: <pre><code>pixi exec feedrattler my-awesome-feedstock\n</code></pre></p> <p>It uses the <code>conda-recipe-manager</code> for the generation of the recipe and <code>gh</code> or a <code>GITHUB_TOKEN</code> for creating the conversion PR in your name.</p> <p>Alternative installation: <pre><code># Globally install the tool\npixi global install feedrattler\n# or in a workspace\npixi add feedrattler\n# or using conda/mamba\nconda install -c conda-forge feedrattler\n</code></pre></p>"},{"location":"create_patch/","title":"Creating patches","text":"<p>When packaging software, you often need to make small source code changes \u2013 fixing a typo, applying a bug fix, or adapting build scripts. Instead of maintaining a fork of the upstream project, you can create patch files that are applied during the build process.</p> <p><code>rattler-build</code> provides a streamlined workflow for creating patches using the <code>debug</code> and <code>create-patch</code> commands.</p>"},{"location":"create_patch/#how-it-works","title":"How it works","text":"<p>The <code>debug</code> command sets up a build environment and downloads sources without running the actual build script. This gives you a clean workspace to make changes. The <code>create-patch</code> command then compares your modified files against the original sources and generates a unified diff patch.</p>"},{"location":"create_patch/#basic-workflow","title":"Basic workflow","text":"<pre><code># Set up debug environment and enter the debug shell\nrattler-build debug setup --recipe recipe.yaml\nrattler-build debug shell\n\n# You're now in the work directory with the build environment sourced.\n# Edit files directly:\nvim some_file.c\n\n# Generate patch (from inside the debug shell, the directories are auto-detected)\nrattler-build create-patch --name fix-typo\n\n# Add to recipe\n</code></pre> recipe.yaml<pre><code>source:\n  - url: https://example.com/package.tar.gz\n    sha256: abc123...\n    patches:\n      - fix-typo.patch\n</code></pre>"},{"location":"create_patch/#command-options","title":"Command options","text":"<p>The <code>create-patch</code> command supports the following options:</p> <ul> <li><code>--directory &lt;DIR&gt;</code> - Work directory containing the modified sources (required)</li> <li><code>--name &lt;NAME&gt;</code> - Patch filename without .patch extension (default: \"changes\")</li> <li><code>--patch-dir &lt;DIR&gt;</code> - Directory to write the patch file (default: recipe directory)</li> <li><code>--exclude &lt;PATTERNS&gt;</code> - Files to exclude from the patch (comma-separated glob patterns)</li> <li><code>--dry-run</code> - Preview changes without creating a file</li> </ul>"},{"location":"create_patch/#examples","title":"Examples","text":"<p>Generate a patch with a custom name:</p> <pre><code>rattler-build create-patch --directory work/ --name fix-build-system\n</code></pre> <p>Preview changes before creating the patch:</p> <pre><code>rattler-build create-patch --directory work/ --dry-run\n</code></pre> <p>Create a patch in a dedicated patches folder:</p> <pre><code>rattler-build create-patch --directory work/ \\\n                           --name fix-compilation \\\n                           --patch-dir patches/\n</code></pre>"},{"location":"create_patch/#supported-source-types","title":"Supported source types","text":"<p>Currently, the <code>create-patch</code> command supports:</p> <ul> <li>URL sources - Creates patches for extracted archives (tar.gz, zip, etc.)</li> <li>Git sources - \u26a0\ufe0f Not yet implemented</li> <li>Path sources - \u26a0\ufe0f Not yet implemented</li> </ul>"},{"location":"debugging_builds/","title":"Debugging Builds","text":"<p>This guide covers how to debug conda package builds with rattler-build when things go wrong. It's designed for both humans and AI agents working with recipes.</p>"},{"location":"debugging_builds/#debugging-workflow","title":"Debugging Workflow","text":"<p>Suppose you have a recipe that fails to build:</p> recipe.yaml<pre><code>package:\n  name: test\n  version: \"1.0\"\n\nbuild:\n  script:\n    - exit 1\n</code></pre> <p>Running <code>rattler-build build</code> will fail. When a build fails, the build directory is automatically preserved so you can investigate. There are multiple things you can do to investigate</p>"},{"location":"debugging_builds/#enter-the-debug-shell","title":"Enter the Debug Shell","text":"<p>Jump straight into the failed build environment:</p> <pre><code>rattler-build debug shell\n</code></pre> <p>This opens an interactive shell in the work directory with the build environment loaded. All environment variables (<code>$PREFIX</code>, <code>$BUILD_PREFIX</code>, etc.) are set up exactly as they were during the build.</p> <p>Now you can modify files and run individual commands to isolate the issue:</p> <pre><code>./configure --prefix=$PREFIX\nmake VERBOSE=1\nmake install\n</code></pre>"},{"location":"debugging_builds/#re-run-the-build-script","title":"Re-run the Build Script","text":"<p>Use <code>debug run</code> to re-execute the build script with the full environment already loaded:</p> <pre><code># Re-run the build script\nrattler-build debug run\n\n# Re-run with shell tracing (bash -x) for verbose output\nrattler-build debug run --trace\n</code></pre> <p>You can find the working directory by running the following:</p> <pre><code>rattler-build debug workdir\n</code></pre> <p>Modify files inside that directory and run <code>rattler-build debug run</code> to check whether that fixed the problem.</p>"},{"location":"debugging_builds/#modify-dependencies","title":"Modify Dependencies","text":"<p>If you need additional packages in the host or build environment, you can add them without re-running the full setup:</p> <pre><code># Add packages to the host environment\nrattler-build debug host-add libfoo libbar\n\n# Add build tools\nrattler-build debug build-add gdb valgrind\n</code></pre> <p>Remember to add them to your recipe.yaml once you found the right set of dependencies.</p>"},{"location":"debugging_builds/#create-a-patch-for-fixes","title":"Create a Patch for Fixes","text":"<p>After fixing issues in the source code:</p> <pre><code># Create a patch from your changes\nrattler-build debug create-patch \\\n  --directory . \\\n  --name my-fix \\\n  --exclude \"*.o,*.so,*.pyc\"\n\n# Preview what would be included\nrattler-build debug create-patch \\\n  --directory . \\\n  --name my-fix \\\n  --dry-run\n</code></pre> <p>To include new files:</p> <pre><code>rattler-build debug create-patch \\\n  --directory . \\\n  --name my-fix \\\n  --add \"*.txt,src/new_file.c\"\n</code></pre> <p>In the end, you will have a patch file that you can include in your recipe</p>"},{"location":"debugging_builds/#update-recipe-and-rebuild","title":"Update Recipe and Rebuild","text":"<p>Add the patch to your recipe:</p> <pre><code>source:\n  - url: https://example.com/source.tar.gz\n    sha256: ...\n    patches:\n      # this needs to be manually added\n      - my-fix.patch\n</code></pre> <p>Then rebuild:</p> <pre><code>rattler-build build --recipe recipe.yaml\n</code></pre>"},{"location":"debugging_builds/#debugging-a-successful-build","title":"Debugging a Successful Build","text":"<p>If your recipe builds successfully but you still want to inspect the environment, use <code>--keep-build</code> to prevent cleanup:</p> <pre><code>rattler-build build --recipe recipe.yaml --keep-build\nrattler-build debug shell\n</code></pre>"},{"location":"debugging_builds/#setting-up-a-debug-environment-without-building","title":"Setting Up a Debug Environment Without Building","text":"<p>If you want to prepare a debug environment without running the build script at all, use <code>debug setup</code>. This resolves dependencies, downloads sources, and creates the build script \u2014 but doesn't execute it:</p> <pre><code>rattler-build debug setup --recipe recipe.yaml\nrattler-build debug shell\n</code></pre> <p>This is useful when you want to inspect or modify sources before running the build for the first time.</p>"},{"location":"debugging_builds/#inspecting-and-extracting-packages","title":"Inspecting and Extracting Packages","text":"<p>The <code>rattler-build package</code> subcommand provides utilities for inspecting and extracting built packages, which is useful for debugging package contents.</p>"},{"location":"debugging_builds/#inspecting-packages","title":"Inspecting Packages","text":"<p>Use <code>package inspect</code> to view package metadata without extracting:</p> <pre><code># Basic package information\nrattler-build package inspect mypackage-1.0-h12345.conda\n\n# Show all information including file listing\nrattler-build package inspect mypackage-1.0-h12345.conda --all\n\n# Show specific sections\nrattler-build package inspect mypackage-1.0-h12345.conda --paths      # File listing with hashes\nrattler-build package inspect mypackage-1.0-h12345.conda --about      # Extended about info\nrattler-build package inspect mypackage-1.0-h12345.conda --run-exports # Run exports\n\n# Output as JSON for scripting\nrattler-build package inspect mypackage-1.0-h12345.conda --json\n</code></pre>"},{"location":"debugging_builds/#extracting-packages","title":"Extracting Packages","text":"<p>Use <code>package extract</code> to extract a package to a directory for inspection:</p> <pre><code># Extract to a directory named after the package\nrattler-build package extract mypackage-1.0-h12345.conda\n\n# Extract to a custom destination\nrattler-build package extract mypackage-1.0-h12345.conda -d my-extracted\n\n# Extract directly from a URL (supports authenticated channels)\nrattler-build package extract https://conda.anaconda.org/conda-forge/linux-64/python-3.11.0-h12345.conda\n</code></pre> <p>After extraction, the command reports the SHA256/MD5 checksums and file size, which is useful for verifying package integrity.</p> <p>Both <code>.conda</code> and <code>.tar.bz2</code> package formats are supported.</p>"},{"location":"debugging_builds/#build-directory-structure","title":"Build Directory Structure","text":"<p>When rattler-build builds a package, it creates:</p> <pre><code>output/\n\u2514\u2500 rattler-build-log.txt            # Append-only log of build directories (latest at bottom)\n\u2514\u2500 bld/                             # Build directories\n\u2502   \u2514\u2500 rattler-build_&lt;name&gt;_&lt;timestamp&gt;/\n\u2502       \u2514\u2500 work/                    # Source code and working directory\n\u2502       \u2502   \u2514\u2500 .source_info.json    # Source information (extracted folders, etc.)\n\u2502       \u2502   \u2514\u2500 build_env.sh         # Environment setup script\n\u2502       \u2502   \u2514\u2500 conda_build.sh       # The actual build script (sources `build_env.sh`)\n\u2502       \u2502   \u2514\u2500 conda_build.log      # Complete build output\n\u2502       \u2514\u2500 host_env_placehold_.../  # Host environment (runtime dependencies)\n\u2502       \u2514\u2500 build_env/               # Build environment (build-time dependencies)\n\u2514\u2500 src_cache/                       # Downloaded and extracted sources\n\u2514\u2500 build_cache/                     # Staging cache (experimental)\n\u2502   \u2514\u2500 staging_&lt;sha256&gt;/            # Per-staging-output cache\n\u2502       \u2514\u2500 metadata.json            # Cache metadata (deps, sources, variant)\n\u2502       \u2514\u2500 prefix/                  # Cached prefix files from staging build\n\u2502       \u2514\u2500 work_dir/                # Cached work directory from staging build\n\u2514\u2500 &lt;platform&gt;/                      # Built packages\n</code></pre>"},{"location":"debugging_builds/#environment-variables-available-in-the-debug-shell","title":"Environment Variables Available in the Debug Shell","text":"<p>Inside the debug shell, you have access to:</p> Variable Description <code>$PREFIX</code> Host prefix (where packages get installed) <code>$BUILD_PREFIX</code> Build prefix (tools for building) <code>$SRC_DIR</code> Source directory (same as work directory) <code>$RATTLER_BUILD_DIRECTORIES</code> Full JSON with all directory info <code>$RATTLER_BUILD_RECIPE_PATH</code> Path to the recipe file <code>$RATTLER_BUILD_RECIPE_DIR</code> Directory containing the recipe <code>$RATTLER_BUILD_BUILD_DIR</code> The build directory root <code>$RATTLER_BUILD_HOST_PREFIX</code> Path to the host prefix <code>$RATTLER_BUILD_BUILD_PREFIX</code> Path to the build prefix"},{"location":"debugging_builds/#common-debugging-scenarios","title":"Common Debugging Scenarios","text":""},{"location":"debugging_builds/#compilation-failures","title":"Compilation Failures","text":"<pre><code># Re-run the build script with tracing to see where it fails\nrattler-build debug run --trace\n\n# Or enter the shell and run specific build commands\nrattler-build debug shell\nmake VERBOSE=1\ncmake --build . --verbose\n</code></pre>"},{"location":"debugging_builds/#missing-files-or-dependencies","title":"Missing Files or Dependencies","text":"<pre><code># Check source information\ncat .source_info.json | jq .\n\n# List what's in the work directory\nfind . -type f | head -30\n\n# Check what's in the environments\nls $PREFIX/lib/\nls $BUILD_PREFIX/bin/\n\n# Add a missing dependency on the fly\nrattler-build debug host-add libmissing\n</code></pre>"},{"location":"debugging_builds/#library-not-found-errors","title":"Library Not Found Errors","text":"<pre><code># Check if the library exists in PREFIX\nfind $PREFIX -name \"lib*.so*\" -o -name \"lib*.dylib*\"\n\n# Check pkg-config paths\necho $PKG_CONFIG_PATH\npkg-config --libs --cflags libfoo\n</code></pre>"},{"location":"debugging_builds/#build-log-analysis","title":"Build Log Analysis","text":"<p>All build output is saved to <code>conda_build.log</code>:</p> <pre><code># View the full log\nless conda_build.log\n\n# Search for errors\ngrep -i error conda_build.log\ngrep -i \"undefined reference\" conda_build.log\n</code></pre>"},{"location":"debugging_builds/#debugging-with-ai-agents","title":"Debugging with AI Agents","text":"<p>The <code>debug</code> subcommands are designed to work well with AI coding agents (Claude Code, Codex, etc.) that cannot use interactive shells. The key principle is: set up once, then iterate fast by re-running the build script.</p>"},{"location":"debugging_builds/#agent-workflow","title":"Agent Workflow","text":"<pre><code># 1. Set up the debug environment (slow, only once)\nrattler-build debug setup --recipe recipe.yaml\n\n# 2. Get the work directory\nrattler-build debug workdir\n\n# 3. Edit source files in work directory to fix the issue\n#    (agent edits files directly)\n\n# 4. Re-run the build script (fast \u2014 no dependency resolution)\nrattler-build debug run\n\n# 5. If the build fails, go back to step 3\n# 6. Once it works, create a patch\nrattler-build debug create-patch --name my-fix\n</code></pre>"},{"location":"debugging_builds/#key-points-for-agents","title":"Key Points for Agents","text":"<ul> <li><code>debug setup</code> is non-interactive \u2014 it sets up everything and exits. Use   this instead of <code>debug shell</code> which opens an interactive shell.</li> <li><code>debug workdir</code> prints the work directory path to stdout \u2014 no <code>jq</code> or log   parsing needed.</li> <li><code>debug run</code> re-runs the build script with the environment already set up.   Use <code>--trace</code> for verbose <code>bash -x</code> output. This is the fast inner loop \u2014 it   takes seconds, not minutes, because dependencies are already installed.</li> <li><code>debug host-add</code> / <code>debug build-add</code> let agents add missing dependencies   without re-running the full setup.</li> <li><code>debug create-patch</code> generates a unified diff from changes in the work   directory. The agent can then add the patch to the recipe.</li> </ul>"},{"location":"debugging_builds/#parsing-the-build-log","title":"Parsing the Build Log","text":"<p>The last line of <code>output/rattler-build-log.txt</code> is JSON:</p> <pre><code>{\n  \"work_dir\": \"/path/to/output/bld/rattler-build_pkg_1234/work\",\n  \"build_dir\": \"/path/to/output/bld/rattler-build_pkg_1234\",\n  \"host_prefix\": \"/path/to/output/bld/rattler-build_pkg_1234/host_env_placehold_...\",\n  \"build_prefix\": \"/path/to/output/bld/rattler-build_pkg_1234/build_env\",\n  \"recipe_dir\": \"/path/to/recipe/dir\",\n  \"recipe_path\": \"/path/to/recipe.yaml\",\n  \"output_dir\": \"/path/to/output\"\n}\n</code></pre>"},{"location":"debugging_builds/#understanding-relocatability","title":"Understanding Relocatability","text":"<p>rattler-build makes packages relocatable through:</p> <ol> <li> <p>RPATH patching - Changes <code>.dylib</code> and <code>.so</code> files to use relative paths (<code>$ORIGIN</code>, <code>@loader_path</code>) using <code>patchelf</code> or <code>install_name_tool</code></p> </li> <li> <p>Placeholder replacement - At install time, replaces placeholder strings in binaries and text files with the actual prefix</p> </li> </ol> <p>Important: The placeholder is a long string (<code>placehold_placehol_...</code>). If your code has small buffer optimization or assumes static string lengths for file paths, you may need to adjust it. The <code>$PREFIX</code> length will differ at installation time. The placeholder replacement in binary files will overwrite the placeholder string, move the remainder until <code>\\0</code> is found in the original string, and pad with <code>\\0</code> bytes.</p>"},{"location":"debugging_builds/#useful-commands-reference","title":"Useful Commands Reference","text":"<pre><code># Build commands\nrattler-build build --recipe recipe.yaml --keep-build\nrattler-build build --recipe recipe.yaml --channel conda-forge --no-test\n\n# Debug commands\nrattler-build debug setup --recipe recipe.yaml         # Set up environment\nrattler-build debug shell                              # Open shell in last build\nrattler-build debug shell --work-dir /path/to/work     # Open shell in specific build\nrattler-build debug workdir                            # Print work directory path\nrattler-build debug run                                # Re-run build script\nrattler-build debug run --trace                        # Re-run with bash -x tracing\nrattler-build debug host-add python numpy              # Add packages to host env\nrattler-build debug build-add cmake                    # Add packages to build env\nrattler-build debug create-patch --name fix            # Create patch from changes\nrattler-build debug create-patch --name fix --dry-run  # Preview patch\n\n# Test commands\nrattler-build test --package-file output/linux-64/mypackage-1.0.tar.bz2\n</code></pre>"},{"location":"experimental_features/","title":"Experimental features","text":"<p>Warning</p> <p>These are experimental features of <code>rattler-build</code> and may change or go away completely.</p> <p>Currently only the <code>build</code> and <code>rebuild</code> commands support the following experimental features.</p> <p>To enable them, use the <code>--experimental</code> flag with the command. Or, use the environment variable, <code>RATTLER_BUILD_EXPERIMENTAL=true</code>.</p>"},{"location":"experimental_features/#staging-outputs","title":"Staging outputs","text":"<p>Staging outputs allow you to build code once and cache the results, then have multiple package outputs inherit those cached files. This is useful for splitting a single build into multiple packages (e.g. a runtime library and development headers) without rebuilding.</p> <pre><code>outputs:\n  - staging:\n      name: mylib-build\n    requirements:\n      build:\n        - ${{ compiler('c') }}\n    build:\n      script:\n        - cmake -B build &amp;&amp; cmake --build build --target install\n\n  - package:\n      name: mylib\n    inherit: mylib-build\n    build:\n      files:\n        - lib/**\n\n  - package:\n      name: mylib-dev\n    inherit: mylib-build\n    build:\n      files:\n        - include/**\n</code></pre> <p>See the staging outputs guide for full documentation, and the recipe reference for the complete YAML schema.</p>"},{"location":"experimental_features/#sigstore-source-attestation","title":"Sigstore source attestation","text":"<p>The <code>attestation</code> field on URL sources allows verifying that downloaded source archives were produced by a trusted publisher using Sigstore attestations. This is supported for PyPI packages (where the bundle URL is automatically derived) and GitHub releases (where you specify the <code>bundle_url</code> manually).</p> <pre><code>source:\n  url: https://files.pythonhosted.org/packages/.../flask-3.1.1.tar.gz\n  sha256: \"6489f1...\"\n  attestation:\n    publishers:\n      - github:pallets/flask\n</code></pre> <p>See the Sigstore source attestation documentation for more details.</p>"},{"location":"experimental_features/#jinja-functions","title":"Jinja functions","text":""},{"location":"experimental_features/#load_from_filefile_path","title":"<code>load_from_file(&lt;file_path&gt;)</code>","text":"<p>The Jinja function <code>load_from_file</code> allows loading from files; specifically, it allows loading from <code>toml</code>, <code>json</code>, and <code>yaml</code> file types to an object to allow it to fetch things directly from the file. It loads all other files as strings.</p>"},{"location":"experimental_features/#usage","title":"Usage","text":"<p><code>load_from_file</code> is useful when there is a project description in a well-defined project file such as <code>Cargo.toml</code>, <code>package.json</code>, <code>pyproject.toml</code>, <code>package.yaml</code>, or <code>stack.yaml</code>. It enables the recipe to be preserved in as simple a state as possible, especially when there is no need to keep the changes in sync; some example use cases for this are with CI/CD infrastructure or when there is a well-defined output format.</p> <p>Below is an example loading a <code>Cargo.toml</code> inside of the <code>rattler-build</code> GitHub repository:</p> recipe.yaml<pre><code>context:\n  name: ${{ load_from_file(\"Cargo.toml\").package.name }}\n  version: ${{ load_from_file(\"Cargo.toml\").package.version }}\n  source_url: ${{ load_from_file(\"Cargo.toml\").package.homepage }}\n  rust_toolchain: ${{ load_from_file(\"rust-toolchains\") }}\n\npackage:\n  name: ${{ name }}\n  version: ${{ version }}\n\nsource:\n  git: ${{ source_url }}\n  tag: ${{ source_tag }}\n\nrequirements:\n  build:\n    - rust ==${{ rust_toolchain }}\n\nbuild:\n  script: cargo build --release -p ${{ name }}\n\ntest:\n  - script: cargo test -p ${{ name }}\n  - script: cargo test -p rust-test -- --test-threads=1\n\nabout:\n  home: ${{ source_url }}\n  repository: ${{ source_url }}\n  documentation: ${{ load_from_file(\"Cargo.toml\").package.documentation }}\n  summary: ${{ load_from_file(\"Cargo.toml\").package.description }}\n  license: ${{ load_from_file(\"Cargo.toml\").package.license }}\n</code></pre>"},{"location":"experimental_features/#git-functions","title":"<code>git</code> functions","text":"<p><code>git</code> functions are useful for getting the latest tag and commit hash. These can be used in the <code>context</code> section of the recipe, to fetch version information from a repository.</p> Examples <pre><code># latest tag in the repo\ngit.latest_tag(&lt;git_repo_url&gt;)\n\n# latest tag revision(aka, hash of tag commit) in the repo\ngit.latest_tag_rev(&lt;git_repo_url&gt;)\n\n# latest commit revision(aka, hash of head commit) in the repo\ngit.head_rev(&lt;git_repo_url&gt;)\n</code></pre>"},{"location":"experimental_features/#usage_1","title":"Usage","text":"<p>These can be useful for automating minor things inside of the recipe itself, such as if the current version is the latest version or if the current hash is the latest hash, etc.</p> recipe.yaml<pre><code>context:\n  git_repo_url: \"https://github.com/prefix-dev/rattler-build\"\n  latest_tag: ${{ git.latest_tag( git_repo_url ) }}\n\npackage:\n  name: \"rattler-build\"\n  version: ${{ latest_tag }}\n\nsource:\n  git: ${{ git_repo_url }}\n  tag: ${{ latest_tag }}\n</code></pre> <p>There is currently no guarantee of caching for repo fetches when using <code>git</code> functions. This may lead to some performance issues.</p>"},{"location":"getting_started/","title":"Getting started","text":"<p>This tutorial walks you through building and publishing your first conda package with <code>rattler-build</code>.</p>"},{"location":"getting_started/#creating-a-recipe","title":"Creating a recipe","text":"<p>A recipe is a YAML file that describes how to build a package. Create a file called <code>recipe.yaml</code>:</p> recipe.yaml<pre><code>context:\n  version: \"1.0.0\"\n\npackage:\n  name: hello-world\n  version: ${{ version }}\n\nbuild:\n  number: 0\n  script:\n    - mkdir -p $PREFIX/bin\n    - echo '#!/bin/bash' &gt; $PREFIX/bin/hello\n    - echo 'echo \"Hello, World!\"' &gt;&gt; $PREFIX/bin/hello\n    - chmod +x $PREFIX/bin/hello\n\ntests:\n  - script:\n      - hello\n\nabout:\n  summary: A simple hello world package\n  license: MIT\n</code></pre> <p>This recipe creates a simple shell script that prints \"Hello, World!\".</p>"},{"location":"getting_started/#building-the-package","title":"Building the package","text":"<p>Build the package with the <code>build</code> command:</p> <pre><code>rattler-build build --recipe recipe.yaml\n</code></pre> <p>The build process will:</p> <ol> <li>Create an isolated build environment</li> <li>Run the build script</li> <li>Package the result into a <code>.conda</code> file</li> <li>Run the tests to verify the package works</li> </ol> <p>The output package will be in the <code>output/</code> directory (e.g., <code>output/linux-64/hello-world-1.0.0-h123abc_0.conda</code>).</p>"},{"location":"getting_started/#adding-dependencies","title":"Adding dependencies","text":"<p>Most real-world packages need dependencies. Add them under the <code>requirements</code> section:</p> <pre><code>requirements:\n  build:\n    - ${{ compiler('c') }}     # C compiler for compiled code\n    - cmake                    # Build tools\n    - ninja                    # Another build tool\n  host:\n    - openssl                  # Libraries to link against\n    - python                   # Python for the build environment\n  run:\n    - python                   # Runtime dependencies\n    - numpy &gt;=1.20\n</code></pre> <ul> <li>build: Tools needed to build (compilers, cmake, make)</li> <li>host: Libraries to link against during the build</li> <li>run: Dependencies needed when the package is installed</li> </ul> <p>For complete examples, see the Examples section covering Python, Rust, C++, Go, and more.</p>"},{"location":"getting_started/#common-build-options","title":"Common build options","text":"<pre><code># Add channels for dependencies (note: conda-forge is the default)\nrattler-build build -c conda-forge -c bioconda\n\n# Use variant configurations\nrattler-build build -m variants.yaml\n</code></pre>"},{"location":"getting_started/#debugging-failed-builds","title":"Debugging failed builds","text":"<p>When a build fails, the build directory is preserved automatically. Open a debug shell to investigate:</p> <pre><code>rattler-build debug shell\n</code></pre> <p>This opens a shell with:</p> <ul> <li>All environment variables set (like <code>$PREFIX</code>, <code>$SRC_DIR</code>)</li> <li>The build and host environments activated</li> <li>The source code extracted and patches applied</li> </ul> <p>From here, you can manually run the build script to debug issues:</p> <pre><code># Run the build script that rattler-build generated\n./conda_build.sh\n\n# Open VSCode to edit files or the build script (don't forget to transfer the changes)\ncode .\n\n# Create a patch after editing the files\nrattler-build create-patch ...\n</code></pre> <p>This lets you inspect the environment, test commands interactively, and iterate quickly without re-running the full build process. To learn more about debugging failed builds visit Debugging Builds.</p>"},{"location":"getting_started/#publishing-the-package","title":"Publishing the package","text":"<p>Once your package is built, publish it to a channel with the <code>publish</code> command:</p> <pre><code># Publish to prefix.dev\nrattler-build publish recipe.yaml --to https://prefix.dev/my-channel\n\n# Publish to anaconda.org\nrattler-build publish recipe.yaml --to https://anaconda.org/my-username\n\n# Publish to an S3 bucket\nrattler-build publish recipe.yaml --to s3://my-bucket/my-channel\n\n# Publish to a local directory\nrattler-build publish recipe.yaml --to /path/to/local/channel\n</code></pre> <p>The <code>publish</code> command combines building and uploading in one step. You can also publish pre-built packages directly:</p> <pre><code>rattler-build publish output/linux-64/hello-world-1.0.0-h123abc_0.conda --to https://prefix.dev/my-channel\n</code></pre>"},{"location":"getting_started/#authentication","title":"Authentication","text":"<p>Before publishing, authenticate with your channel:</p> <pre><code># prefix.dev\nrattler-build auth login prefix.dev --token &lt;your-token&gt;\n\n# anaconda.org\nrattler-build auth login anaconda.org --conda-token &lt;your-token&gt;\n</code></pre> <p>See Server authentication for more details.</p>"},{"location":"getting_started/#bumping-the-build-number","title":"Bumping the build number","text":"<p>When republishing a package with the same version (e.g., to pick up updated dependencies), increment the build number:</p> <pre><code># Automatically increment from the highest build number in the channel\nrattler-build publish recipe.yaml --to https://prefix.dev/my-channel --build-number=+1\n\n# Set an explicit build number\nrattler-build publish recipe.yaml --to https://prefix.dev/my-channel --build-number=5\n</code></pre>"},{"location":"getting_started/#updating-to-a-new-version","title":"Updating to a new version","text":"<p>When a new upstream version is released, use <code>bump-recipe</code> to update your recipe:</p> <pre><code># Auto-detect latest version from source URL (GitHub, PyPI, crates.io)\nrattler-build bump-recipe --recipe recipe.yaml\n\n# Specify a version explicitly\nrattler-build bump-recipe --recipe recipe.yaml --version 1.2.0\n\n# Check for updates without modifying\nrattler-build bump-recipe --recipe recipe.yaml --check-only\n</code></pre> <p>This command updates both the version and the SHA256 checksum in your recipe.</p>"},{"location":"getting_started/#setting-up-github-actions","title":"Setting up GitHub Actions","text":"<p>Automate your builds with the rattler-build-action.</p>"},{"location":"getting_started/#basic-workflow","title":"Basic workflow","text":".github/workflows/build.yml<pre><code>name: Build Package\n\non:\n  push:\n    branches: [main]\n  pull_request:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build conda package\n        uses: prefix-dev/rattler-build-action@v0.2.34\n</code></pre> <p>By default, this builds the recipe at <code>conda.recipe/recipe.yaml</code> and uploads the built package as a GitHub Actions artifact.</p>"},{"location":"getting_started/#multi-platform-builds","title":"Multi-platform builds","text":"<p>Build for multiple platforms using a matrix:</p> .github/workflows/build.yml<pre><code>name: Build Package\n\non:\n  push:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        include:\n          - os: ubuntu-latest\n            target-platform: linux-64\n          - os: macos-latest\n            target-platform: osx-arm64\n          - os: windows-latest\n            target-platform: win-64\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build conda package\n        uses: prefix-dev/rattler-build-action@v0.2.34\n        with:\n          artifact-name: package-${{ matrix.target-platform }}\n          build-args: --target-platform ${{ matrix.target-platform }}\n</code></pre>"},{"location":"getting_started/#publishing-with-oidc-no-secrets-required","title":"Publishing with OIDC (no secrets required)","text":"<p>For prefix.dev, you can use trusted publishing with OIDC - no API keys needed:</p> .github/workflows/publish.yml<pre><code>name: Publish Package\n\non:\n  release:\n    types: [published]\n\npermissions:\n  contents: read\n  id-token: write  # Required for OIDC\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build conda package\n        uses: prefix-dev/rattler-build-action@v0.2.34\n\n      - name: Publish to prefix.dev\n        run: |\n          for pkg in $(find output -type f \\( -name \"*.conda\" -o -name \"*.tar.bz2\" \\)); do\n            rattler-build upload prefix -c my-channel \"$pkg\"\n          done\n</code></pre> <p>First, configure trusted publishing in your prefix.dev channel settings by adding your GitHub repository and workflow.</p>"},{"location":"getting_started/#publishing-to-anacondaorg","title":"Publishing to anaconda.org","text":".github/workflows/publish.yml<pre><code>name: Publish Package\n\non:\n  release:\n    types: [published]\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build conda package\n        uses: prefix-dev/rattler-build-action@v0.2.34\n\n      - name: Publish to anaconda.org\n        run: |\n          for pkg in $(find output -type f \\( -name \"*.conda\" -o -name \"*.tar.bz2\" \\)); do\n            rattler-build upload anaconda -o my-org \"$pkg\"\n          done\n        env:\n          ANACONDA_API_KEY: ${{ secrets.ANACONDA_API_KEY }}\n</code></pre>"},{"location":"getting_started/#action-options","title":"Action options","text":"Option Description Default <code>recipe-path</code> Path to the recipe file <code>conda.recipe/recipe.yaml</code> <code>build-args</code> Additional arguments for <code>rattler-build build</code> <code>upload-artifact</code> Upload built packages as artifacts <code>true</code> <code>artifact-name</code> Name for the artifact (use with matrix builds) <code>package</code> <code>rattler-build-version</code> Version of rattler-build to use latest"},{"location":"getting_started/#next-steps","title":"Next steps","text":"<ul> <li>Learn about variants for building multiple configurations</li> <li>Explore testing options for your packages</li> <li>See language-specific examples in the Examples section</li> </ul>"},{"location":"highlevel/","title":"What is <code>rattler-build</code>?","text":"<p><code>rattler-build</code> is a tool to build and package software so that it can be installed on any operating system \u2013 with any compatible package manager such as <code>mamba</code>, <code>conda</code>, or <code>rattler</code>. We are also intending for <code>rattler-build</code> to be used as a library to drive builds of packages from any other recipe format in the future.</p>"},{"location":"highlevel/#how-does-rattler-build-work","title":"How does <code>rattler-build</code> work?","text":"<p>Building of packages consists of several steps. It all begins with a <code>recipe.yaml</code> file that specifies how the package is to be built and what the dependencies are. From the recipe file, <code>rattler-build</code> executes several steps:</p> <ol> <li> <p>Rendering: Parse the recipe file and evaluate conditionals, Jinja expressions, and variables, and variants.</p> </li> <li> <p>Fetch source: Retrieve specified source files, such as <code>.tar.gz</code> files, <code>git</code> repositories, local paths. Additionally, this step will apply patches that can be specified alongside the source file.</p> </li> <li> <p>Install build environments: Download and install dependencies into temporary \"host\" and \"build\" workspaces. Any dependencies that are needed at build time are installed in this step.</p> </li> <li> <p>Build source: Execute the build script to build/compile the source code and install it into the host environment.</p> </li> <li> <p>Prepare package files: Collect all files that are new in the \"host\" environment and apply some transformations if necessary; specifically, we edit the <code>rpath</code> on <code>Linux</code> and <code>macOS</code> to make binaries relocatable.</p> </li> <li> <p>Package: Bundle all the files in a package and write out any additional metadata into the <code>info/index.json</code>, <code>info/about.json</code>, and <code>info/paths.json</code> files. This also creates the test files that are bundled with the package.</p> </li> <li> <p>Test: Run any tests specified in the recipe. The package is considered done if it passes all the tests, otherwise its moved to <code>broken/</code> in the output directory.</p> </li> </ol> <p>After this process, a package is created. This package can be uploaded to somewhere like a custom prefix.dev private or public channel.</p>"},{"location":"highlevel/#how-to-run-rattler-build","title":"How to run <code>rattler-build</code>","text":"<p>Running <code>rattler-build</code> is straightforward. It can be done on the command line:</p> <pre><code>rattler-build build --recipe myrecipe/recipe.yaml\n</code></pre> <p>A custom channel that is not conda-forge (the default) can be specified like so:</p> <pre><code>rattler-build build -c robostack --recipe myrecipe/recipe.yaml\n</code></pre> <p>You can also use the <code>--recipe-dir</code> argument if you want to build all the packages in a directory:</p> <pre><code>rattler-build build --recipe-dir myrecipes/\n</code></pre>"},{"location":"highlevel/#overview-of-a-recipeyaml","title":"Overview of a <code>recipe.yaml</code>","text":"<p>A <code>recipe.yaml</code> file is separated into multiple sections and can conditionally include or exclude sections. Recipe files also support a limited amount of string interpolation with Jinja (specifically <code>minijinja</code> in our case).</p> <p>A simple example of a recipe file for the <code>zlib</code> package would look as follows:</p> recipe.yaml<pre><code># variables from the context section can be used in the rest of the recipe\n# in jinja expressions\ncontext:\n  version: 1.2.13\n\npackage:\n  name: zlib\n  version: ${{ version }}\n\nsource:\n  url: http://zlib.net/zlib-${{ version }}.tar.gz\n  sha256: b3a24de97a8fdbc835b9833169501030b8977031bcb54b3b3ac13740f846ab30\n\nbuild:\n  # build numbers can be set arbitrarily\n  number: 0\n  script:\n    # build script to install the package into the $PREFIX (host prefix)\n    - if: unix\n      then:\n        - ./configure --prefix=$PREFIX\n        - make -j$CPU_COUNT\n    - if: win\n      then:\n        - cmake -G \"Ninja\" -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=%LIBRARY_PREFIX%\n        - ninja install\n\nrequirements:\n  build:\n    # compiler is a special function.\n    - ${{ compiler(\"c\") }}\n    # The following two dependencies are only needed on Windows,\n    # and thus conditionally selected\n    - if: win\n      then:\n        - cmake\n        - ninja\n    - if: unix\n      then:\n        - make\n</code></pre> <p>The sections of a recipe are:</p> sections description <code>context</code> Defines variables that can be used in the Jinja context later in the recipe (e.g. name and version are commonly interpolated in strings) <code>package</code> This section defines the name and version of the package you are currently building and will be the name of the final output <code>source</code> Defines where the source code is going to be downloaded from and checksums <code>build</code> Settings for the build and the build script <code>requirements</code> Allows the definition of build, host, run and run-constrained dependencies"},{"location":"internals/","title":"What does <code>rattler-build</code> do to build a package?","text":"<p><code>rattler-build</code> creates conda packages which are relocatable packages. These packages are built up with some rules and conventions in mind.</p>"},{"location":"internals/#what-goes-into-a-package","title":"What goes into a package?","text":"<p>Generally speaking, any new files that are copied into the <code>$PREFIX</code> directory at build time are part of the new package. However, there is some filtering going on to exclude unwanted files, and <code>noarch: python</code> packages have special handling as well. The rules are as follows:</p>"},{"location":"internals/#filtering","title":"Filtering","text":""},{"location":"internals/#general-file-filtering","title":"General File Filtering","text":"<p>Certain files are filtered out to prevent them from being included in the package. These include:</p> <ul> <li>.pyo files: Optimized Python files are not included because they are   considered harmful.</li> <li>.la files: Libtool archive files that are not needed at runtime.</li> <li>.DS_Store files: macOS-specific files that are irrelevant to the package.</li> <li>.git files and directories: Version control files, including <code>.gitignore</code>   and the <code>.git</code> directory, which are not needed in the package.</li> <li>share/info/dir This file is ignored because it would be written from   multiple packages.</li> </ul>"},{"location":"internals/#special-handling-for-noarch-python-packages","title":"Special Handling for <code>noarch: python</code> Packages","text":"<p>For packages marked as <code>noarch: python</code>, special transformations are applied to ensure compatibility across different platforms:</p> <ul> <li>Stripping Python Library Prefix: The \"lib/pythonX.X\" prefix is removed,   retaining only the \"site-packages\" part of the path.</li> <li>Skipping <code>__pycache__</code> Directories and <code>.pyc</code> Files: These are excluded   and recreated during installation (they are specific to the Python version).</li> <li>Replacing <code>bin</code> and <code>Scripts</code> Directories:<ul> <li>On Unix systems, the <code>bin</code> directory is replaced with <code>python-scripts</code>.</li> <li>On Windows systems, the <code>Scripts</code> directory is replaced with   <code>python-scripts</code>.</li> </ul> </li> <li>Remove explicitly mentioned entrypoints: For <code>noarch: python</code> packages,   entry points registered in the package are also taken into account. Files in   the <code>bin</code> or <code>Scripts</code> directories that match entry points are excluded to   avoid duplications.</li> </ul>"},{"location":"internals/#symlink-handling","title":"Symlink Handling","text":"<p>Symlinks are carefully managed to ensure they are relative rather than absolute, which aids in making the package relocatable:</p> <ul> <li>Absolute symlinks pointing within the <code>$PREFIX</code> are converted to relative   symlinks.</li> <li>On Unix systems, this conversion is handled directly by creating new relative   symlinks.</li> <li>On Windows, a warning is issued since symlink creation requires administrator   privileges.</li> </ul>"},{"location":"internals/#making-packages-relocatable-with-rattler-build","title":"Making Packages Relocatable with <code>rattler-build</code>","text":"<p>Often, the most challenging aspect of building a package using <code>rattler-build</code> is making it relocatable. A relocatable package can be installed into any prefix, allowing it to be used outside the environment in which it was built. This is in contrast to a non-relocatable package, which can only be utilized within its original build environment.</p> <p><code>rattler-build</code> automatically performs the following actions to make packages relocatable:</p> <ol> <li>Binary object file conversion: Binary object files are converted to use    relative paths using <code>install_name_tool</code> on macOS and <code>patchelf</code> on Linux.    This uses <code>$ORIGIN</code> for elf files on Linux and <code>@loader_path</code> for Mach-O    files on macOS to make the <code>rpath</code> relative to the executable / shared    library.</li> <li>Text file prefix registration: Any text file without <code>NULL</code> bytes    containing the placeholder prefix have the registered prefix replaced with    the install prefix.</li> <li>Binary file prefix detection and registration: Binary files containing the build prefix can be automatically registered. The registered files will have their build prefix replaced with the install prefix at install time. This works by padding the install prefix with null terminators, such that the length of the binary file remains the same. The build prefix must be long enough to accommodate any reasonable installation prefix. On macOS and Linux, <code>rattler-build</code> pads the build prefix to 255 characters by appending <code>_placehold</code> to the end of the build directory name.</li> </ol>"},{"location":"multiple_output_cache/","title":"Staging outputs for multiple packages","text":"<p>Note</p> <p>Staging outputs are different from a compilation cache. If you look for tips and tricks on how to use <code>sccache</code> or <code>ccache</code> with <code>rattler-build</code>, please refer to the tips and tricks section.</p> <p>Sometimes you build a package and want to split the contents into multiple sub-packages. For example, when building a C/C++ package, you might want to create multiple packages for the runtime requirements (library), and the development time requirements such as header files.</p> <p>Staging outputs make this easy. A staging output runs its build script once, then copies its files directly into each inheriting package's prefix. Since these are \"new\" files in the prefix, they will be included in the output package.</p> <p>Let's take a look at an example:</p> recipe.yaml<pre><code>recipe:\n  name: mypackage\n  version: '0.1.0'\n\nsource:\n  - url: https://example.com/library.tar.gz\n    sha256: 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n\noutputs:\n  # Staging output - builds once and caches results\n  - staging:\n      name: mypackage-build\n    requirements:\n      build:\n        - ${{ compiler('c') }}\n    build:\n      script:\n        - mkdir -p $PREFIX/lib\n        - mkdir -p $PREFIX/include\n        - echo \"This is the library\" &gt; $PREFIX/lib/library.txt\n        - echo \"This is the header\" &gt; $PREFIX/include/header.txt\n\n  # First package output inheriting from staging\n  - package:\n      name: mypackage-library\n    inherit: mypackage-build\n    build:\n      files:\n        - lib/*\n\n  # Second package output inheriting from staging\n  - package:\n      name: mypackage-headers\n    inherit: mypackage-build\n    build:\n      files:\n        - include/*\n</code></pre> <p>Note</p> <p>Since this is an experimental feature, you need to pass the <code>--experimental</code> flag to enable parsing of staging outputs.</p> <p>In this example, we have a staging output called <code>mypackage-build</code> that creates files during its build. The two package outputs <code>mypackage-library</code> and <code>mypackage-headers</code> inherit from it using the <code>inherit:</code> key.</p> <p>When building, the staging output runs first and creates files in <code>$PREFIX</code>. These files are then copied into the <code>$PREFIX</code> of each inheriting output package. The easiest way to select a subset of the files in the prefix is by using the <code>files</code> field in the output definition. You can use a list of globs to select only the files that you want.</p> <p>For something more complicated you can also use <code>include</code> and <code>exclude</code> fields in the <code>files</code> selector. Please refer to the the build options documentation.</p>"},{"location":"multiple_output_cache/#run-exports-from-staging","title":"Run exports from staging","text":"<p>Since the staging output also has build- and host requirements we need to additionally take care of eventual \"run-exports\" from the staging output. Run exports from the staging dependencies are handled very similar to the run exports from a given output. We append any run exports to the inheriting outputs.</p> <p>You can control whether run exports are inherited using the extended <code>inherit:</code> syntax:</p> <pre><code># Simple inherit (includes run exports by default)\ninherit: staging-name\n\n# Extended inherit with run exports control\ninherit:\n  from: staging-name\n  run_exports: false  # Disable inheriting run exports\n</code></pre> <p>If the staging output has an <code>ignore_run_exports</code> section, those filters are applied at the staging level before run exports reach any inheriting package. If an inheriting output also ignores run exports, those filters are applied additionally.</p> <p>You can filter run exports at the staging level using <code>from_package</code> or <code>by_name</code>:</p> <pre><code>outputs:\n  - staging:\n      name: build-stage\n    requirements:\n      host:\n        - some-dep\n      ignore_run_exports:\n        from_package:\n          - some-dep       # ignore run exports originating from some-dep\n        # alternatively:\n        # by_name:\n        #   - some-dep     # ignore run exports matching the name \"some-dep\"\n\n  - package:\n      name: mypkg\n    inherit: build-stage\n</code></pre>"},{"location":"multiple_output_cache/#source-code-with-staging","title":"Source code with staging","text":"<p>The top-level <code>source</code> section provides source code that is available to both the staging output and all package outputs. For every output, the (dirty) source is restored from the staging directory. Outputs can layer additional files on top of the staging source.</p> <p>If you already ran <code>cmake</code> in the staging output, you can continue from where the build left off in subsequent outputs. This is useful when you want to e.g. build additional components (such as Python bindings) on top of the already-built library.</p>"},{"location":"multiple_output_cache/#work-directory-caching","title":"Work directory caching","text":"<p>The staging cache preserves not just prefix files but also the entire work directory from the staging build. When a package output inherits from staging, both the prefix and the work directory are restored. This means that build artifacts like compiled object files, CMake build directories, and generated configuration files are available to the inheriting package's build script.</p> <p>For example, if your staging output runs <code>cmake</code> and <code>make</code>, an inheriting package can <code>cd build &amp;&amp; make install</code> additional targets without recompiling from scratch.</p>"},{"location":"multiple_output_cache/#top-level-inheritance","title":"Top-level inheritance","text":"<p>In recipes that have both a top-level <code>build:</code> section and staging outputs, package outputs can choose where to inherit from. By default, listing <code>inherit: cache-name</code> inherits from a staging cache. To inherit from the top-level build instead, use <code>inherit: null</code>:</p> <pre><code>build:\n  script:\n    - if: unix\n      then: |\n        mkdir -p $PREFIX/share\n        echo \"data\" &gt; $PREFIX/share/data.txt\n\noutputs:\n  - staging:\n      name: compile-stage\n    build:\n      script:\n        - if: unix\n          then: |\n            mkdir -p $PREFIX/lib\n            echo \"compiled.so\" &gt; $PREFIX/lib/compiled.so\n\n  # Inherits compiled library from staging\n  - package:\n      name: compiled-pkg\n    inherit: compile-stage\n    build:\n      files:\n        - lib/**\n\n  # Inherits data files from the top-level build\n  - package:\n      name: data-pkg\n    inherit: null\n    build:\n      files:\n        - share/**\n</code></pre>"},{"location":"multiple_output_cache/#multiple-staging-caches","title":"Multiple staging caches","text":"<p>A recipe can define multiple independent staging outputs. Each staging output is built and cached separately, and different package outputs can inherit from different staging caches:</p> <pre><code>outputs:\n  # First staging output - builds core C library\n  - staging:\n      name: core-build\n    requirements:\n      build:\n        - ${{ compiler('c') }}\n        - cmake\n      host:\n        - zlib\n    build:\n      script:\n        - cmake -B build &amp;&amp; cmake --build build --target install\n\n  # Second staging output - builds Python bindings\n  - staging:\n      name: python-build\n    requirements:\n      build:\n        - python\n        - setuptools\n      host:\n        - python\n    build:\n      script:\n        - python -m pip install . --prefix=$PREFIX\n\n  # Inherits from core-build\n  - package:\n      name: libcore\n    inherit: core-build\n    build:\n      files:\n        - lib/**\n\n  # Inherits from core-build (different file selection)\n  - package:\n      name: core-headers\n    inherit: core-build\n    build:\n      files:\n        - include/**\n\n  # Inherits from python-build\n  - package:\n      name: python-mycore\n    inherit: python-build\n    requirements:\n      run:\n        - python\n</code></pre>"},{"location":"multiple_output_cache/#variants-and-staging","title":"Variants and staging","text":"<p>Staging caches interact with variant configuration. The cache key includes only the variant variables that are referenced in the staging output's requirements. This means:</p> <ul> <li>Different variants produce different staging caches</li> <li>The staging build is only rerun when its relevant variant keys change</li> <li>Inheriting packages can add their own variant dimensions (e.g. a <code>python</code>   version) on top of the staging cache</li> </ul> <p>For example, if a staging output depends on <code>libfoo</code> and <code>libfoo</code> has variants <code>[1.0, 2.0]</code>, the staging build runs once per <code>libfoo</code> variant. An inheriting package that additionally depends on <code>python</code> expands the matrix further (one package per <code>libfoo</code> \u00d7 <code>python</code> combination), but the staging cache is reused across <code>python</code> variants.</p>"},{"location":"multiple_output_cache/#how-caching-works","title":"How caching works","text":"<p>The staging cache is keyed by a SHA256 hash over:</p> <ul> <li>The staging output's resolved requirements (build and host dependencies)</li> <li>Relevant variant variables (only those referenced in the staging requirements)</li> <li><code>host_platform</code> and <code>build_platform</code> (always included)</li> </ul> <p>Staging caches are stored under <code>output/build_cache/staging_&lt;hash&gt;/</code>. Each cache directory contains:</p> <pre><code>output/build_cache/staging_&lt;sha256&gt;/\n\u251c\u2500 metadata.json    # Cache metadata (deps, sources, file lists, variant)\n\u251c\u2500 prefix/          # Cached prefix files (only files added by the build script)\n\u2514\u2500 work_dir/        # Cached work directory\n</code></pre> <p>On a cache hit, the staging build script is skipped entirely \u2014 the cached prefix and work directory files are restored directly. On a cache miss, the full build runs and the results are cached for future use.</p> <p>To force a staging cache rebuild, delete the corresponding directory under <code>output/build_cache/</code>.</p>"},{"location":"multiple_output_cache/#symlink-handling","title":"Symlink handling","text":"<p>Symlinks created during the staging build are preserved in the cache. Both relative and absolute symlinks are cached and restored correctly, including broken symlinks (symlinks whose target does not exist). On Unix systems, symbolic links are used; on Windows, junction points are created where applicable.</p>"},{"location":"multiple_output_cache/#file-capture","title":"File capture","text":"<p>Only files added by the build script are cached \u2014 files that were already present in the host environment from dependencies are excluded. This means the staging cache contains exactly the files that the build script installed into <code>$PREFIX</code>, not the entire environment.</p>"},{"location":"multiple_output_cache/#c-example-that-builds-python-bindings-on-top-of-a-library","title":"C++ Example that builds Python bindings on top of a library","text":"<p>You can find an example (with source code) here: Link.</p> variants.yaml<pre><code>python:\n  - \"3.12.*\"\n  - \"3.11.*\"\n</code></pre> <p>And the corresponding recipe:</p> recipe.yaml<pre><code>recipe:\n  name: calculator\n  version: 1.0.0\n\nsource:\n  path: ../\n\noutputs:\n  # Staging output - builds the C++ library once\n  - staging:\n      name: calculator-build\n    requirements:\n      build:\n        - ${{ compiler('cxx') }}\n        - cmake\n        - ninja\n    build:\n      script:\n        # make sure that `alternative_name.md` is not present\n        - test ! -f ./alternative_name.md\n        - mkdir build\n        - cd build\n        - cmake $SRC_DIR -GNinja ${CMAKE_ARGS}\n        - ninja install\n\n  # This output inherits all files installed during the staging build\n  - package:\n      name: libcalculator\n    inherit: calculator-build\n    requirements:\n      run_exports:\n        - ${{ pin_subpackage('libcalculator') }}\n\n  # This output builds Python bindings on top of the staged build\n  - package:\n      name: py-calculator\n    inherit: calculator-build\n    source:\n      - path: ../README.md\n        file_name: alternative_name.md\n\n    requirements:\n      build:\n        - ${{ compiler('cxx') }}\n        - cmake\n        - ninja\n      host:\n        - pybind11\n        - python\n        - libcalculator\n\n    build:\n      script:\n        # assert that the README.md file is present\n        - test -f ./alternative_name.md\n        - cd build\n        - cmake $SRC_DIR -GNinja ${CMAKE_ARGS} -DBUILD_PYTHON_BINDINGS=ON\n        - ninja install\n</code></pre>"},{"location":"package_spec/","title":"Package specification","text":"<p><code>rattler-build</code> produces \"conda\" packages. These packages work with the <code>mamba</code> and <code>conda</code> package managers, and they work cross-platform on Windows, Linux and macOS.</p> <p>By default, a conda package is a <code>tar.bz2</code> archive which contains:</p> <ul> <li>Metadata under the <code>info/</code> directory</li> <li>A collection of files that are installed directly into an install prefix</li> </ul> <p>The format is identical across platforms and operating systems. During the install process, all files are extracted into the install prefix, except the ones in <code>info/</code>. Installing a conda package into an environment is similar to executing the following commands:</p> <pre><code>cd &lt;environment prefix&gt;\ntar xjf mypkg-1.0.0-h2134.tar.bz2\n</code></pre> <p>Only files, including symbolic links, are part of a conda package. Directories are not included. Directories are created and removed as needed, but you cannot create an empty directory from the tar archive directly.</p> <p>There is also a newer archive type, suffixed with <code>.conda</code>. This archive type consists of an outer \"zip\" archive that is not compressed, and two inner archives that are compressed with <code>zstd</code>, which is very fast for decompression.</p> <p>The inner archives are split into <code>info</code> and <code>pkg</code> files, which makes it possible to extract only the <code>info</code> part of the archive (only the metadata), which is often smaller in size.</p>"},{"location":"package_spec/#package-filename","title":"Package filename","text":"<p>A conda package conforms to the following filename:</p> <pre><code>&lt;name&gt;-&lt;version&gt;-&lt;hash&gt;.tar.bz2 OR &lt;name&gt;-&lt;version&gt;-&lt;hash&gt;.conda\n</code></pre>"},{"location":"package_spec/#special-files-in-packages","title":"Special files in packages","text":"<p>There are some special files in a package:</p> <ul> <li>activation and deactivation scripts that are executed when the environment is   activated or deactivated</li> <li>post-link and pre-unlink scripts that are executed when the package is   installed or uninstalled</li> </ul> <p>You can read more about these files in the activation scripts and other special files section.</p>"},{"location":"package_spec/#package-metadata","title":"Package metadata","text":"<p>The <code>info/</code> directory contains all metadata about a package. Files in this location are not installed under the install prefix. Although you are free to add any file to this directory, conda only inspects the content of the files discussed below:</p>"},{"location":"package_spec/#infoindexjson","title":"<code>info/index.json</code>","text":"<p>This file contains basic information about the package, such as name, version, build string, and dependencies. The content of this file is stored in <code>repodata.json</code>, which is the repository index file, hence the name <code>index.json</code>. The JSON object is a dictionary containing the keys shown below.</p> <code>name: string</code> <p>The lowercase name of the package. May contain lowercase characters, underscores, and dashes.</p> <code>version: string</code> <p>The package version. May not contain \"<code>-</code>\". Acknowledges PEP 440.</p> <code>build: string</code> <p>The build string. May not contain \"<code>-</code>\". Differentiates builds of packages with   otherwise identical names and versions, such as:</p> <ul> <li>A build with other dependencies, such as Python 3.4 instead of Python 2.7.</li> <li>A bug fix in the build process.</li> <li>Some different optional dependencies, such as MKL versus ATLAS linkage.     Nothing in conda actually inspects the build string. Strings such as     <code>np18py34_1</code> are designed only for human readability and conda never parses     them.</li> </ul> <code>build_number: integer</code> <p>A non-negative integer representing the build number of the package. Unlike   the build string, the <code>build_number</code> is inspected by conda. Conda uses it to   sort packages that have otherwise identical names and versions to determine   the latest one. This is important because new builds that contain bug fixes   for the way a package is built may be added to a repository.</p> <code>depends: list of match specs</code> <p>A list of dependency specifications, where each element is a string. These come from the <code>run</code> section of the recipe or any run exports of dependencies.</p> <code>constrains: list of match specs</code> <p>A list of optional dependency constraints. The packages listed under <code>constrains</code> are not installed by default, but if they are installed they have   to respect the constraints.</p> <code>subdir: string</code> <p>The subdir (like <code>linux-64</code>) of this package.</p> <code>arch: string</code> <p>Optional. The architecture the package is built for. EXAMPLE: <code>x86_64</code>. This key is generally not used (duplicate information from <code>sudir</code>).</p> <code>platform: string</code> <p>Optional. The OS that the package is built for, e.g. <code>osx</code>. This key is generally not used (duplicate information from <code>sudir</code>).</p>"},{"location":"package_spec/#infopathsjson","title":"<code>info/paths.json</code>","text":"<p>The <code>paths.json</code> file lists all files that are installed into the environment.</p> <p>It consists of a list of path entries, each with the following keys:</p> <code>_path: string</code> <p>The relative path of the file</p> <code>path_type: optional, string</code> <p>The type of linking, can be <code>hardlink</code>, <code>softlink</code>, or <code>directory</code>. Default is   <code>hardlink</code>.</p> <code>file_mode: - optional, string</code> <p>The file mode can be <code>binary</code> or <code>text</code>. This is only relevant for prefix   replacement.</p> <code>prefix_placeholder: optional, string</code> <p>The prefix placeholder string that is encoded in the text or binary file, which   is replaced at installation time. Note that this prefix placeholder uses   <code>/</code> even on Windows.</p> <code>no_link: bool, optional</code> <p>Determines whether this file should be linked or not when installing the package   (linking the file from the cache into the environment). Defaults to <code>false</code>.</p> <code>sha256: string</code> <p>The <code>SHA256</code> hash of the file. For symbolic links it contains the <code>SHA256</code> hash of   the file pointed to.</p> <code>size_in_bytes: number</code> <p>The size, in bytes, of the file. For symbolic links, it contains the file size   of the file pointed to.</p> <p>Due to the way the binary replacement works, the placeholder prefix must be longer than the install prefix.</p>"},{"location":"package_spec/#infolicense","title":"<code>info/license/&lt;...&gt;</code>","text":"<p>All licenses mentioned in the recipe are copied to this folder.</p>"},{"location":"package_spec/#infoaboutjson","title":"<code>info/about.json</code>","text":"<p>Optional file. Contains the entries of the \"about\" section of the recipe of the <code>recipe.yaml</code> file. The following keys are added to <code>info/about.json</code> if present in the build recipe:</p> <p>Renamed fields</p> <p>The new recipe spec renamed a few fields (from conda-build's original implementation). This means that some fields in the <code>about.json</code> file still have the old names (for backwards compatibility), while you would generally use different names in the recipe.</p> <code>home: url (from about.homepage)</code> <p>The URL of the homepage of the package.</p> <code>dev_url: url (from about.repository)</code> <p>The URL of the development repository of the package.</p> <code>doc_url: url (from about.documentation)</code> <p>The URL of the documentation of the package.</p> <code>license: string (from about.license)</code> <p>The SPDX license identifier of the package.</p> <code>summary: string</code> <p>A short summary of the package.</p> <code>description: string</code> <p>A longer description of the package.</p> <code>license_family: string</code> <p>(this field is not used anymore as we rely on SPDX license identifiers)</p>"},{"location":"package_spec/#inforecipe","title":"<code>info/recipe/&lt;...&gt;</code>","text":"<p>A directory containing the full contents of the build recipe. This folder also contains a rendered version of the recipe (<code>rendered_recipe.yaml</code>). This rendered version is used for the <code>rebuild</code> command. However, note that currently this format is still in flux and can change at any time.</p> <p>You can also use <code>--no-include-recipe</code> to disable the inclusion of the recipe in the package.</p>"},{"location":"publish/","title":"Publishing packages to your own channel","text":"<p>Rattler-build comes with an intuitive <code>publish</code> subcommand, that will publish a package to a channel.</p> <p>You can either point to an already built package, or to a recipe and <code>publish</code> them into your channel. The channel can be either on prefix.dev, anaconda.org, an S3 bucket, a local filesystem folder (or network mount), or a Quetz or Artifactory instance.</p> <p>Publishing a package is a convenience short hand for:</p> <ol> <li>Building the package from a recipe.yaml</li> <li>Optionally, automatically increment the build number by passing in <code>--build-number=+1</code> to set a relative value, or <code>--build-number=12</code> to set an absolute value for all packages being built.</li> <li>Uploading the package to a channel</li> <li>Running <code>rattler-index</code> for a S3 bucket or a filesystem channel to produce <code>repodata.json</code>.</li> </ol> <p>To publish a package you can use:</p> <pre><code>rattler-build publish ./my-recipe.yaml --to https://prefix.dev/my-channel\n\nrattler-build publish ./output/linux-64/my-package-0.1.2-h123_0.conda --to s3://my-bucket\n\nrattler-build publish ./some/recipe.yaml --to artifactory://my-secret.company.com/package-channel\n\n# on prefix.dev you can also automatically add a sigstore attestation\nrattler-build publish ./my-recipe.yaml --to https://prefix.dev/my-channel --generate-attestation\n</code></pre> <p>The following schema is used:</p> <ul> <li>prefix.dev: <code>https://prefix.dev/&lt;channel-name&gt;</code></li> <li>anaconda.org: <code>https://anaconda.org/&lt;owner&gt;/&lt;label (optional)&gt;</code> (e.g. <code>https://anaconda.org/foobar</code>)</li> <li>S3: <code>s3://bucket-name</code> (note: we read the standard S3 configuration / environment variables for region, authentication, etc.)</li> <li>Filesystem: <code>file:///path/to/channel</code></li> <li>Quetz: <code>quetz://server.my-company.com/&lt;channel&gt;</code></li> <li>Articatory: <code>artifactory://server.my-company.com/&lt;channel&gt;</code></li> </ul>"},{"location":"publish/#options","title":"Options","text":"<p>The <code>--to</code> option selects the channel to publish the package into. This channel will also be used as the highest priority channel in the list of channels. Other channels can be added using the usual <code>-c conda-forge -c bioconda ...</code> syntax or configured using a <code>config.toml</code> file.</p> <p>When using <code>publish</code> with a recipe, you can use the same options as when normally building packages.</p>"},{"location":"publish/#bumping-the-build-number","title":"Bumping the build number","text":"<p>Sometimes you want to package the same package again, but rebuild it with the latest dependencies. There are two ways to achieve this:</p> <ul> <li>By using a variant file, and updating it at certain times</li> <li>By bumping the build number and re-publishing the package again</li> </ul> <p>The publish command makes it easy to \"bump the buildnumber\" either by setting an absolute build number for all packages the recipe builds (e.g. <code>--build-number=12</code>) or a relative bump for all packages (e.g. <code>--build-number=+1</code> to add 1 to the highest build number found in the publish channel). When bumping by a relative amount, we download the repodata and determine for each subdir/package combination that you are building the highest build number.</p> <p>When the recipe does not specify a build number, the build number is automatically bumped on <code>publish</code> to the next available build number.</p> <p>If the recipe does specify a build number, you have to manually trigger an override using the <code>--build-number</code> CLI flag. Alternatively, you can use the <code>--force</code> upload option on S3, your local filesystem, Anaconda and prefix channels to forcibly replace the previous build. Please note that this is heavily discouraged as lockfiles will get out of date and the old build is irrevocably deleted.</p>"},{"location":"publish/#authentication","title":"Authentication","text":"<p>Rattler-build uses the same authentication as other tools in the prefix family. It's easiest to login using the <code>auth</code> subcommand: <code>rattler-build auth login</code>. Note: if you are already logged in with <code>pixi</code>, you are also logged in with <code>rattler-build</code> - they share credentials.</p> <p>Otherwise you can also use the same options as with <code>upload</code>, and supply tokens as environment variables or CLI arguments.</p>"},{"location":"publish/#channel-initialization","title":"Channel Initialization","text":"<p>When publishing to local filesystem or S3 channels, rattler-build automatically handles channel initialization:</p>"},{"location":"publish/#new-channels","title":"New channels","text":"<p>If the target channel doesn't exist yet, rattler-build will:</p> <ol> <li>Create the channel directory (for filesystem channels)</li> <li>Initialize it with an empty <code>noarch/repodata.json</code></li> <li>Upload your package</li> <li>Run indexing to update the repodata</li> </ol> <pre><code># This will create /path/to/my-channel if it doesn't exist\nrattler-build publish ./my-package.conda --to file:///path/to/my-channel\n\n# Same for S3 buckets\nrattler-build publish ./my-package.conda --to s3://my-bucket/channel\n</code></pre>"},{"location":"publish/#existing-channels","title":"Existing channels","text":"<p>If the channel directory exists but is not properly initialized (missing <code>noarch/repodata.json</code>), rattler-build will fail with a helpful error message. This prevents accidentally treating a random directory as a conda channel.</p> <p>To initialize an existing directory as a channel, you can either:</p> <ul> <li>Let rattler-build create it fresh (remove the directory first)</li> <li>Manually create <code>noarch/repodata.json</code> with content <code>{\"packages\": {}, \"packages.conda\": {}}</code></li> </ul>"},{"location":"publish/#indexing-s3-and-filesystem-channels","title":"Indexing S3 and Filesystem channels","text":"<p>Since S3 and Filesystem channels don't know anything about \"indexing\" (producing repodata.json), rattler-build will internally use <code>rattler-index</code> to run the indexing step after a successful upload. This will ensure that the repodata in the channel is up to date and users can start downloading the new packages.</p>"},{"location":"publish/#sigstore-attestations","title":"Sigstore attestations","text":"<p>When publishing to prefix.dev, you can automatically generate Sigstore attestations to cryptographically sign your packages and provide verifiable build provenance. Use the <code>--generate-attestation</code> flag:</p> <pre><code>rattler-build publish ./my-recipe.yaml --to https://prefix.dev/my-channel --generate-attestation\n</code></pre> <p>For more information about Sigstore attestations, verification, and manual attestation creation, see the Sigstore attestations documentation.</p>"},{"location":"rattler_index/","title":"Rattler Index","text":"<p><code>rattler-index</code> is a rattler-based tool which allows you to index your channels. It can create <code>repodata.json</code>, <code>repodata.json.zst</code> as well as sharded repodata (CEP 16). It can index both conda channels on a local file system as well as conda channels on S3.</p>"},{"location":"rattler_index/#installation","title":"Installation","text":"<p>You can install <code>rattler-index</code> using pixi:</p> <pre><code>pixi global install rattler-index\n</code></pre>"},{"location":"rattler_index/#usage","title":"Usage","text":"<p><code>rattler-index</code> has two subcommands for indexing channels on different storage backends:</p>"},{"location":"rattler_index/#indexing-a-local-filesystem-channel","title":"Indexing a local filesystem channel","text":"<pre><code>rattler-index fs /path/to/channel\n</code></pre>"},{"location":"rattler_index/#indexing-an-s3-channel","title":"Indexing an S3 channel","text":"<pre><code>rattler-index s3 s3://my-bucket/my-channel\n</code></pre> <p>For S3 channels, you can provide credentials via command-line options or they will be resolved from the AWS SDK (environment variables, AWS config files, etc.).</p>"},{"location":"rattler_index/#global-options","title":"Global Options","text":"Option Default Description <code>--write-zst</code> <code>true</code> Write compressed <code>repodata.json.zst</code> files <code>--write-shards</code> <code>true</code> Write sharded repodata (CEP 16) <code>-f, --force</code> <code>false</code> Force re-indexing of all packages, creating a new <code>repodata.json</code> instead of updating the existing one <code>--max-parallel &lt;N&gt;</code> 10 Maximum number of packages to process in-memory simultaneously. Useful for limiting memory usage when indexing large channels <code>--target-platform &lt;PLATFORM&gt;</code> all Index only a specific platform (e.g., <code>linux-64</code>, <code>osx-arm64</code>). By default, all platforms in the channel are indexed <code>--repodata-patch &lt;PACKAGE&gt;</code> none Name of a conda package (in the <code>noarch</code> subdir) to use for repodata patching. See repodata patching for more information <code>--config &lt;PATH&gt;</code> none Path to a config file (uses the same format as pixi configuration) <code>-v, -vv, -vvv</code> none Increase verbosity level"},{"location":"rattler_index/#s3-specific-options","title":"S3-specific Options","text":"Option Description <code>--disable-precondition-checks</code> Disable ETag and timestamp checks during file operations. Use if your S3 backend doesn't fully support conditional requests, or if you're certain no concurrent indexing processes are running. Warning: Disabling this removes protection against concurrent modifications <code>--region &lt;REGION&gt;</code> AWS region for the S3 bucket <code>--endpoint-url &lt;URL&gt;</code> Custom S3 endpoint URL (for S3-compatible storage like MinIO) <p>S3 credentials can also be configured in the config file under the <code>s3_options</code> section.</p>"},{"location":"rattler_index/#examples","title":"Examples","text":"<p>Index a local channel with default settings: <pre><code>rattler-index fs ./my-channel\n</code></pre></p> <p>Index only the <code>linux-64</code> platform: <pre><code>rattler-index fs ./my-channel --target-platform linux-64\n</code></pre></p> <p>Force a full re-index (ignoring existing repodata): <pre><code>rattler-index fs ./my-channel --force\n</code></pre></p> <p>Index without sharded repodata: <pre><code>rattler-index fs ./my-channel --write-shards false\n</code></pre></p> <p>Index an S3 channel with a custom endpoint (e.g., MinIO): <pre><code>rattler-index s3 s3://my-bucket/channel --endpoint-url http://localhost:9000 --region us-east-1\n</code></pre></p> <p>Apply repodata patches from a package: <pre><code>rattler-index fs ./my-channel --repodata-patch my-repodata-patches\n</code></pre></p>"},{"location":"rebuild/","title":"Rebuilding a package","text":"<p>The <code>rebuild</code> command allows you to rebuild a package from an existing package. The main use case is to examine if a package can be rebuilt in a reproducible manner. You can read more about reproducible builds here.</p>"},{"location":"rebuild/#usage","title":"Usage","text":"<pre><code>rattler-build rebuild --package-file ./mypkg-0.1.0-h60d57d3_0.tar.bz2\n</code></pre>"},{"location":"rebuild/#how-it-works","title":"How it works","text":"<p>The recipe is \"rendered\" and stored into the package. The way the recipe is rendered is subject to change. For the moment, the rendered recipe is stored as <code>info/recipe/rendered_recipe.yaml</code>. It includes the exact package versions that were used at build time. When rebuilding, we use the package resolutions from the rendered recipe, and execute the same build script as the original package.</p> <p>We also take great care to sort files in a deterministic manner as well as erasing any time stamps. The <code>SOURCE_DATE_EPOCH</code> environment variable is set to the same timestamp as the original build for additional determinism (some build tools use this variable to set timestamps).</p>"},{"location":"rebuild/#how-to-check-the-reproducibility-of-a-package","title":"How to check the reproducibility of a package","text":"<p>There is an excellent tool called <code>diffoscope</code> that allows you to compare two packages and see the differences. You can install it with <code>pixi</code>:</p> <pre><code>pixi global install diffoscope\n</code></pre> <p>To compare two packages, you can use the following command:</p> <pre><code>rattler-build rebuild ./build0.tar.bz2\ndiffoscope ./build0.tar.bz2 ./mypkg-0.1.0-h60d57d3_0.tar.bz2\n</code></pre>"},{"location":"recipe_generation/","title":"Generating recipes for different ecosystems","text":"<p>Rattler-build has some builtin functionality to generate recipes for different (existing) ecosystems.</p> <p>Currently we support the following ecosystems:</p> <ul> <li><code>pypi</code> (Python) - generates a recipe for a Python package</li> <li><code>cran</code> (R) - generates a recipe for an R package</li> </ul> <p>To generate a recipe for a Python package, you can use the following command:</p> <pre><code>rattler-build generate-recipe pypi jinja2\n</code></pre> <p>This will generate a recipe for the <code>jinja2</code> package from PyPI and print it to the console. To turn it into a recipe, you can either pipe the stdout to a file or use the <code>-w</code> flag. The <code>-w</code> flag will create a new folder with the recipe in it.</p> <p>The PyPI recipe generation supports additional flags:</p> <ul> <li><code>-w/--write</code> write the recipe to a folder</li> <li><code>-m/--use-mapping</code> use the conda-forge PyPI name mapping (defaults to true)</li> <li><code>-t/--tree</code> generate recipes for all dependencies</li> <li><code>--pypi-index-url</code> specify one or more PyPI index URLs to use for recipe generation (comma-separated)</li> </ul> <p>The <code>--pypi-index-url</code> option allows you to use alternative PyPI mirrors or private PyPI repositories. You can specify multiple URLs, and the system will try each in order until one succeeds. This is especially useful for organizations with private packages or in environments with limited internet access. You can also set the <code>RATTLER_BUILD_PYPI_INDEX_URL</code> environment variable.</p> <pre><code># Use a custom PyPI index\nrattler-build generate-recipe pypi --pypi-index-url https://my-custom-pypi.example.com/pypi my-package\n\n# Use multiple PyPI indexes (will try each in order)\nrattler-build generate-recipe pypi --pypi-index-url https://my-custom-pypi.example.com/pypi,https://pypi.org/pypi my-package\n</code></pre> <p>The generated recipe for <code>jinja2</code> will look something like:</p> recipe.yaml<pre><code>package:\n  name: jinja2\n  version: 3.1.4\n\nsource:\n  - url: https://files.pythonhosted.org/packages/ed/55/39036716d19cab0747a5020fc7e907f362fbf48c984b14e62127f7e68e5d/jinja2-3.1.4.tar.gz\n    sha256: 4a3aee7acbbe7303aede8e9648d13b8bf88a429282aa6122a993f0ac800cb369\n\nbuild:\n  script: python -m pip install .\n\nrequirements:\n  host:\n    - flit_core &lt;4\n    - python &gt;=3.7\n    - pip\n  run:\n    - python &gt;=3.7\n    - markupsafe &gt;=2.0\n  # - babel &gt;=2.7  # extra == 'i18n'\n\ntests: []\n\nabout:\n  summary: A very fast and expressive template engine.\n  documentation: https://jinja.palletsprojects.com/\n</code></pre>"},{"location":"recipe_generation/#generating-recipes-for-r-packages","title":"Generating recipes for R packages","text":"<p>To generate a recipe for an R package, you can use the following command:</p> <pre><code>rattler-build generate-recipe cran dplyr\n</code></pre> <p>The <code>R</code> recipe generation supports some additional flags:</p> <ul> <li><code>-u/--universe</code> select an R universe to use (e.g. <code>bioconductor</code>)</li> <li><code>-t/--tree</code> generate multiple recipes, for every dependency as well</li> </ul> <p>R packages will be prefixed with <code>r-</code> to avoid name conflicts with Python packages. The generated recipe for <code>dplyr</code> will look something like:</p> recipe.yaml<pre><code>package:\n  name: r-dplyr\n  version: 1.1.4\n\nsource:\n  - url: https://cran.r-project.org/src/contrib/dplyr_1.1.4.tar.gz\n    md5: e3066ea859b26e0d3b992c476ea3af2e\n\nbuild:\n  script: R CMD INSTALL --build .\n  python: {}\n\nrequirements:\n  host:\n    - r-base &gt;=3.5.0\n  run:\n    - r-cli &gt;=3.4.0\n    - r-generics\n    - r-glue &gt;=1.3.2\n    - r-lifecycle &gt;=1.0.3\n    - r-magrittr &gt;=1.5\n    - r-methods\n    - r-pillar &gt;=1.9.0\n    - r-r6\n    - r-rlang &gt;=1.1.0\n    - r-tibble &gt;=3.2.0\n    - r-tidyselect &gt;=1.2.0\n    - r-utils\n    - r-vctrs &gt;=0.6.4\n  # -  r-bench  # suggested\n  # -  r-broom  # suggested\n  # -  r-callr  # suggested\n  # -  r-covr  # suggested\n  # -  r-dbi  # suggested\n  # -  r-dbplyr &gt;=2.2.1  # suggested\n  # -  r-ggplot2  # suggested\n  # -  r-knitr  # suggested\n  # -  r-lahman  # suggested\n  # -  r-lobstr  # suggested\n  # -  r-microbenchmark  # suggested\n  # -  r-nycflights13  # suggested\n  # -  r-purrr  # suggested\n  # -  r-rmarkdown  # suggested\n  # -  r-rmysql  # suggested\n  # -  r-rpostgresql  # suggested\n  # -  r-rsqlite  # suggested\n  # -  r-stringi &gt;=1.7.6  # suggested\n  # -  r-testthat &gt;=3.1.5  # suggested\n  # -  r-tidyr &gt;=1.3.0  # suggested\n  # -  r-withr  # suggested\n\nabout:\n  homepage: https://dplyr.tidyverse.org\n  summary: A Grammar of Data Manipulation\n  description: |-\n    A fast, consistent tool for working with data frame like\n    objects, both in memory and out of memory.\n  license: MIT\n  license_file: LICENSE\n  repository: https://github.com/cran/dplyr\n</code></pre> <p>Tip</p> <p>You can use the generated recipes to build your own \"forge\" with <code>rattler-build</code>. Read more about it in the Building your own forge section.</p>"},{"location":"sandbox/","title":"Experimental sandbox","text":"<p>Warning</p> <p>The sandbox feature is experimental and may not work as expected. The options might change in future releases.</p> <p>Since the 0.34.0 release, <code>rattler-build</code> has a new experimental feature called <code>sandbox</code>. With the sandbox feature enabled (via <code>--sandbox</code>), the build process has much more restricted access to system resources on macOS and Linux. As the sandbox feature is experimental it is disabled by default.</p> <p>In particular, with the default configuration, the build process can read the entire filesystem, but it cannot write outside of the build directories. The build process also cannot access the network. In the future, we plan to enable the sandbox per default and restrict it further.</p> <p>On macOS this is achieved by using the <code>sandbox-exec</code> command, which is part of the macOS system. On Linux the sandbox is created using Linux namespaces.</p> <p>To control the sandbox behavior, you can supply additional arguments to the CLI:</p>"},{"location":"sandbox/#example","title":"Example","text":"<pre><code># run the build and sandbox the build process\nrattler-build build --recipe ./example/recipe.yaml --sandbox\n\n# to add more permissions to the sandbox\nrattler-build build --recipe ./example/recipe.yaml --sandbox \\\n    --allow-read /some/path --allow-read /foo/bar --allow-network\n</code></pre>"},{"location":"sandbox/#options","title":"Options","text":"<ul> <li><code>--allow-network</code>: Allow network access (by default network access is disabled)</li> <li><code>--allow-read-write /some/path</code>: Allow read and write access to the specified path (and all its subdirectories)</li> <li><code>--allow-read /some/path</code>: Allow read access to the specified path (and all its subdirectories)</li> <li><code>--allow-read-execute /some/path</code>: Allow read and execute access to the specified path (and all its subdirectories)</li> <li><code>--overwrite-default-sandbox-config</code>: Ignore the default sandbox configuration and use only the supplied arguments</li> </ul>"},{"location":"sandbox/#default-sandbox-configuration","title":"Default sandbox configuration","text":""},{"location":"sandbox/#macos","title":"macOS","text":"<p>On macOS, by default, the sandbox configuration is as follows:</p> <ul> <li>Read access to the entire filesystem (<code>/</code>)</li> <li>Read and execute access to <code>/bin</code>, <code>/usr/bin</code></li> <li>Write access to the build directories and <code>/tmp</code>, <code>/var/tmp</code>, and <code>$TMPDIR</code> (if defined)</li> </ul>"},{"location":"sandbox/#linux","title":"Linux","text":"<p>On Linux, by default, the sandbox configuration is as follows:</p> <ul> <li>Read access to the entire filesystem (<code>/</code>)</li> <li>Read and execute access to <code>/bin</code>, <code>/usr/bin</code>, <code>/lib</code>, <code>/usr/lib</code>, <code>/lib64</code>, <code>/usr/lib64</code></li> <li>Write access to the build directories and <code>/tmp</code>, <code>/var/tmp</code>, and <code>$TMPDIR</code> (if defined)</li> </ul>"},{"location":"sandbox/#windows","title":"Windows","text":"<p>Sandboxing the build process is not yet supported on Windows, and thus all passed sandbox flags are entirely ignored.</p>"},{"location":"selectors/","title":"Selectors in recipes","text":"<p>Recipe and variant configuration files can utilize selectors to conditionally add, remove, or modify dependencies, configuration options, or even skip recipe execution based on specific conditions.</p> <p>Selectors are implemented using an <code>if / then / else</code> map, which is a valid YAML dictionary. The condition is evaluated using <code>minijinja</code> and follows the same syntax as a Python expression.</p> <p>During rendering, several variables are set based on the platform and variant being built. For example, the <code>unix</code> variable is true when the host platform is macOS or Linux, while <code>win</code> is true when the host platform is Windows. Consider the following recipe executed on Linux:</p> <pre><code>requirements:\n  host:\n    - if: unix\n      then: unix-tool\n    - if: win\n      then: win-tool\n</code></pre> <p>This will be evaluated as:</p> <pre><code>requirements:\n  host:\n    - unix-tool\n</code></pre> <p>The line containing the Windows-specific configuration is removed. Multiple items can also be selected, such as:</p> <pre><code>host:\n  - if: linux\n    then:\n      - linux-tool-1\n      - linux-tool-2\n      - linux-tool-3\n</code></pre> <p>For Linux, this will result in:</p> <pre><code>host:\n  - linux-tool-1\n  - linux-tool-2\n  - linux-tool-3\n</code></pre> <p>Other examples often found in the wild:</p> <pre><code>if: build_platform != target_platform ... # true if cross-platform build\nif: osx and arm64 ... # true for apple silicon (osx-arm64)\nif: linux and (aarch64 or ppc64le)) ... # true for linux ppc64le or linux-aarch64\n</code></pre>"},{"location":"selectors/#available-variables","title":"Available variables","text":"<p>The following variables are available during rendering of the recipe:</p> Variable Description <code>target_platform</code> the configured <code>target_platform</code> for the build <code>build_platform</code> the configured <code>build_platform</code> for the build <code>host_platform</code> the configured <code>host_platform</code> for the build <code>linux</code> \"true\" if <code>host_platform</code> is Linux <code>osx</code> \"true\" if <code>host_platform</code> is OSX / macOS <code>win</code> \"true\" if <code>host_platform</code> is Windows <code>unix</code> \"true\" if <code>host_platform</code> is a Unix (macOS or Linux) <code>x86</code>, <code>x86_64</code> x86 32/64-bit Architecture (based on <code>host_platform</code>) <code>aarch64</code> 64-bit Arm (if <code>host_platform</code> is <code>linux-aarch64</code>) <code>arm64</code> 64-bit Arm (if <code>host_platform</code> is <code>osx-arm64</code> or <code>win-arm64</code>) <code>armV6l</code>, <code>armV7l</code> 32-bit Arm <code>ppc64</code>, <code>s390x</code>, Big endian <code>ppc64le</code> Little endian <code>riscv32</code>, <code>riscv64</code> The RISC-V Architecture <code>wasm32</code> The WebAssembly Architecture"},{"location":"selectors/#variant-selectors","title":"Variant selectors","text":"<p>To select based on variant configuration you can use the names in the selectors as well. For example, if the build uses <code>python: 3.8</code> as a variant, we can use <code>if: python == \"3.8\"</code> to enable a dependency for only when the Python version is 3.8.</p> <p>String comparison</p> <p>The comparison is a string comparison done by <code>minijinja</code>, so it is important to use the correct string representation of the variant. Use the <code>match</code> function to compare versions.</p> variants.yaml<pre><code>python:\n  - 3.8\n  - 3.9\n</code></pre> recipe.yaml<pre><code>requirements:\n  host:\n    - if: python == \"3.8\" # (1)!\n      then: mydep\n      else: otherdep\n</code></pre> <ol> <li>This will only add <code>mydep</code> when the Python version is 3.8. This comparison is a string comparison, so it is important    to    use the correct string representation of the variant.</li> </ol>"},{"location":"selectors/#the-match-function","title":"The <code>match</code> function","text":"<p>!!!  note \"Rename from <code>cmp</code> to <code>match</code>\"     The <code>cmp</code> function has been renamed to <code>match</code> to better reflect its purpose.</p> <p>Inside selectors, one can use a special <code>match</code> function to test if the selected variant version has a matching version. For example, having the following variants file, we could use the these tests:</p> variants.yaml<pre><code>python:\n  - 3.8\n  - 3.9\n</code></pre> recipe.yaml<pre><code>- if: match(python, \"3.8\")    # true, false\n  then: mydep\n- if: match(python, \"&gt;=3.8\")  # true, true\n  then: mydep\n- if: match(python, \"&lt;3.8\")   # false, false (1)\n  then: mydep\n</code></pre> <ol> <li><code>else:</code> would also have worked here.</li> </ol> <p>This function eliminates the need to implement any Python-specific <code>conda-build</code> selectors (such as <code>py3k</code>, <code>py38</code>, etc.) or the <code>py</code> and <code>npy</code> integers.</p> <p>Please note that during the initial phase of rendering we do not know the variant, and thus the <code>match</code> condition always evaluates to <code>true</code>.</p>"},{"location":"selectors/#selector-evaluation","title":"Selector evaluation","text":"<p>Except for the rattler-build specific selectors, the selectors are evaluated using the <code>minijinja</code> engine. This means that the selectors are evaluated by <code>minijinja</code> thus Python like expressions. Some notable options are:</p> <pre><code>- if: python == \"3.8\" # equal\n- if: python != \"3.8\" # not equal\n- if: python and linux # true if python variant is set and the host_platform is linux\n- if: python and not linux # true if python variant is set and the host_platform is not linux\n- if: python and (linux or osx) # true if python variant is set and the host_platform is linux or osx\n</code></pre>"},{"location":"selectors/#alternatives-for-scalar-fields","title":"Alternatives for scalar fields","text":"<p>Some fields accept scalars rather than lists, and selectors cannot be used. Alternatives include:</p> <pre><code>string: ${{ \"foobar\" if USE_OPENMP else \"bla\" }}\n</code></pre> <pre><code>string: |\n  {% if USE_OPENMP %}\n     blablabla\n  {% else %}\n     blabla\n  {% endif %}\n</code></pre>"},{"location":"sigstore/","title":"Sigstore attestations","text":"<p>Sigstore is a way to cryptographically sign packages (or any binary artifacts). It was pioneered in the container space, but has been adopted by many packaging ecosystems: PyPI, Python releases, Rust crates, Homebrew, and Rubygems.</p> <p>Rattler-build supports creating Sigstore attestations for conda packages, allowing you to cryptographically sign your packages and provide verifiable provenance information.</p>"},{"location":"sigstore/#what-does-a-sigstore-attestation-provide","title":"What does a Sigstore attestation provide?","text":"<p>A Sigstore attestation ties the producer of a package (for example, a GitHub Actions workflow) to the package artifact. When the attestation is created, metadata about the artifact is registered in a \"Transparency Log\" which can be inspected at any time. The metadata contains information such as:</p> <ul> <li>The name and SHA256 hash of the package</li> <li>The CI workflow that built the package</li> <li>The repository Git hash that contained the CI workflow</li> <li>The organization and username that built the package</li> </ul> <p>Using this information, you can attest that a given package was created and uploaded by a certain GitHub organization, and this is transparently logged on both the server and the Sigstore public good instance.</p> <p>The attestation follows CEP-27, which standardizes the in-toto attestation format with a Conda-specific predicate containing:</p> <ul> <li>The SHA256 hash of the package (guaranteed to be unique)</li> <li>The full filename (<code>{name}-{version}-{buildstring}.conda</code>)</li> <li>Optionally, the target channel URL (e.g., <code>https://prefix.dev/my-channel</code>)</li> </ul>"},{"location":"sigstore/#automatic-attestation-generation","title":"Automatic attestation generation","text":"<p>The easiest way to create Sigstore attestations is using the <code>--generate-attestation</code> flag when publishing to prefix.dev:</p> <pre><code>rattler-build publish ./my-recipe.yaml --to https://prefix.dev/my-channel --generate-attestation\n</code></pre> <p>This automatically:</p> <ol> <li>Builds your package(s) from the recipe</li> <li>Creates a Sigstore attestation using the OIDC identity from your CI environment</li> <li>Uploads both the package and attestation to prefix.dev</li> </ol> <p>Requirements</p> <p>The <code>--generate-attestation</code> flag only works when:</p> <ul> <li>Uploading to prefix.dev channels</li> <li>Using Trusted Publishing (OIDC authentication)</li> <li>Running in a supported CI environment (e.g., GitHub Actions)</li> </ul>"},{"location":"sigstore/#github-actions-example","title":"GitHub Actions example","text":"<p>Here's a complete example workflow using automatic attestation generation:</p> .github/workflows/build.yml<pre><code>name: Build and publish with attestation\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    # These permissions are needed for OIDC authentication\n    permissions:\n      id-token: write\n      contents: read\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up rattler-build\n        uses: prefix-dev/rattler-build-action@v0.2.34\n\n      - name: Build and publish with attestation\n        run: |\n          rattler-build publish ./recipe.yaml \\\n            --to https://prefix.dev/my-channel \\\n            --generate-attestation\n</code></pre>"},{"location":"sigstore/#manual-attestation-with-github-actions","title":"Manual attestation with GitHub Actions","text":"<p>If you need more control over the attestation process, you can use GitHub's official attest action to create the attestation separately:</p> .github/workflows/build.yml<pre><code>name: Package and sign\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    # These permissions are needed to create a sigstore certificate\n    permissions:\n      id-token: write\n      contents: read\n      attestations: write\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Build conda package\n        uses: prefix-dev/rattler-build-action@v0.2.34\n\n      # Use GitHub's official attest action with the Conda predicate\n      - uses: actions/attest@v1\n        id: attest\n        with:\n          subject-path: \"**/*.conda\"\n          predicate-type: \"https://schemas.conda.org/attestations-publish-1.schema.json\"\n          predicate: '{\"targetChannel\": \"https://prefix.dev/my-channel\"}'\n\n      # Upload with the attestation bundle\n      - name: Upload the package\n        run: |\n          rattler-build upload prefix -c my-channel ./output/**/*.conda \\\n            --attestation ${{ steps.attest.outputs.bundle-path }}\n</code></pre> <p>This approach gives you full control over the attestation creation and allows you to customize the predicate or add additional attestation metadata.</p>"},{"location":"sigstore/#source-attestation-verification","title":"Source attestation verification","text":"<p>Experimental</p> <p>This feature requires the <code>--experimental</code> flag: <code>rattler-build build --experimental -r recipe.yaml</code></p> <p>In addition to signing built packages, rattler-build can also verify the attestations of source archives during the build. This lets you ensure that the source code you're building from was produced by a trusted publisher (e.g., a specific GitHub Actions workflow).</p>"},{"location":"sigstore/#how-it-works","title":"How it works","text":"<p>Add an <code>attestation</code> block to a URL source in your recipe:</p> recipe.yaml<pre><code>source:\n  url: https://files.pythonhosted.org/packages/.../flask-3.1.1.tar.gz\n  sha256: \"6489f1...\"\n  attestation:\n    publishers:\n      - github:pallets/flask\n</code></pre> <p>When rattler-build downloads the source, it will:</p> <ol> <li>Fetch the Sigstore attestation bundle (automatically derived for PyPI packages, or from <code>bundle_url</code>)</li> <li>Verify the bundle signature against the Sigstore transparency log</li> <li>Check that the attestation identity matches one of the listed publishers</li> </ol> <p>If verification fails, the build is aborted.</p>"},{"location":"sigstore/#pypi-sources","title":"PyPI sources","text":"<p>For packages hosted on PyPI, the attestation bundle URL is automatically derived from the PyPI attestation API. You only need to specify the publisher:</p> <pre><code>source:\n  url: https://files.pythonhosted.org/packages/.../flask-3.1.1.tar.gz\n  sha256: \"6489f1...\"\n  attestation:\n    publishers:\n      - github:pallets/flask\n</code></pre>"},{"location":"sigstore/#github-release-sources","title":"GitHub release sources","text":"<p>For source archives from GitHub releases, specify the <code>bundle_url</code> pointing to the <code>.sigstore.json</code> bundle:</p> <pre><code>source:\n  url: https://github.com/facebook/zstd/releases/download/v1.5.7/zstd-1.5.7.tar.gz\n  sha256: \"eb33e5...\"\n  attestation:\n    bundle_url: https://github.com/facebook/zstd/releases/download/v1.5.7/zstd-1.5.7.tar.gz.sigstore.json\n    publishers:\n      - github:facebook/zstd\n</code></pre>"},{"location":"sigstore/#publisher-format","title":"Publisher format","text":"<p>Publishers are specified in <code>github:owner/repo</code> format. The identity is matched against the Sigstore certificate's Subject Alternative Name (SAN), which for GitHub Actions is the workflow identity.</p>"},{"location":"sigstore/#verifying-attestations","title":"Verifying attestations","text":"<p>Once packages are published with attestations, they can be verified using several tools:</p>"},{"location":"sigstore/#using-the-github-cli","title":"Using the GitHub CLI","text":"<pre><code>gh attestation verify my-package-0.1.0-h123_0.conda \\\n  --owner my-org \\\n  --predicate-type \"https://schemas.conda.org/attestations-publish-1.schema.json\"\n</code></pre>"},{"location":"sigstore/#using-cosign","title":"Using cosign","text":"<pre><code>cosign verify-blob \\\n  --certificate-identity-regexp \"https://github.com/my-org/.*\" \\\n  --certificate-oidc-issuer \"https://token.actions.githubusercontent.com\" \\\n  my-package-0.1.0-h123_0.conda\n</code></pre>"},{"location":"sigstore/#using-sigstore-python","title":"Using sigstore-python","text":"<pre><code>pip install sigstore\nsigstore verify identity \\\n  --cert-identity \"https://github.com/my-org/my-repo/.github/workflows/build.yml@refs/heads/main\" \\\n  --cert-oidc-issuer \"https://token.actions.githubusercontent.com\" \\\n  my-package-0.1.0-h123_0.conda\n</code></pre>"},{"location":"sigstore/#viewing-attestations","title":"Viewing attestations","text":"<p>You can find attestations for packages published to prefix.dev in several places:</p> <ul> <li>GitHub: View attestations in your repository's attestations tab (e.g., <code>https://github.com/my-org/my-repo/attestations</code>)</li> <li>Sigstore public goods instance: Search by package hash at search.sigstore.dev</li> <li>prefix.dev: View attestations on the package page</li> </ul>"},{"location":"sigstore/#security-benefits","title":"Security benefits","text":"<p>Sigstore attestations provide several security benefits:</p> <ol> <li> <p>Unforgeability: Attestations cryptographically bind a package to its producer, preventing forgery of provenance metadata.</p> </li> <li> <p>Transparency: All attestations are logged in a public, append-only transparency log. This means attackers cannot perform targeted attacks without leaving a public trace.</p> </li> <li> <p>No long-lived keys: Sigstore uses ephemeral keys bound to identities (like GitHub Actions workflows), eliminating the risk of key compromise.</p> </li> <li> <p>Build provenance: Machine identities in the attestation provide verifiable information about exactly which workflow, repository, and commit produced the package.</p> </li> </ol>"},{"location":"sigstore/#further-reading","title":"Further reading","text":"<ul> <li>CEP-27: Standardizing a publish attestation for the conda ecosystem</li> <li>Securing the Conda Package Supply Chain with Sigstore (prefix.dev blog)</li> <li>Sigstore documentation</li> <li>Example repository with full source code</li> </ul>"},{"location":"special_files/","title":"Activation scripts and other special files","text":"<p>A <code>conda</code> package can contain \"special\" files in the prefix. These files are scripts that are executed during activation, installation, or uninstallation process.</p> <p>If possible, they should be avoided since they execute arbitrary code at installation time and slow down the installation and activation process.</p>"},{"location":"special_files/#activation-scripts","title":"Activation scripts","text":"<p>The activation scripts are executed when the environment containing the package is activated (e.g. when doing <code>micromamba activate myenv</code> or <code>pixi run ...</code>).</p> <p>The scripts are located in special folders:</p> <ul> <li><code>etc/conda/activate.d/{script.*}</code> - scripts in this folder are executed when the environment is activated</li> <li><code>etc/conda/deactivate.d/{script.*}</code> - scripts in this folder are executed when the environment is deactivated</li> </ul> <p>The scripts are executed in lexicographical order, so you can prefix them with numbers to control the order of execution.</p>"},{"location":"special_files/#shell-specific-file-extensions","title":"Shell-specific file extensions","text":"<p>Different shells require different script file extensions. The activation system will only execute scripts that match the current shell:</p> Shell Extension Bash <code>.sh</code> Zsh <code>.sh</code> Fish <code>.fish</code> Xonsh <code>.xsh</code> or <code>.sh</code> PowerShell <code>.ps1</code> Cmd.exe <code>.bat</code> NuShell <code>.nu</code> <p>To add a script to the package, just make sure that you install the file in this folder. For example, on Linux:</p> <pre><code>mkdir -p $PREFIX/etc/conda/activate.d\ncp activate-mypkg.sh $PREFIX/etc/conda/activate.d/10-activate-mypkg.sh\n\nmkdir -p $PREFIX/etc/conda/deactivate.d\ncp deactivate-mypkg.sh $PREFIX/etc/conda/deactivate.d/10-deactivate-mypkg.sh\n</code></pre> <p>For cross-platform packages that need to support multiple shells, you should provide scripts for each shell type you want to support:</p> <pre><code># Unix shells (Bash, Zsh)\nmkdir -p $PREFIX/etc/conda/activate.d\ncp activate-mypkg.sh $PREFIX/etc/conda/activate.d/10-activate-mypkg.sh\n\n# Windows Cmd.exe\ncp activate-mypkg.bat $PREFIX/etc/conda/activate.d/10-activate-mypkg.bat\n\n# Windows PowerShell\ncp activate-mypkg.ps1 $PREFIX/etc/conda/activate.d/10-activate-mypkg.ps1\n</code></pre>"},{"location":"special_files/#activation-environment-variables","title":"Activation environment variables","text":"<p>If you only need to set environment variables when an environment is activated (rather than running arbitrary shell code), you can use JSON files in the <code>etc/conda/env_vars.d/</code> directory. This is more efficient and portable than using activation scripts.</p>"},{"location":"special_files/#package-specific-environment-variables","title":"Package-specific environment variables","text":"<p>To set environment variables from your package, create a JSON file in <code>etc/conda/env_vars.d/</code>:</p> <pre><code>&lt;prefix&gt;/etc/conda/env_vars.d/&lt;package_name&gt;.json\n</code></pre> <p>The JSON file should contain a simple object with string key-value pairs:</p> <pre><code>{\n  \"MY_PACKAGE_HOME\": \"/path/to/data\",\n  \"MY_PACKAGE_CONFIG\": \"default\",\n  \"SOME_API_ENDPOINT\": \"https://api.example.com\"\n}\n</code></pre> <p>To include this in your package, add to your build script:</p> <pre><code>mkdir -p $PREFIX/etc/conda/env_vars.d\ncat &gt; $PREFIX/etc/conda/env_vars.d/mypkg.json &lt;&lt; 'EOF'\n{\n  \"MY_PKG_VAR\": \"some_value\",\n  \"ANOTHER_VAR\": \"another_value\"\n}\nEOF\n</code></pre> <p>Or copy a pre-existing file:</p> <pre><code>mkdir -p $PREFIX/etc/conda/env_vars.d\ncp $RECIPE_DIR/env_vars.json $PREFIX/etc/conda/env_vars.d/mypkg.json\n</code></pre>"},{"location":"special_files/#using-the-prefix-path-in-environment-variables","title":"Using the $PREFIX path in environment variables","text":"<p>Since JSON files contain static values, you need to expand the <code>$PREFIX</code> environment variable when creating the file during the build. Use a heredoc without quotes to allow bash variable expansion:</p> <pre><code>mkdir -p $PREFIX/etc/conda/env_vars.d\ncat &gt; $PREFIX/etc/conda/env_vars.d/mypkg.json &lt;&lt; EOF\n{\n  \"MY_PKG_DATA_DIR\": \"$PREFIX/share/mypkg\",\n  \"MY_PKG_CONFIG\": \"$PREFIX/etc/mypkg.conf\"\n}\nEOF\n</code></pre> <p>This will write the actual prefix path (e.g., <code>/home/user/host_env_placehold_plachold...</code>) into the JSON file, which be replaced at installation time.</p> <p>On Windows (in <code>bld.bat</code>), use <code>%PREFIX%</code>:</p> <pre><code>mkdir %PREFIX%\\etc\\conda\\env_vars.d\necho {\"MY_PKG_DATA_DIR\": \"%PREFIX%\\\\share\\\\mypkg\"} &gt; %PREFIX%\\etc\\conda\\env_vars.d\\mypkg.json\n</code></pre> <p>Quoted vs unquoted heredocs</p> <p>Note the difference: <code>&lt;&lt; 'EOF'</code> (quoted) prevents variable expansion, while <code>&lt;&lt; EOF</code> (unquoted) allows bash to expand <code>$PREFIX</code> before writing the file.</p>"},{"location":"special_files/#complete-directory-structure","title":"Complete directory structure","text":"<p>Here's the complete structure of activation-related files in a conda environment:</p> <pre><code>&lt;conda-prefix&gt;/\n\u251c\u2500\u2500 bin/                           # Executables (Unix)\n\u251c\u2500\u2500 Scripts/                       # Executables (Windows)\n\u251c\u2500\u2500 etc/conda/\n\u2502   \u251c\u2500\u2500 activate.d/               # Activation scripts (shell-specific)\n\u2502   \u2502   \u251c\u2500\u2500 10-pkg1-activate.sh   # Bash/Zsh script\n\u2502   \u2502   \u251c\u2500\u2500 10-pkg1-activate.bat  # Cmd.exe script\n\u2502   \u2502   \u2514\u2500\u2500 10-pkg1-activate.ps1  # PowerShell script\n\u2502   \u251c\u2500\u2500 deactivate.d/             # Deactivation scripts\n\u2502   \u2502   \u251c\u2500\u2500 10-pkg1-deactivate.sh\n\u2502   \u2502   \u2514\u2500\u2500 10-pkg1-deactivate.bat\n\u2502   \u2514\u2500\u2500 env_vars.d/               # Package environment variables (JSON)\n\u2502       \u251c\u2500\u2500 pkg1.json\n\u2502       \u251c\u2500\u2500 pkg2.json\n\u2502       \u2514\u2500\u2500 zzz-override.json     # Loaded last due to filename\n\u2514\u2500\u2500 conda-meta/\n    \u251c\u2500\u2500 pkg1-1.0.0-h1234.json      # Package metadata\n    \u251c\u2500\u2500 pkg2-2.0.0-h5678.json\n    \u2514\u2500\u2500 state                      # Environment-level state (JSON)\n</code></pre>"},{"location":"special_files/#processing-order","title":"Processing order","text":"<p>When an environment is activated, the activation system:</p> <ol> <li>Reads all <code>.json</code> files from <code>etc/conda/env_vars.d/</code> in lexicographical order</li> <li>Reads the <code>conda-meta/state</code> file (if it exists)</li> <li>Merges all variables, with later files overriding earlier ones</li> </ol> <p>This means:</p> <ul> <li>If multiple packages define the same variable, the package whose filename comes later alphabetically will win</li> <li>You can prefix filenames with numbers (e.g., <code>00-base.json</code>, <code>50-mypkg.json</code>) to control priority</li> <li>The <code>conda-meta/state</code> file always has the highest priority</li> </ul>"},{"location":"special_files/#post-link-and-pre-unlink-scripts","title":"Post-link and pre-unlink scripts","text":"<p>The <code>post-link</code> and <code>pre-unlink</code> scripts are executed when the package is installed or uninstalled. They are both heavily discouraged but implemented for compatibility with conda in <code>rattler-build</code> since version 0.17.</p> <p>For a <code>post-link</code> script to be executed when a package is installed, the built package needs to have a <code>.&lt;package_name&gt;-post-link.{sh/bat}</code> in its <code>bin/</code> folder. The same is applicable for <code>pre-unlink</code> scripts, just with the name <code>.&lt;package_name&gt;-pre-unlink.{sh/bat}</code> (note the leading period). For example, for a package <code>mypkg</code>, you would need to have a <code>.mypkg-post-link.sh</code> in its <code>bin/</code> folder.</p> <p>To make sure the scripts are included in the correct location, use your recipe's build script or <code>build/script</code> key. For example, assuming you have a <code>post-link.sh</code> script in your source, alongside the recipe in the recipe's folder, the following configuration will copy it correctly:</p> <pre><code>build:\n  ...\n  script:\n    - ...\n    - mkdir -p $PREFIX/bin\n    - cp $RECIPE_DIR/post-link.sh $PREFIX/bin/.mypkg-post-link.sh\n    - chmod +x $PREFIX/bin/.mypkg-post-link.sh\n</code></pre> <p>The <code>$PREFIX</code> and <code>$RECIPE_DIR</code> environment variables will be set during the build process to help you specify the correct paths.</p>"},{"location":"system_integration/","title":"System integration for packages","text":"<p>When you are building packages, you might want to integrate with the system to install shortcuts, desktop icons, etc.</p> <p>In the Conda ecosystem, this is the job of \"menuinst\" - originally a Python project, that we ported to our underlying <code>rattler</code> library. To install a menuitem, you need to place a specially crafted JSON file in the right location in the package / conda environment.</p> recipe.yaml<pre><code>build:\n  script:\n    # ... build the package\n    # Install the menu item\n    - mkdir -p $PREFIX/Menu\n    - cp $RECIPE_DIR/menu/menu.json $PREFIX/Menu/pixi-editor.json\n    - cp $RECIPE_DIR/icons/pixi-icon.* $PREFIX/Menu/\n</code></pre> <p>To learn more about installing menu items, please take a look at the <code>menuinst</code> documentation.</p>"},{"location":"system_integration/#installing-shell-completion-scripts","title":"Installing shell completion scripts","text":"<p>Shell completion scripts are scripts that are sourced by the shell to provide tab-completion for commands. They are automatically picked up by <code>pixi</code> and other tools when they appear in the right location in your package.</p> <p>These locations are:</p> <ul> <li><code>bash</code>: <code>$PREFIX/share/bash-completion/completions/</code></li> <li><code>zsh</code>: <code>$PREFIX/share/zsh/site-functions/</code></li> <li><code>fish</code>: <code>$PREFIX/share/fish/vendor_completions.d/</code></li> </ul> <p>Following is an example of how to ship shell completions for <code>ripgrep</code> in a package:</p> recipe.yaml<pre><code>package:\n  name: ripgrep\n  version: \"1.24.3\"\n\n# ... other fields omitted for brevity\n\nbuild:\n  number: 1\n  noarch: generic\n  script:\n    # Build and install ripgrep ...\n    # Then generate the completions\n    # ZSH completions\n    - mkdir -p $PREFIX/share/zsh/site-functions\n    - rg --generate complete-zsh &gt; $PREFIX/share/zsh/site-functions/_rg\n    # Bash completions\n    - mkdir -p $PREFIX/share/bash-completion/completions\n    - rg --generate complete-bash &gt; $PREFIX/share/bash-completion/completions/rg\n    # Fish completions\n    - mkdir -p $PREFIX/share/fish/vendor_completions.d\n    - rg --generate complete-fish &gt; $PREFIX/share/fish/vendor_completions.d/rg.fish\n\n# ... continue recipe\n</code></pre> <p>Note that tools like <code>pixi global install</code> will expect completion script name to match the binary name. The pattern is as follows:</p> <ul> <li><code>bash</code>: <code>&lt;binary-name&gt;</code></li> <li><code>zsh</code>: <code>_&lt;binary-name&gt;</code></li> <li><code>fish</code>: <code>&lt;binary-name&gt;.fish</code></li> </ul>"},{"location":"testing/","title":"Testing packages","text":"<p>When you are developing a package, you should write tests for it. The tests are automatically executed as soon as the package build and all it's run dependencies are ready.</p>"},{"location":"testing/#writing-tests","title":"Writing tests","text":"<p>You can add one or more tests to your package in the <code>tests</code> section of the recipe (or output). Each test is run independently, in a separate environment.</p> <p>One notable difference are the <code>package_contents</code> tests that are executed right after the package is prepared and do not create a new environment (as we only analyze the contents of the package).</p> recipe.yaml<pre><code>tests:\n  # commands to run to test the package. If any of the commands\n  # returns with an error code, the test is considered failed.\n  - script:\n      - echo \"Hello world\"\n      - exit 1  # this will fail the test\n\n  # run a script from the recipe folder\n  - script: sometest.py\n\n  # run a Python script with the Python interpreter\n  - script:\n      interpreter: python\n      content: |\n        import mypkg\n        assert mypkg.__version__ == \"0.1.0\"\n\n  # execute `pytest` with the tests from the `tests` folder\n  - script:\n      - pytest ./tests\n    # additional requirements at test time\n    requirements:\n      run:\n        - pytest\n        - python 3.9.*  # require an older python version\n    # extra files to be copied to the test folder from the recipe or source directory\n    files:\n      recipe:\n        - tests/\n\n  # run test scripts with environment variables. Note that the interpreter is\n  # inferred automatically and the test file is copied from recipe or source directory\n  - script:\n      env:\n        HELLO: \"Hello World!\"\n      file: run_my_test_script.py\n\n  # python specific tests\n  - python:\n      # this test section tries to import the python modules and errors if it can't\n      imports:\n        - mypkg\n      pip_check: true\n      python_version: [3.9.*, 3.10.*]  # run against multiple older python versions\n\n  - r:\n      libraries:\n        - dplyr\n\n  - perl:\n      modules:\n        - JSON\n\n  # test the contents of the package.\n  - package_contents:\n      files:\n        - share/package/*.txt\n        - lib/python*/site-packages/mypackage/*.py\n\n  # test with strict mode: fails if there are any files not matched by the globs\n  - package_contents:\n      strict: true\n      files:\n        - share/package/*.txt\n        - bin/myapp\n      lib:\n        - mylib\n</code></pre>"},{"location":"testing/#testing-package-contents","title":"Testing package contents","text":"<p>The <code>package_contents</code> test is a special test that is executed right after the package is prepared. It does not create a new environment, but instead checks the paths that will be part of the final package. It can be very useful as a \"sanity check\" to ensure that the package contains the expected files.</p> <p>It has multiple sub-keys that help when building cross-platform packages:</p> <ul> <li><code>files</code>: Specifies glob patterns for files that should exist in the package. You can provide a simple list of globs that should match at least one file in the package. If any pattern doesn't match at least one file, the test fails.</li> </ul> <p>Note: For more advanced use cases, you can also use the expanded form with <code>exists</code> and <code>not_exists</code> fields: <pre><code>files:\n  exists:\n    - share/package/*.txt\n    - lib/python*/site-packages/mypackage/*.py\n  not_exists:\n    - lib/python*/site-packages/mypackage/deprecated_module.py\n</code></pre></p> <ul> <li><code>lib</code>: matches libraries in the package (<code>.so</code>, <code>.dll</code>, <code>.dylib</code> files). The test fails if any of the libraries are not found. It's enough to specify the library name without any extension (e.g. <code>foo</code> will match <code>libfoo.so</code>, <code>libfoo.dylib</code>, and <code>foo.dll</code>).</li> <li><code>include</code>: matches files under the <code>include</code> directory in the package. You can specify the file name like <code>foo.h</code>.</li> <li><code>bin</code>: matches files under the <code>bin</code> directory in the package. You can specify executable names like <code>foo</code> which will match <code>foo.exe</code> on Windows and <code>foo</code> on Linux and macOS.</li> <li><code>site_packages</code>: matches files under the <code>site-packages</code> directory in the package. You can specify the import path like <code>foobar.api</code> which will match <code>foobar/api.py</code> and <code>foobar/api/__init__.py</code>.</li> <li><code>strict</code>: when set to <code>true</code>, enables strict mode. In strict mode, the test will fail if there are any files in the package that don't match any of the specified globs. (default: <code>false</code>).</li> </ul>"},{"location":"testing/#testing-existing-packages","title":"Testing existing packages","text":"<p>The tests from the test section are actually added into your package and can also be executed straight from the existing package.</p> <p>The idea behind adding the tests into the package is that you can execute the tests independently from building the package. That is also why we are shipping a <code>test</code> subcommand that takes as input an existing package and executes the tests:</p> <pre><code>rattler-build test --package-file ./xtensor-0.24.6-h60d57d3_0.tar.bz2\n</code></pre> <p>Running the above command will extract the package and create a clean environment where the package and dependencies are installed. Then the tests are executed in this newly-created environment.</p> <p>If you inspect the package contents, you would find the test files under <code>info/test/*</code>.</p>"},{"location":"testing/#how-tests-are-translated","title":"How tests are translated","text":"<p>The <code>tests</code> section allows you to define test configurations for your package. Tests are serialized to <code>info/tests/tests.yaml</code> in the created package and read from there during test execution.</p> <p>When adding extra files to your tests:</p> <ol> <li>During package creation<ul> <li>Files are copied to <code>$PREFIX/etc/conda/test-files/{pkg_name}/{idx}</code></li> <li><code>{idx}</code> is a sequential number assigned to each test</li> <li>Files can come from both <code>source</code> (work directory) and <code>recipe</code> locations</li> </ul> </li> <li>During test execution<ul> <li>Files are copied from <code>$PREFIX/etc/conda/test-files/{pkg_name}/{idx}</code> to a temporary directory</li> <li>Tests run within this temporary directory</li> <li>Use relative paths to access these files in your test commands</li> </ul> </li> </ol> <p>This approach ensures test files are properly packaged and available during test execution.</p>"},{"location":"testing/#legacy-tests","title":"Legacy tests","text":"<p>Legacy tests (from <code>conda-build</code>) are still supported for execution. These tests are stored as files under the <code>info/test/</code> folder.</p> <p>The files are:</p> <ul> <li><code>run_test.sh</code> (Unix)</li> <li><code>run_test.bat</code> (Windows)</li> <li><code>run_test.py</code> (for the Python import tests)</li> <li><code>test_time_dependencies.json</code> (for additional dependencies at test time)</li> </ul> <p>Additionally, the <code>info/test/</code> folder contains all the files specified in the test section as <code>source_files</code> and <code>files</code>. The tests are executed pointing to this directory as the current working directory.</p>"},{"location":"tips_and_tricks/","title":"Tips and tricks for rattler-build","text":"<p>This section contains some tips and tricks for using <code>rattler-build</code>.</p>"},{"location":"tips_and_tricks/#using-sccache-or-ccache-with-rattler-build","title":"Using sccache or ccache with <code>rattler-build</code>","text":"<p>When debugging a recipe it can help a lot to use <code>sccache</code> or <code>ccache</code>. You can install both tools e.g. with <code>pixi global install sccache</code>.</p> <p>To use them with a CMake project, you can use the following variables:</p> <pre><code>export CMAKE_C_COMPILER_LAUNCHER=sccache\nexport CMAKE_CXX_COMPILER_LAUNCHER=sccache\n\n# or more generally\n\nexport C=\"sccache $C\"\nexport CXX=\"sccache $CXX\"\n</code></pre> <p>However, both <code>ccache</code> and <code>sccache</code> are sensitive to changes in the build location. Since <code>rattler-build</code>, by default, always creates a new build directory with the timestamp, you need to use the <code>--no-build-id</code> flag. This will disable the time stamp in the build directory and allow <code>ccache</code> and <code>sccache</code> to cache the build.</p> <pre><code>rattler-build build --no-build-id --recipe ./path/to/recipe.yaml\n</code></pre>"},{"location":"tips_and_tricks/#building-your-own-forge","title":"Building your own \"forge\"","text":"<p>You might want to publish your own software packages to a channel you control. These might be packages that are not available in the main conda-forge channel, or proprietary packages, or packages that you have modified in some way.</p> <p>Doing so is pretty straightforward with <code>rattler-build</code> and a CI provider of your choice. We have a number of example repositories for \"custom\" forges:</p> <ul> <li>rust-forge: This repository builds a   number of Rust packages for Windows, macOS and Linux on top of Github Actions.</li> <li>r-forge: The same idea, but for <code>R</code>   packages</li> </ul>"},{"location":"tips_and_tricks/#directory-structure","title":"Directory structure","text":"<p>To create your own forge, you should create a number of sub-directories where each sub-directory should contain at most one recipe. With the <code>--recipe-dir</code> flag of rattler-build, the program will go and collect all recipes it finds in the given directory or sub-directories.</p> <p>We can combine this with the <code>--skip-existing=all</code> flag which will skip all packages that are already built locally or in the channel (if you upload them). Using <code>all</code> will also look at the <code>repodata.json</code> file in the channel to see if the package is already there. Packages are skipped based on their complete name, including the version and build string.</p> <p>To note: the build string changes if the variant configuration changes! So if you update a package in the variant configuration, the packages that need rebuilding should be rebuilt.</p> <p>Note</p> <p>You can generate recipes for different ecosystems with the <code>rattler-build generate-recipe</code> command. Read more about it in the Generating recipes section.</p>"},{"location":"tips_and_tricks/#ci-setup","title":"CI setup","text":"<p>As an example, the following is the CI setup for <code>rust-forge</code>. The workflow uses <code>rattler-build</code> to build and upload packages to a custom channel on https://prefix.dev \u2013 but you can also use <code>rattler-build</code> to upload to your own <code>quetz</code> instance, or a channel on <code>anaconda.org</code>.</p> Example CI setup for <code>rust-forge</code> <p>The following is an example of a Github Actions workflow for <code>rust-forge</code>:</p> .github/workflows/forge.yml<pre><code>name: Build all packages\n\non:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  build:\n    strategy:\n      matrix:\n        include:\n          - { target: linux-64, os: ubuntu-20.04 }\n          - { target: win-64, os: windows-latest }\n          # force older macos-13 to get x86_64 runners\n          - { target: osx-64, os: macos-13 }\n          - { target: osx-arm64, os: macos-14 }\n      fail-fast: false\n\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 2\n      - uses: prefix-dev/setup-pixi@v0.5.1\n        with:\n          pixi-version: v0.24.2\n          cache: true\n\n      - name: Run code in changed subdirectories\n        shell: bash\n        env:\n          TARGET_PLATFORM: ${{ matrix.target }}\n\n        run: |\n          pixi run rattler-build build --recipe-dir . \\\n            --skip-existing=all --target-platform=$TARGET_PLATFORM \\\n            -c conda-forge -c https://prefix.dev/rust-forge\n\n      - name: Upload all packages\n        shell: bash\n        # do not upload on PR\n        if: github.event_name == 'push'\n        env:\n          PREFIX_API_KEY: ${{ secrets.PREFIX_API_KEY }}\n        run: |\n          # ignore errors because we want to ignore duplicate packages\n          for file in output/**/*.conda; do\n            pixi run rattler-build upload prefix -c rust-forge \"$file\" || true\n          done\n</code></pre>"},{"location":"understanding_terminal_output/","title":"Understanding the terminal output","text":"<p>When you build a recipe with rattler-build, a lot of information is printed on the terminal. Some of that information uses short codes that we are explaining here.</p> <p>Let's look at the logs together!</p>"},{"location":"understanding_terminal_output/#variant-configuration","title":"Variant configuration","text":"<pre><code> \u256d\u2500 Finding outputs from recipe\n \u2502 Found 1 variants\n \u2502 \n \u2502 Build variant: curl-8.0.1-h60d57d3_0\n \u2502 \n \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502 \u2502 Variant         \u2506 Version     \u2502\n \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 \u2502 target_platform \u2506 \"osx-arm64\" \u2502\n \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n \u2502\n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (took 0 seconds)\n</code></pre> <p>This first section shows you what variants are applied to your recipe (from the variant configuration files). In this case, we only have a single variant (<code>target_platform</code>) which is always given. A variant can also expand to a matrix of multiple variant builds, in which case you would see more than one \"output\" being built (e.g. for different versions of Python or Boost).</p> <p>You can select a single variant to build from the CLI using the <code>--variant</code> override flag (e.g. <code>--variant python=3.12</code>). To pass in a variant configuration file you can use <code>-m</code> or <code>--variant-config</code> and point to a yaml file. If a <code>variants.yaml</code> file is placed next to the recipe, it is loaded automatically.</p> <p>You can read more about variants here.</p>"},{"location":"understanding_terminal_output/#fetching-the-source-code","title":"Fetching the source code","text":"<pre><code> \u256d\u2500 Running build for recipe: curl-8.0.1-h60d57d3_0\n \u2502\n \u2502 \u256d\u2500 Fetching source code\n \u2502 \u2502 Fetching source from url: http://curl.haxx.se/download/curl-8.0.1.tar.bz2\n \u2502 \u2502 Validated SHA256 values of the downloaded file!\n \u2502 \u2502 Found valid source cache file.\n \u2502 \u2502 Using extracted directory from cache: /Users/wolfv/Programs/rattler-build/output/src_cache/curl-8_0_1_9b6b1e96\n \u2502 \u2502 Copying source from url: /Users/wolfv/Programs/rattler-build/output/src_cache/curl-8_0_1_9b6b1e96 to /Users/wolfv/Progra\n \u2502 \u2502 ms/rattler-build/output/bld/rattler-build_curl_1764660286/work\n \u2502 \u2502\n \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (took 0 seconds)\n</code></pre> <p>In this next section, the source code is fetched. The source is first downloaded to a cache directory located under the \"output\" directory (by default <code>./output/src_cache</code>, but you can change the output directory. From the cache it is copied into the <code>$SRC_DIR</code>, which is a temporary directory used during the build (in our case <code>/Users/wolfv/Programs/rattler-build/output/bld/rattler-build_curl_1764660286/work</code>). The <code>rattler-build_curl_1764660286</code> is the build folder that is created for this particular build (the <code>176...</code> is a timestamp). </p> <pre><code> \u2502 \u256d\u2500 Resolving environments\n \u2502 \u2502 \n \u2502 \u2502 Resolving build environment:\n \u2502 \u2502   Platform: osx-arm64 [__unix=0=0, __osx=15.6=0, __archspec=1=m2]\n \u2502 \u2502   Channels: \n \u2502 \u2502    - file:///Users/wolfv/Programs/rattler-build/output/\n \u2502 \u2502    - conda-forge\n \u2502 \u2502   Specs:\n \u2502 \u2502    - clang_osx-arm64\n \u2502 \u2502    - make\n \u2502 \u2502    - perl\n \u2502 \u2502    - pkg-config\n \u2502 \u2502    - libtool\n \u2502 \u2502 \n \u2502 \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502 \u2502 \u2502 Package                 \u2506 Version     \u2506 Build               \u2506 Channel     \u2506        Size \u2502\n \u2502 \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 \u2502 \u2502 bzip2                   \u2506 1.0.8       \u2506 hd037594_8          \u2506 conda-forge \u2506  122.13 KiB \u2502\n \u2502 \u2502 \u2502 ca-certificates         \u2506 2025.11.12  \u2506 hbd8a1cb_0          \u2506 conda-forge \u2506  148.86 KiB \u2502\n \u2502 \u2502 \u2502 cctools_impl_osx-arm64  \u2506 1030.6.3    \u2506 llvm21_1_haddd2d4_1 \u2506 conda-forge \u2506  730.35 KiB \u2502\n \u2502 \u2502 \u2502 cctools_osx-arm64       \u2506 1030.6.3    \u2506 llvm21_1_h6d92914_1 \u2506 conda-forge \u2506   22.26 KiB \u2502\n \u2502 \u2502 \u2502 clang                   \u2506 21.1.6      \u2506 default_hf9bcbb7_0  \u2506 conda-forge \u2506   24.39 KiB \u2502\n \u2502 \u2502 \u2502 clang-21                \u2506 21.1.6      \u2506 default_h489deba_0  \u2506 conda-forge \u2506  807.97 KiB \u2502\n \u2502 \u2502 \u2502 clang_impl_osx-arm64    \u2506 21.1.6      \u2506 hdbf2fcc_26         \u2506 conda-forge \u2506   17.52 KiB \u2502\n \u2502 \u2502 \u2502 clang_osx-arm64         \u2506 21.1.6      \u2506 h07b0088_26         \u2506 conda-forge \u2506   20.12 KiB \u2502\n \u2502 \u2502 \u2502 compiler-rt             \u2506 21.1.6      \u2506 hce30654_0          \u2506 conda-forge \u2506   15.62 KiB \u2502\n \u2502 \u2502 \u2502 compiler-rt21           \u2506 21.1.6      \u2506 h855ad52_0          \u2506 conda-forge \u2506   96.03 KiB \u2502\n \u2502 \u2502 \u2502 compiler-rt21_osx-arm64 \u2506 21.1.6      \u2506 h2514db7_0          \u2506 conda-forge \u2506   10.31 MiB \u2502\n \u2502 \u2502 \u2502 ld64                    \u2506 956.6       \u2506 llvm21_1_h5d6df6c_1 \u2506 conda-forge \u2506   20.66 KiB \u2502\n \u2502 \u2502 \u2502 ld64_osx-arm64          \u2506 956.6       \u2506 llvm21_1_hde6573c_1 \u2506 conda-forge \u2506 1013.34 KiB \u2502\n \u2502 \u2502 \u2502 libclang-cpp21.1        \u2506 21.1.6      \u2506 default_h73dfc95_0  \u2506 conda-forge \u2506   13.04 MiB \u2502\n \u2502 \u2502 \u2502 libcxx                  \u2506 21.1.6      \u2506 hf598326_0          \u2506 conda-forge \u2506  556.47 KiB \u2502\n \u2502 \u2502 \u2502 libffi                  \u2506 3.5.2       \u2506 he5f378a_0          \u2506 conda-forge \u2506   39.31 KiB \u2502\n \u2502 \u2502 \u2502 libglib                 \u2506 2.86.2      \u2506 hfe11c1f_1          \u2506 conda-forge \u2506    3.47 MiB \u2502\n \u2502 \u2502 \u2502 libiconv                \u2506 1.18        \u2506 h23cfdf5_2          \u2506 conda-forge \u2506  732.79 KiB \u2502\n \u2502 \u2502 \u2502 libintl                 \u2506 0.25.1      \u2506 h493aca8_0          \u2506 conda-forge \u2506   88.83 KiB \u2502\n \u2502 \u2502 \u2502 libllvm21               \u2506 21.1.6      \u2506 h8e0c9ce_0          \u2506 conda-forge \u2506   28.04 MiB \u2502\n \u2502 \u2502 \u2502 libltdl                 \u2506 2.4.3a      \u2506 h286801f_0          \u2506 conda-forge \u2506   36.45 KiB \u2502\n \u2502 \u2502 \u2502 liblzma                 \u2506 5.8.1       \u2506 h39f12f2_2          \u2506 conda-forge \u2506   90.12 KiB \u2502\n \u2502 \u2502 \u2502 libtool                 \u2506 2.5.4       \u2506 h286801f_0          \u2506 conda-forge \u2506  404.96 KiB \u2502\n \u2502 \u2502 \u2502 libxml2                 \u2506 2.15.1      \u2506 hba2cd1d_0          \u2506 conda-forge \u2506   39.66 KiB \u2502\n \u2502 \u2502 \u2502 libxml2-16              \u2506 2.15.1      \u2506 h8eac4d7_0          \u2506 conda-forge \u2506  453.31 KiB \u2502\n \u2502 \u2502 \u2502 libzlib                 \u2506 1.3.1       \u2506 h8359307_2          \u2506 conda-forge \u2506   45.35 KiB \u2502\n \u2502 \u2502 \u2502 llvm-openmp             \u2506 21.1.6      \u2506 h4a912ad_0          \u2506 conda-forge \u2506  279.50 KiB \u2502\n \u2502 \u2502 \u2502 llvm-tools              \u2506 21.1.6      \u2506 h855ad52_0          \u2506 conda-forge \u2506   86.46 KiB \u2502\n \u2502 \u2502 \u2502 llvm-tools-21           \u2506 21.1.6      \u2506 h91fd4e7_0          \u2506 conda-forge \u2506   17.42 MiB \u2502\n \u2502 \u2502 \u2502 make                    \u2506 4.4.1       \u2506 hc9fafa5_2          \u2506 conda-forge \u2506  267.62 KiB \u2502\n \u2502 \u2502 \u2502 ncurses                 \u2506 6.5         \u2506 h5e97a16_3          \u2506 conda-forge \u2506  778.35 KiB \u2502\n \u2502 \u2502 \u2502 openssl                 \u2506 3.6.0       \u2506 h5503f6c_0          \u2506 conda-forge \u2506    2.96 MiB \u2502\n \u2502 \u2502 \u2502 pcre2                   \u2506 10.47       \u2506 h30297fc_0          \u2506 conda-forge \u2506  830.30 KiB \u2502\n \u2502 \u2502 \u2502 perl                    \u2506 5.32.1      \u2506 7_h4614cfb_perl5    \u2506 conda-forge \u2506   13.77 MiB \u2502\n \u2502 \u2502 \u2502 pkg-config              \u2506 0.29.2      \u2506 hde07d2e_1009       \u2506 conda-forge \u2506   48.56 KiB \u2502\n \u2502 \u2502 \u2502 sdkroot_env_osx-arm64   \u2506 14.5        \u2506 hfa17104_3          \u2506 conda-forge \u2506    8.58 KiB \u2502\n \u2502 \u2502 \u2502 sigtool                 \u2506 0.1.3       \u2506 h44b9a77_0          \u2506 conda-forge \u2506  205.34 KiB \u2502\n \u2502 \u2502 \u2502 tapi                    \u2506 1600.0.11.8 \u2506 h997e182_0          \u2506 conda-forge \u2506  195.02 KiB \u2502\n \u2502 \u2502 \u2502 zstd                    \u2506 1.5.7       \u2506 hd0aec43_5          \u2506 conda-forge \u2506  380.61 KiB \u2502\n \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n \u2502 \u2502 \n \u2502 \u2502 Resolving host environment:\n \u2502 \u2502   Platform: osx-arm64 [__unix=0=0, __osx=15.6=0, __archspec=1=m2]\n \u2502 \u2502   Channels: \n \u2502 \u2502    - file:///Users/wolfv/Programs/rattler-build/output/\n \u2502 \u2502    - conda-forge\n \u2502 \u2502   Specs:\n \u2502 \u2502    - zlib\n \u2502 \u2502 \n \u2502 \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502 \u2502 \u2502 Package \u2506 Version \u2506 Build      \u2506 Channel     \u2506      Size \u2502\n \u2502 \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 \u2502 \u2502 libzlib \u2506 1.3.1   \u2506 h8359307_2 \u2506 conda-forge \u2506 45.35 KiB \u2502\n \u2502 \u2502 \u2502 zlib    \u2506 1.3.1   \u2506 h8359307_2 \u2506 conda-forge \u2506 75.79 KiB \u2502\n \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n \u2502 \u2502 \n \u2502 \u2502 Finalized run dependencies (curl-8.0.1-h60d57d3_0):\n \u2502 \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502 \u2502 \u2502 Name             \u2506 Spec                                \u2502\n \u2502 \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 \u2502 \u2502 Run dependencies \u2506                                     \u2502\n \u2502 \u2502 \u2502 libzlib          \u2506 &gt;=1.3.1,&lt;2.0a0 (RE of [host: zlib]) \u2502\n \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n \u2502 \u2502\n \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (took 1 second)\n</code></pre> <p>In this section, the build and host environments are resolved and the \"run-exports\" are collected in order to compute the final run dependencies. In this case, we did not have any explicit run dependencies, however, the <code>zlib</code> host dependency has a \"run-export\" of <code>zlib &gt;=1.3.1,&lt;2.0a0</code>.</p> <p>For the resolution of the host and build environments, the variants are also taken into account (for example compiler variants will influence what compiler is chosen).</p> <p>In the next step, the build and host environments are installed. The build environment goes to a folder called <code>build_env</code>, and the host environment to a folder called <code>host_env_placehold_placehold...</code>. The host environment is referenced by <code>$PREFIX</code>, and is where we install the new files to.</p> <pre><code> \u2502 Installing build environment\n \u2502 \u2714 Successfully updated the build environment\n \u2502 \n \u2502 Installing host environment\n \u2502 \u2714 Successfully updated the host environment\n</code></pre>"},{"location":"understanding_terminal_output/#running-the-build-script","title":"Running the build script","text":"<pre><code> \u2502 \u256d\u2500 Running build script\n \u2502 \u2502 INFO: activate_cctools_osx-arm64.sh made the following environmental changes:\n \u2502 \u2502 +AR=arm64-apple-darwin20.0.0-ar\n \u2502 \u2502 +AS=arm64-apple-darwin20.0.0-as\n \u2502 \u2502 +CHECKSYMS=arm64-apple-darwin20.0.0-checksyms\n \u2502 \u2502 +INSTALL_NAME_TOOL=arm64-apple-darwin20.0.0-install_name_tool\n \u2502 \u2502 +LD=arm64-apple-darwin20.0.0-ld\n \u2502 \u2502 +LIBTOOL=arm64-apple-darwin20.0.0-libtool\n \u2502 \u2502 +LIPO=arm64-apple-darwin20.0.0-lipo\n \u2502 \u2502 +NM=arm64-apple-darwin20.0.0-nm\n \u2502 \u2502 +NMEDIT=arm64-apple-darwin20.0.0-nmedit\n \u2502 \u2502 +OTOOL=arm64-apple-darwin20.0.0-otool\n \u2502 \u2502 +PAGESTUFF=arm64-apple-darwin20.0.0-pagestuff\n \u2502 \u2502 +RANLIB=arm64-apple-darwin20.0.0-ranlib\n \u2502 \u2502 +REDO_PREBINDING=arm64-apple-darwin20.0.0-redo_prebinding\n \u2502 \u2502 +SEG_ADDR_TABLE=arm64-apple-darwin20.0.0-seg_addr_table\n \u2502 \u2502 +SEG_HACK=arm64-apple-darwin20.0.0-seg_hack\n \u2502 \u2502 +SEGEDIT=arm64-apple-darwin20.0.0-segedit\n \u2502 \u2502 +SIZE=arm64-apple-darwin20.0.0-size\n \u2502 \u2502 +STRINGS=arm64-apple-darwin20.0.0-strings\n \u2502 \u2502 +STRIP=arm64-apple-darwin20.0.0-strip\n \u2502 \u2502 INFO: activate_clang_osx-arm64.sh made the following environmental changes:\n \u2502 \u2502 -CONDA_BUILD_CROSS_COMPILATION=0\n \u2502 \u2502 +_CONDA_PYTHON_SYSCONFIGDATA_NAME=_sysconfigdata_arm64_apple_darwin20_0_0\n \u2502 \u2502 +ac_cv_func_malloc_0_nonnull=yes\n \u2502 \u2502 +ac_cv_func_realloc_0_nonnull=yes\n \u2502 \u2502 +build_alias=arm64-apple-darwin20.0.0\n \u2502 \u2502 +CC_FOR_BUILD=$BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-clang\n \u2502 \u2502 +CC=arm64-apple-darwin20.0.0-clang\n \u2502 \u2502 +CFLAGS=-ftree-vectorize -fPIC -fstack-protector-strong -O2 -pipe -isystem $PREFIX/include -fdebug-prefix-map=$SRC_DIR=/\n \u2502 \u2502 usr/local/src/conda/curl-8.0.1 -fdebug-prefix-map=$PREFIX=/usr/local/src/conda-prefix\n \u2502 \u2502 +CLANG=arm64-apple-darwin20.0.0-clang\n \u2502 \u2502 +CMAKE_ARGS=-DCMAKE_AR=$BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-ar -DCMAKE_CXX_COMPILER_AR=$BUILD_PREFIX/bin/arm64-app\n \u2502 \u2502 le-darwin20.0.0-ar -DCMAKE_C_COMPILER_AR=$BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-ar -DCMAKE_RANLIB=$BUILD_PREFIX/bin/\n \u2502 \u2502 arm64-apple-darwin20.0.0-ranlib -DCMAKE_CXX_COMPILER_RANLIB=$BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-ranlib -DCMAKE_C_\n \u2502 \u2502 COMPILER_RANLIB=$BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-ranlib -DCMAKE_LINKER=$BUILD_PREFIX/bin/arm64-apple-darwin20.\n \u2502 \u2502 0.0-ld -DCMAKE_STRIP=$BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-strip -DCMAKE_INSTALL_NAME_TOOL=$BUILD_PREFIX/bin/arm64-\n \u2502 \u2502 apple-darwin20.0.0-install_name_tool -DCMAKE_LIBTOOL=$BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-libtool -DCMAKE_OSX_DEPL\n \u2502 \u2502 OYMENT_TARGET=11.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_FIND_FRAMEWORK=LAST -DCMAKE_FIND_APPBUNDLE=LAST -DCMAKE_INSTALL_PR\n \u2502 \u2502 EFIX=$PREFIX -DCMAKE_INSTALL_LIBDIR=lib -DCMAKE_PROGRAM_PATH=$BUILD_PREFIX/bin;$PREFIX/bin\n \u2502 \u2502 +CMAKE_PREFIX_PATH=:$PREFIX\n \u2502 \u2502 +CONDA_TOOLCHAIN_BUILD=arm64-apple-darwin20.0.0\n \u2502 \u2502 +CONDA_TOOLCHAIN_HOST=arm64-apple-darwin20.0.0\n \u2502 \u2502 +CPP_FOR_BUILD=$BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-clang-cpp\n \u2502 \u2502 +CPP=arm64-apple-darwin20.0.0-clang-cpp\n \u2502 \u2502 +CPPFLAGS=-D_FORTIFY_SOURCE=2 -isystem $PREFIX/include -mmacosx-version-min=11.0\n \u2502 \u2502 +DEBUG_CFLAGS=-ftree-vectorize -fPIC -fstack-protector-strong -O2 -pipe -Og -g -Wall -Wextra -isystem $PREFIX/include -f\n \u2502 \u2502 debug-prefix-map=$SRC_DIR=/usr/local/src/conda/curl-8.0.1 -fdebug-prefix-map=$PREFIX=/usr/local/src/conda-prefix\n \u2502 \u2502 +host_alias=arm64-apple-darwin20.0.0\n \u2502 \u2502 +HOST=arm64-apple-darwin20.0.0\n \u2502 \u2502 +LDFLAGS_LD=-headerpad_max_install_names -dead_strip_dylibs -rpath $PREFIX/lib -L$PREFIX/lib\n \u2502 \u2502 +LDFLAGS=-Wl,-headerpad_max_install_names -Wl,-dead_strip_dylibs -Wl,-rpath,$PREFIX/lib -L$PREFIX/lib\n \u2502 \u2502 +MESON_ARGS=-Dbuildtype=release --prefix=$PREFIX -Dlibdir=lib\n \u2502 \u2502 +OBJC_FOR_BUILD=$BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-clang\n \u2502 \u2502 +OBJC=arm64-apple-darwin20.0.0-clang\n \u2502 \u2502 checking whether to enable maintainer-specific portions of Makefiles... no\n \u2502 \u2502 checking whether make supports nested variables... yes\n \u2502 \u2502 checking whether to enable debug build options... no\n \u2502 \u2502 checking whether to enable compiler optimizer... (assumed) yes\n \u2502 \u2502 checking whether to enable strict compiler warnings... no\n \u2502 \u2502 checking whether to enable compiler warnings as errors... no\n \u2502 \u2502 checking whether to enable curl debug memory tracking... no\n \u2502 \u2502 checking whether to enable hiding of library internal symbols... yes\n \u2502 \u2502 checking whether to enable c-ares for DNS lookups... no\n \u2502 \u2502 checking whether to disable dependency on -lrt... (assumed no)\n \u2502 \u2502 checking whether to enable ECH support... no\n \u2502 \u2502 checking for path separator... :\n \u2502 \u2502 checking for sed... /Users/wolfv/.pixi/bin/sed\n \u2502 \u2502 checking for grep... /Users/wolfv/.pixi/bin/grep\n \u2502 \u2502 checking that grep -E works... yes\n \u2502 \u2502 checking for a BSD-compatible install... /Users/wolfv/.pixi/bin/install -c\n \u2502 \u2502 checking for arm64-apple-darwin20.0.0-gcc... arm64-apple-darwin20.0.0-clang\n \u2502 \u2502 checking whether the C compiler works... yes\n \u2502 \u2502 checking for C compiler default output file name... a.out\n \u2502 \u2502 checking for suffix of executables... \n \u2502 \u2502 checking whether we are cross compiling... no\n \u2502 \u2502 checking for suffix of object files... o\n \u2502 \u2502 checking whether the compiler supports GNU C... yes\n \u2502 \u2502 checking whether arm64-apple-darwin20.0.0-clang accepts -g... yes\n \u2502 \u2502 checking for arm64-apple-darwin20.0.0-clang option to enable C11 features... none needed\n \u2502 \u2502 checking whether arm64-apple-darwin20.0.0-clang understands -c and -o together... yes\n \u2502 \u2502 checking how to run the C preprocessor... arm64-apple-darwin20.0.0-clang-cpp\n \u2502 \u2502 checking for stdio.h... yes\n \u2502 \u2502 checking for stdlib.h... yes\n \u2502 \u2502 checking for string.h... yes\n \u2502 \u2502 checking for inttypes.h... yes\n \u2502 \u2502 checking for stdint.h... yes\n \u2502 \u2502 checking for strings.h... yes\n \u2502 \u2502 checking for sys/stat.h... yes\n \u2502 \u2502 checking for sys/types.h... yes\n \u2502 \u2502 checking for unistd.h... yes\n \u2502 \u2502 checking for stdatomic.h... yes\n \u2502 \u2502 checking if _Atomic is available... yes\n \u2502 \u2502 checking for a sed that does not truncate output... (cached) /Users/wolfv/.pixi/bin/sed\n \u2502 \u2502 checking for code coverage support... no\n \u2502 \u2502 checking whether build environment is sane... yes\n \u2502 \u2502 checking for a race-free mkdir -p... /Users/wolfv/.pixi/bin/mkdir -p\n \u2502 \u2502 checking for gawk... gawk\n \u2502 \u2502 checking whether make sets $(MAKE)... yes\n \u2502 \u2502 checking whether make supports the include directive... yes (GNU style)\n \u2502 \u2502 checking dependency style of arm64-apple-darwin20.0.0-clang... gcc3\n \u2502 \u2502 checking curl version... 8.0.1\n \u2502 \u2502 checking for httpd... /usr/sbin/httpd\n \u2502 \u2502 checking for apachectl... /usr/sbin/apachectl\n \u2502 \u2502 checking for apxs... no\n \u2502 \u2502 configure: apxs not in PATH, httpd tests disabled\n \u2502 \u2502 checking for nghttpx... no\n \u2502 \u2502 checking for caddy... no\n \u2502 \u2502 checking build system type... aarch64-apple-darwin20.0.0\n \u2502 \u2502 checking host system type... aarch64-apple-darwin20.0.0\n \u2502 \u2502 checking for grep that handles long lines and -e... (cached) /Users/wolfv/.pixi/bin/grep\n \u2502 \u2502 checking for egrep... /Users/wolfv/.pixi/bin/grep -E\n \u2502 \u2502 checking if OS is AIX (to define _ALL_SOURCE)... no\n \u2502 \u2502 checking if _THREAD_SAFE is already defined... no\n \u2502 \u2502 checking if _THREAD_SAFE is actually needed... no\n \u2502 \u2502 checking if _THREAD_SAFE is onwards defined... no\n \u2502 \u2502 checking if _REENTRANT is already defined... no\n \u2502 \u2502 checking if _REENTRANT is actually needed... no\n \u2502 \u2502 checking if _REENTRANT is onwards defined... no\n \u2502 \u2502 checking for special C compiler options needed for large files... no\n \u2502 \u2502 checking for _FILE_OFFSET_BITS value needed for large files... no\n | | ... \n | | ... more output from autotools\n | | ... \n | | # COMPILATION STARTS - configuration is printed\n \u2502 \u2502 configure: Configured to build curl/libcurl:\n \u2502 \u2502   Host setup:       aarch64-apple-darwin20.0.0\n \u2502 \u2502   Install prefix:   $PREFIX\n \u2502 \u2502   Compiler:         arm64-apple-darwin20.0.0-clang\n \u2502 \u2502    CFLAGS:          -ftree-vectorize -fPIC -fstack-protector-strong -O2 -pipe -isystem $PREFIX/include -fdebug-prefix-ma\n \u2502 \u2502 p=$SRC_DIR=/usr/local/src/conda/curl-8.0.1 -fdebug-prefix-map=$PREFIX=/usr/local/src/conda-prefix -Qunused-arguments -Wn\n \u2502 \u2502 o-pointer-bool-conversion -Werror=partial-availability\n \u2502 \u2502    CPPFLAGS:        -D_FORTIFY_SOURCE=2 -isystem $PREFIX/include -mmacosx-version-min=11.0 -isystem $PREFIX/include\n \u2502 \u2502    LDFLAGS:         -Wl,-headerpad_max_install_names -Wl,-dead_strip_dylibs -Wl,-rpath,$PREFIX/lib -L$PREFIX/lib -framew\n \u2502 \u2502 ork CoreFoundation -framework SystemConfiguration -L$PREFIX/lib -framework CoreFoundation -framework Security\n \u2502 \u2502    LIBS:            -lldap -lz\n \u2502 \u2502   curl version:     8.0.1\n \u2502 \u2502   SSL:              enabled (Secure Transport)\n \u2502 \u2502   SSH:              no      (--with-{libssh,libssh2})\n \u2502 \u2502   zlib:             enabled\n \u2502 \u2502   brotli:           no      (--with-brotli)\n \u2502 \u2502   zstd:             no      (--with-zstd)\n \u2502 \u2502   GSS-API:          no      (--with-gssapi)\n \u2502 \u2502   GSASL:            no      (libgsasl not found)\n \u2502 \u2502   TLS-SRP:          no      (--enable-tls-srp)\n \u2502 \u2502   resolver:         POSIX threaded\n \u2502 \u2502   IPv6:             no      (--enable-ipv6)\n \u2502 \u2502   Unix sockets:     enabled\n \u2502 \u2502   IDN:              no      (--with-{libidn2,winidn})\n \u2502 \u2502   Build libcurl:    Shared=yes, Static=no\n \u2502 \u2502   Built-in manual:  no      (--enable-manual)\n \u2502 \u2502   --libcurl option: enabled (--disable-libcurl-option)\n \u2502 \u2502   Verbose errors:   enabled (--disable-verbose)\n \u2502 \u2502   Code coverage:    disabled\n \u2502 \u2502   SSPI:             no      (--enable-sspi)\n \u2502 \u2502   ca cert bundle:   no\n \u2502 \u2502   ca cert path:     \n \u2502 \u2502   ca fallback:      \n \u2502 \u2502   LDAP:             enabled (OpenLDAP)\n \u2502 \u2502   LDAPS:            enabled\n \u2502 \u2502   RTSP:             enabled\n \u2502 \u2502   RTMP:             no      (--with-librtmp)\n \u2502 \u2502   PSL:              no      (libpsl not found)\n \u2502 \u2502   Alt-svc:          enabled (--disable-alt-svc)\n \u2502 \u2502   Headers API:      enabled (--disable-headers-api)\n \u2502 \u2502   HSTS:             enabled (--disable-hsts)\n \u2502 \u2502   HTTP1:            enabled (internal)\n \u2502 \u2502   HTTP2:            no      (--with-nghttp2, --with-hyper)\n \u2502 \u2502   HTTP3:            no      (--with-ngtcp2, --with-quiche --with-msh3)\n \u2502 \u2502   ECH:              no      (--enable-ech)\n \u2502 \u2502   WebSockets:       no      (--enable-websockets)\n \u2502 \u2502   Protocols:        DICT FILE FTP FTPS GOPHER GOPHERS HTTP HTTPS IMAP IMAPS LDAP LDAPS MQTT POP3 POP3S RTSP SMB SMBS SMT\n \u2502 \u2502 P SMTPS TELNET TFTP\n \u2502 \u2502   Features:         AsynchDNS HSTS HTTPS-proxy Largefile NTLM NTLM_WB SSL UnixSockets alt-svc libz threadsafe\n \u2502 \u2502 Making all in lib\n \u2502 \u2502 make[1]: Entering directory '$SRC_DIR/lib'\n \u2502 \u2502 make  all-am\n \u2502 \u2502 make[2]: Entering directory '$SRC_DIR/lib'\n \u2502 \u2502   CC       libcurl_la-altsvc.lo\n \u2502 \u2502   CC       libcurl_la-amigaos.lo\n \u2502 \u2502   CC       libcurl_la-asyn-ares.lo\n \u2502 \u2502   CC       libcurl_la-bufref.lo\n \u2502 \u2502   CC       libcurl_la-asyn-thread.lo\n \u2502 \u2502   CC       libcurl_la-base64.lo\n \u2502 \u2502   CC       libcurl_la-cf-https-connect.lo\n \u2502 \u2502   CC       libcurl_la-c-hyper.lo\n \u2502 \u2502   CC       libcurl_la-cfilters.lo\n \u2502 \u2502   CC       libcurl_la-cf-socket.lo\n \u2502 \u2502   CC       libcurl_la-conncache.lo\n \u2502 \u2502   CC       libcurl_la-connect.lo\n | | ...\n | | ... more compilation ...\n | | ... \n  \u2502 \u2502 make[6]: Nothing to be done for 'install-exec-am'.\n \u2502 \u2502  /Users/wolfv/.pixi/bin/mkdir -p '$PREFIX/share/aclocal'\n \u2502 \u2502  /Users/wolfv/.pixi/bin/install -c -m 644 libcurl.m4 '$PREFIX/share/aclocal'\n \u2502 \u2502  /Users/wolfv/.pixi/bin/mkdir -p '$PREFIX/share/man/man3'\n \u2502 \u2502  /Users/wolfv/.pixi/bin/install -c -m 644 curl_easy_cleanup.3 curl_easy_duphandle.3 curl_easy_escape.3 curl_easy_getinfo '$PREFIX/share/man/man3'\n \u2502 \u2502  /Users/wolfv/.pixi/bin/install -c -m 644 libcurl-easy.3 libcurl-env.3 libcurl-errors.3 libcurl-multi.3 libcurl-security\n \u2502 \u2502 .3 libcurl-share.3 libcurl-symbols.3 libcurl-thread.3 libcurl-tutorial.3 libcurl-url.3 libcurl.3 '$PREFIX/share/man/man3\n \u2502 \u2502 '\n \u2502 \u2502 make[6]: Leaving directory '$SRC_DIR/docs/libcurl'\n \u2502 \u2502 make[1]: Leaving directory '$SRC_DIR'\n \u2502 \u2502\n \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (took 59 seconds)\n</code></pre> <p>This section (already shortened) is the full build log of the curl. It depends heavily on the package and the tools that are used in the build script on what is printed here. But usually, you can expect some environment variables at the start (e.g. from compiler activation scripts), some output from configuring the compilation (if it is a compiled package), and output from pip, ninja, make or other tools to build the package. After building is completed, files should be installed into the $PREFIX.</p>"},{"location":"understanding_terminal_output/#package-contents","title":"Package contents","text":"<p>This section shows some important diagnostic information.</p> <pre><code> \u2502 \u256d\u2500 Packaging new files\n \u2502 \u2502 Copying done!\n \u2502 \u2502 Relinking \"libcurl.4.dylib\"\n \u2502 \u2502 Relinking \"curl\"\n</code></pre> <p>This shows that we are \"re-linking\" both the <code>dylib</code> and the <code>curl</code> executable to make them relocatable binaries. In practice, this means that the <code>rpath</code> of the binaries is adjusted to make them look for shared libraries in relative locations (relative to their installation location, and thus \"relocatable\"). You can read more about relinking under Debugging builds.</p> <pre><code> \u2502 \u2502 [lib/libcurl.4.dylib] links against:\n \u2502 \u2502  \u251c\u2500 /usr/lib/libSystem.B.dylib (system)\n \u2502 \u2502  \u251c\u2500 /System/Library/Frameworks/LDAP.framework/Versions/A/LDAP (system)\n \u2502 \u2502  \u251c\u2500 lib/libcurl.4.dylib (package)\n \u2502 \u2502  \u251c\u2500 /System/Library/Frameworks/Security.framework/Versions/A/Security (system)\n \u2502 \u2502  \u251c\u2500 lib/libz.1.3.1.dylib (libzlib)\n \u2502 \u2502  \u2514\u2500 /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (system)\n \u2502 \u2502 \n \u2502 \u2502 [bin/curl] links against:\n \u2502 \u2502  \u251c\u2500 /usr/lib/libSystem.B.dylib (system)\n \u2502 \u2502  \u2514\u2500 lib/libcurl.4.dylib (package)\n</code></pre> <p>We also see some output that shows us against what the binaries are linking. Some of the shared libraries are provided by the system (under <code>/System/...</code> on macOS), and some are provided by other packages (such as <code>libz.1.3.1.dylib</code>).</p> <p>We try to prevent linking against libraries that are not \"allow-listed\" on the system (ie. always installed on Linux/macOS/Windows) or not provided by any package from the dependencies (that is over-linking or under-depending). All linked libraries should either come from a declared dependency or from the allowed system libraries.</p> <p>There are additional options to control this behavior in the dynamic linking configuration.</p> <pre><code> \u2502 \u2502 Post-processing done!\n \u2502 \u2502 Writing test files\n \u2502 \u2502 Writing metadata for package\n \u2502 \u2502 Copying license files\n \u2502 \u2502 Copying recipe files\n</code></pre> <p>Here, data is written for the <code>info/</code> folder: we copy the test files into the correct locations and create a big <code>tests.yaml</code> file for later execution (when the package is finally assembled). We also write some metadata, like <code>about.json</code> or <code>index.json</code> files according to the metadata provided in the recipe.</p> <p>Then, any license files matched by the globs given are copied into <code>info/licenses</code> and the recipe and all files next to it are copied to <code>info/recipe</code>.</p> <pre><code> \u2502 \u2502 Files in package:\n \u2502 \u2502   \u251c\u2500 bin/curl (198.28 KiB)\n \u2502 \u2502   \u251c\u2500 bin/curl-config (8.92 KiB) [prefix:text]\n \u2502 \u2502   \u251c\u2500 include/curl/curl.h (124.84 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/curlver.h (2.97 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/easy.h (3.93 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/header.h (2.84 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/mprintf.h (2.07 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/multi.h (16.91 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/options.h (2.34 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/stdcheaders.h (1.33 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/system.h (18.67 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/typecheck-gcc.h (42.45 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/urlapi.h (5.28 KiB)\n \u2502 \u2502   \u251c\u2500 include/curl/websockets.h (2.68 KiB)\n \u2502 \u2502   \u251c\u2500 lib/libcurl.4.dylib (541.50 KiB)\n \u2502 \u2502   \u251c\u2500 lib/libcurl.dylib -&gt; libcurl.4.dylib\n \u2502 \u2502   \u251c\u2500 lib/pkgconfig/libcurl.pc (1.86 KiB) [prefix:text]\n \u2502 \u2502   \u251c\u2500 info/about.json (453 B)\n \u2502 \u2502   \u251c\u2500 info/hash_input.json (32 B)\n \u2502 \u2502   \u251c\u2500 info/index.json (253 B)\n \u2502 \u2502   \u251c\u2500 info/licenses/COPYING (1.06 KiB)\n \u2502 \u2502   \u251c\u2500 info/paths.json (3.91 KiB)\n \u2502 \u2502   \u251c\u2500 info/recipe/build.bat (371 B)\n \u2502 \u2502   \u251c\u2500 info/recipe/build.sh (520 B)\n \u2502 \u2502   \u251c\u2500 info/recipe/changes.patch (263 B)\n \u2502 \u2502   \u251c\u2500 info/recipe/recipe.yaml (966 B)\n \u2502 \u2502   \u251c\u2500 info/recipe/rendered_recipe.yaml (30.32 KiB)\n \u2502 \u2502   \u251c\u2500 info/recipe/variant_config.yaml (27 B)\n \u2502 \u2502   \u2514\u2500 info/tests/tests.yaml (38 B)\n \u2502 \u2502 \n \u2502 \u2502 Package statistics: 29 files (17 content, 12 metadata), total size: 1015.02 KiB\n \u2502 \u2502 Largest files:\n \u2502 \u2502   541.50 KiB - lib/libcurl.4.dylib\n \u2502 \u2502   198.28 KiB - bin/curl\n \u2502 \u2502   124.84 KiB - include/curl/curl.h\n \u2502 \u2502   42.45 KiB - include/curl/typecheck-gcc.h\n \u2502 \u2502   30.32 KiB - info/recipe/rendered_recipe.yaml\n</code></pre> <p>With everything said and done, we are listing the final files for the package! This is a good thing to check as these are the contents!</p> <p>The files are highlighted:</p> <ul> <li>green: executable</li> <li>magenta: symlink (shows symlink target)</li> <li>yellow brackets: files that contain the value of <code>$PREFIX</code> as a string (<code>[prefix:text]</code> or <code>[prefix:bin]</code>).</li> </ul> <p>Files that contain the $PREFIX (that is files that contain the current installation path, e.g. <code>/user/name/.../output/.../host_env_placehold_placehold...</code>) are marked with the yellow brackets. </p> <p>When a file contains the $PREFIX as a string, it will be replaced at installation time with the actual installation prefix (that is also the reason for the long placeholder string!). You can read more about prefix replacement in Debugging Builds. Ideally, no file contains the installation prefix as string, so that there is no text replacement at installation time.</p> <p>We then see a listing of the largest files in the package which can be a helpful sanity check.</p> <p>Lastly the files are compressed and \"packaged\":</p> <pre><code> \u2502 \u2502 Creating target folder '/Users/wolfv/Programs/rattler-build/output/osx-arm64'\n \u2502 \u2502 Compressing archive...\n \u2502 \u2502 Archive written to '/Users/wolfv/Programs/rattler-build/output/osx-arm64/curl-8.0.1-h60d57d3_0.conda'\n \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (took 1 second)\n \u2502\n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (took 62 seconds)\n</code></pre>"},{"location":"understanding_terminal_output/#testing-the-package","title":"Testing the package","text":"<p>Now, with the package completed, the tests can run!</p> <pre><code> \u256d\u2500 Running script test for recipe: curl-8.0.1-h60d57d3_0.conda\n \u2502 \n \u2502 Resolving test environment:\n \u2502   Platform: osx-arm64 [__unix=0=0, __osx=15.6=0, __archspec=1=m2]\n \u2502   Channels: \n \u2502    - file:///var/folders/ls/nd2_c1qn1tz8c8sccxmg83m00000gn/T/.tmpCi1Blz/\n \u2502    - file:///Users/wolfv/Programs/rattler-build/output/\n \u2502    - conda-forge\n \u2502   Specs:\n \u2502    - curl ==8.0.1 h60d57d3_0\n \u2502 \n \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502 \u2502 Package \u2506 Version \u2506 Build      \u2506 Channel     \u2506       Size \u2502\n \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 \u2502 curl    \u2506 8.0.1   \u2506 h60d57d3_0 \u2506 .tmpCi1Blz  \u2506 376.73 KiB \u2502\n \u2502 \u2502 libzlib \u2506 1.3.1   \u2506 h8359307_2 \u2506 conda-forge \u2506  45.35 KiB \u2502\n \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n \u2502 \n \u2502 Installing test environment\n \u2502 \u2714 Successfully updated the test environment\n \u2502 Testing commands:\n \u2502 curl 8.0.1 (aarch64-apple-darwin20.0.0) libcurl/8.0.1 SecureTransport zlib/1.3.1\n \u2502 Release-Date: 2023-03-20\n \u2502 Protocols: dict file ftp ftps gopher gophers http https imap imaps ldap ldaps mqtt pop3 pop3s rtsp smb smbs smtp smtps tel\n \u2502 net tftp\n \u2502 Features: alt-svc AsynchDNS HSTS HTTPS-proxy Largefile libz NTLM NTLM_WB SSL threadsafe UnixSockets\n \u2502\n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (took 0 seconds)\n \u2714 all tests passed!\n</code></pre> <p>This executes a \"script\" test which just runs <code>curl --version</code>.</p>"},{"location":"understanding_terminal_output/#build-summary","title":"Build summary","text":"<p>Lastly, the build is summarized:</p> <pre><code> \u256d\u2500 Build summary\n \u2502\n \u2502 \u256d\u2500 Build summary for recipe: curl-8.0.1-h60d57d3_0\n \u2502 \u2502 Variant configuration (hash: h60d57d3_0):\n \u2502 \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502 \u2502 \u2502 target_platform \u2506 \"osx-arm64\" \u2502\n \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n \u2502 \u2502 \n \u2502 \u2502 Build dependencies:\n \u2502 \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502 \u2502 \u2502 Package                 \u2506 Spec            \u2506 Version     \u2506 Build               \u2506 Channel     \u2506        Size \u2502\n \u2502 \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 \u2502 \u2502 clang_osx-arm64         \u2506 clang_osx-arm64 \u2506 21.1.6      \u2506 h07b0088_26         \u2506 conda-forge \u2506   20.12 KiB \u2502\n \u2502 \u2502 \u2502 libtool                 \u2506 libtool         \u2506 2.5.4       \u2506 h286801f_0          \u2506 conda-forge \u2506  404.96 KiB \u2502\n \u2502 \u2502 \u2502 make                    \u2506 make            \u2506 4.4.1       \u2506 hc9fafa5_2          \u2506 conda-forge \u2506  267.62 KiB \u2502\n \u2502 \u2502 \u2502 perl                    \u2506 perl            \u2506 5.32.1      \u2506 7_h4614cfb_perl5    \u2506 conda-forge \u2506   13.77 MiB \u2502\n \u2502 \u2502 \u2502 pkg-config              \u2506 pkg-config      \u2506 0.29.2      \u2506 hde07d2e_1009       \u2506 conda-forge \u2506   48.56 KiB \u2502\n \u2502 \u2502 \u2502 bzip2                   \u2506                 \u2506 1.0.8       \u2506 hd037594_8          \u2506 conda-forge \u2506  122.13 KiB \u2502\n \u2502 \u2502 \u2502 ca-certificates         \u2506                 \u2506 2025.11.12  \u2506 hbd8a1cb_0          \u2506 conda-forge \u2506  148.86 KiB \u2502\n \u2502 \u2502 \u2502 cctools_impl_osx-arm64  \u2506                 \u2506 1030.6.3    \u2506 llvm21_1_haddd2d4_1 \u2506 conda-forge \u2506  730.35 KiB \u2502\n \u2502 \u2502 \u2502 cctools_osx-arm64       \u2506                 \u2506 1030.6.3    \u2506 llvm21_1_h6d92914_1 \u2506 conda-forge \u2506   22.26 KiB \u2502\n \u2502 \u2502 \u2502 clang                   \u2506                 \u2506 21.1.6      \u2506 default_hf9bcbb7_0  \u2506 conda-forge \u2506   24.39 KiB \u2502\n \u2502 \u2502 \u2502 clang-21                \u2506                 \u2506 21.1.6      \u2506 default_h489deba_0  \u2506 conda-forge \u2506  807.97 KiB \u2502\n \u2502 \u2502 \u2502 clang_impl_osx-arm64    \u2506                 \u2506 21.1.6      \u2506 hdbf2fcc_26         \u2506 conda-forge \u2506   17.52 KiB \u2502\n \u2502 \u2502 \u2502 compiler-rt             \u2506                 \u2506 21.1.6      \u2506 hce30654_0          \u2506 conda-forge \u2506   15.62 KiB \u2502\n \u2502 \u2502 \u2502 compiler-rt21           \u2506                 \u2506 21.1.6      \u2506 h855ad52_0          \u2506 conda-forge \u2506   96.03 KiB \u2502\n \u2502 \u2502 \u2502 compiler-rt21_osx-arm64 \u2506                 \u2506 21.1.6      \u2506 h2514db7_0          \u2506 conda-forge \u2506   10.31 MiB \u2502\n \u2502 \u2502 \u2502 ld64                    \u2506                 \u2506 956.6       \u2506 llvm21_1_h5d6df6c_1 \u2506 conda-forge \u2506   20.66 KiB \u2502\n \u2502 \u2502 \u2502 ld64_osx-arm64          \u2506                 \u2506 956.6       \u2506 llvm21_1_hde6573c_1 \u2506 conda-forge \u2506 1013.34 KiB \u2502\n \u2502 \u2502 \u2502 libclang-cpp21.1        \u2506                 \u2506 21.1.6      \u2506 default_h73dfc95_0  \u2506 conda-forge \u2506   13.04 MiB \u2502\n \u2502 \u2502 \u2502 libcxx                  \u2506                 \u2506 21.1.6      \u2506 hf598326_0          \u2506 conda-forge \u2506  556.47 KiB \u2502\n \u2502 \u2502 \u2502 libffi                  \u2506                 \u2506 3.5.2       \u2506 he5f378a_0          \u2506 conda-forge \u2506   39.31 KiB \u2502\n \u2502 \u2502 \u2502 libglib                 \u2506                 \u2506 2.86.2      \u2506 hfe11c1f_1          \u2506 conda-forge \u2506    3.47 MiB \u2502\n \u2502 \u2502 \u2502 libiconv                \u2506                 \u2506 1.18        \u2506 h23cfdf5_2          \u2506 conda-forge \u2506  732.79 KiB \u2502\n \u2502 \u2502 \u2502 libintl                 \u2506                 \u2506 0.25.1      \u2506 h493aca8_0          \u2506 conda-forge \u2506   88.83 KiB \u2502\n \u2502 \u2502 \u2502 libllvm21               \u2506                 \u2506 21.1.6      \u2506 h8e0c9ce_0          \u2506 conda-forge \u2506   28.04 MiB \u2502\n \u2502 \u2502 \u2502 libltdl                 \u2506                 \u2506 2.4.3a      \u2506 h286801f_0          \u2506 conda-forge \u2506   36.45 KiB \u2502\n \u2502 \u2502 \u2502 liblzma                 \u2506                 \u2506 5.8.1       \u2506 h39f12f2_2          \u2506 conda-forge \u2506   90.12 KiB \u2502\n \u2502 \u2502 \u2502 libxml2                 \u2506                 \u2506 2.15.1      \u2506 hba2cd1d_0          \u2506 conda-forge \u2506   39.66 KiB \u2502\n \u2502 \u2502 \u2502 libxml2-16              \u2506                 \u2506 2.15.1      \u2506 h8eac4d7_0          \u2506 conda-forge \u2506  453.31 KiB \u2502\n \u2502 \u2502 \u2502 libzlib                 \u2506                 \u2506 1.3.1       \u2506 h8359307_2          \u2506 conda-forge \u2506   45.35 KiB \u2502\n \u2502 \u2502 \u2502 llvm-openmp             \u2506                 \u2506 21.1.6      \u2506 h4a912ad_0          \u2506 conda-forge \u2506  279.50 KiB \u2502\n \u2502 \u2502 \u2502 llvm-tools              \u2506                 \u2506 21.1.6      \u2506 h855ad52_0          \u2506 conda-forge \u2506   86.46 KiB \u2502\n \u2502 \u2502 \u2502 llvm-tools-21           \u2506                 \u2506 21.1.6      \u2506 h91fd4e7_0          \u2506 conda-forge \u2506   17.42 MiB \u2502\n \u2502 \u2502 \u2502 ncurses                 \u2506                 \u2506 6.5         \u2506 h5e97a16_3          \u2506 conda-forge \u2506  778.35 KiB \u2502\n \u2502 \u2502 \u2502 openssl                 \u2506                 \u2506 3.6.0       \u2506 h5503f6c_0          \u2506 conda-forge \u2506    2.96 MiB \u2502\n \u2502 \u2502 \u2502 pcre2                   \u2506                 \u2506 10.47       \u2506 h30297fc_0          \u2506 conda-forge \u2506  830.30 KiB \u2502\n \u2502 \u2502 \u2502 sdkroot_env_osx-arm64   \u2506                 \u2506 14.5        \u2506 hfa17104_3          \u2506 conda-forge \u2506    8.58 KiB \u2502\n \u2502 \u2502 \u2502 sigtool                 \u2506                 \u2506 0.1.3       \u2506 h44b9a77_0          \u2506 conda-forge \u2506  205.34 KiB \u2502\n \u2502 \u2502 \u2502 tapi                    \u2506                 \u2506 1600.0.11.8 \u2506 h997e182_0          \u2506 conda-forge \u2506  195.02 KiB \u2502\n \u2502 \u2502 \u2502 zstd                    \u2506                 \u2506 1.5.7       \u2506 hd0aec43_5          \u2506 conda-forge \u2506  380.61 KiB \u2502\n \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n \u2502 \u2502 \n \u2502 \u2502 Host dependencies:\n \u2502 \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502 \u2502 \u2502 Package \u2506 Spec \u2506 Version \u2506 Build      \u2506 Channel     \u2506      Size \u2502\n \u2502 \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 \u2502 \u2502 zlib    \u2506 zlib \u2506 1.3.1   \u2506 h8359307_2 \u2506 conda-forge \u2506 75.79 KiB \u2502\n \u2502 \u2502 \u2502 libzlib \u2506      \u2506 1.3.1   \u2506 h8359307_2 \u2506 conda-forge \u2506 45.35 KiB \u2502\n \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n \u2502 \u2502 \n \u2502 \u2502 Run dependencies:\n \u2502 \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502 \u2502 \u2502 Name             \u2506 Spec                                \u2502\n \u2502 \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 \u2502 \u2502 Run dependencies \u2506                                     \u2502\n \u2502 \u2502 \u2502 libzlib          \u2506 &gt;=1.3.1,&lt;2.0a0 (RE of [host: zlib]) \u2502\n \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n \u2502 \u2502 \n \u2502 \u2502 Artifact: /Users/wolfv/Programs/rattler-build/output/osx-arm64/curl-8.0.1-h60d57d3_0.conda (376.73 KiB)\n \u2502 \u2502\n \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (took 0 seconds)\n \u2502\n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (took 0 seconds)\n</code></pre>"},{"location":"variants/","title":"Variant configuration","text":"<p><code>rattler-build</code> can automatically build multiple variants of a given package. For example, a Python package might need multiple variants per Python version (especially if it is a binary package such as <code>numpy</code>).</p> <p>For this use case, one can specify variant configuration files. A variant configuration file has 2 special entries and a list of packages with variants. For example:</p> variants.yaml<pre><code># special entry #1, the zip keys\nzip_keys:\n- [python, numpy]\n\n# special entry #2, the pin_run_as_build key\npin_run_as_build:\n  numpy:\n    max_pin: 'x.x'\n\n# entries per package version that users are interested in\npython:\n# Note that versions are _strings_ (not numbers)\n- \"3.8\"\n- \"3.9\"\n- \"3.10\"\n\nnumpy:\n- \"1.12\"\n- \"1.12\"\n- \"1.20\"\n</code></pre> <p>If we have a recipe that has a <code>build</code> or <code>host</code> dependency on <code>python</code>, we will build multiple variants of this package, one for each configured <code>python</code> version (\"3.8\", \"3.9\" and \"3.10\").</p> <p>For example:</p> <pre><code># ...\nrequirements:\n  host:\n  - python\n</code></pre> <p>... will be rendered as (for the first variant):</p> <pre><code># ...\nrequirements:\n  host:\n- python 3.8*\n</code></pre> <p>Note that variants are only applied if the requirement doesn't specify any constraints. If the requirement would be <code>python &gt;3.8,&lt;3.10</code> then the variant entry would be ignored.</p>"},{"location":"variants/#automatic-discovery","title":"Automatic Discovery","text":"<p><code>rattler-build</code> automatically discovers and includes variant configurations from either:</p> <ul> <li><code>variants.yaml</code> file located next to the recipe</li> <li><code>conda_build_config.yaml</code> file located next to the recipe</li> </ul> <p>To disable automatic discovery, use the <code>--ignore-recipe-variants</code> flag. If you pass variant configuration files explicitly using <code>--variant-config / -m &lt;file&gt;</code>, the passed variants are loaded with higher priority.</p>"},{"location":"variants/#custom-configuration-files","title":"Custom Configuration Files","text":"<p>To specify variant configurations from other locations or include multiple files, use the <code>--variant-config</code> or <code>-m</code> option:</p> <pre><code>rattler-build build --variant-config ~/user_variants.yaml --variant-config /opt/rattler-build/global_variants.yaml --recipe myrecipe.yaml\n</code></pre>"},{"location":"variants/#merging-of-multiple-variant-configuration-files","title":"Merging of multiple variant configuration files","text":"<p>When multiple variant configuration files are merged, the following rules apply:</p> <ul> <li>A key from a higher priority file will completely override a key from a lower priority file.</li> <li>Zip key lengths must still match.</li> </ul>"},{"location":"variants/#conda-build-compatibility","title":"<code>conda-build</code> Compatibility","text":"<p>Since version 0.35.0, rattler-build supports <code>conda_build_config.yaml</code> files, parsing a subset of conda-build's configuration syntax. The filename must match exactly to be recognized as a conda-build config file.</p>"},{"location":"variants/#overriding-the-variant-configuration-from-the-command-line","title":"Overriding the variant configuration from the command line","text":"<p>You can override the chosen variant configuration by passing in the variant you want from the CLI:</p> <pre><code>rattler-build build --recipe ./my-recipe --variant python=3.12 --variant numpy=\"2.*\"\n</code></pre> <p>To build against multiple Python versions you can separate the variant strings by <code>,</code>, e.g. <code>--variant python=3.12,3.13</code>.</p> <p>This will follow the same logic as using multiple variant files: the CLI will overwrite any variant keys set by files that were loaded.</p>"},{"location":"variants/#package-hash-from-variant","title":"Package hash from variant","text":"<p>You might have wondered what the role of the build string is. The build string is (if not explicitly set) computed from the variant configuration. It serves as a mechanism to discern different build configurations that produce a package with the same name and version.</p> <p>The hash is computed by dumping all the variant configuration values that are used by a given recipe into a JSON file, and then hashing that JSON file.</p> <p>For example, in our <code>python</code> example, we would get a variant configuration file that looks something like:</p> <pre><code>{\n    \"python\": \"3.8\"\n}\n</code></pre> <p>This JSON string is then hashed with the MD5 hash algorithm, and produces the hash. For certain packages (such as Python packages) special rules exists, and the <code>py&lt;Major.Minor&gt;</code> version is prepended to the hash, so that the final hash would look something like <code>py38h123123</code>.</p>"},{"location":"variants/#zip-keys","title":"Zip keys","text":"<p>Zip keys modify how variants are combined. Usually, each variant key that has multiple entries is expanded to a build matrix. For example, if we have:</p> <pre><code>python: [\"3.8\", \"3.9\"]\nnumpy: [\"1.12\", \"1.14\"]\n</code></pre> <p>...then we obtain 4 variants for a recipe that uses both <code>numpy</code> and <code>python</code>:</p> <pre><code>- python 3.8, numpy 1.12\n- python 3.8, numpy 1.14\n- python 3.9, numpy 1.12\n- python 3.9, numpy 1.14\n</code></pre> <p>However, if we use the <code>zip_keys</code> and specify:</p> <pre><code>zip_keys: [[\"python\", \"numpy\"]]\npython: [\"3.8\", \"3.9\"]\nnumpy: [\"1.12\", \"1.14\"]\n</code></pre> <p>...then the versions are \"zipped up\" and we only get 2 variants. Note that both <code>python</code> and <code>numpy</code> need to specify the exact same number of versions to make this work.</p> <p>The resulting variants with the zip applied are:</p> <pre><code>- python 3.8, numpy 1.12\n- python 3.9, numpy 1.14\n</code></pre>"},{"location":"variants/#pin-run-as-build","title":"Pin run as build","text":"<p>The <code>pin_run_as_build</code> key allows the user to inject additional pins. Usually, the <code>run_exports</code> mechanism is used to specify constraints for runtime dependencies from build time dependencies, but <code>pin_run_as_build</code> offers a mechanism to override that if the package does not contain a run exports file.</p> <p>For example:</p> <pre><code>pin_run_as_build:\n  libcurl:\n    min_pin: 'x'\n    max_pin: 'x'\n</code></pre> <p>If we now have a recipe that uses <code>libcurl</code> in the <code>host</code> and <code>run</code> dependencies like:</p> <pre><code>requirements:\n  host:\n  - libcurl\n  run:\n  - libcurl\n</code></pre> <p>During resolution, <code>libcurl</code> might be evaluated to <code>libcurl 8.0.1 h13284</code>. Our new runtime dependency then looks like:</p> <pre><code>requirements:\n  host:\n  - libcurl 8.0.1 h13284\n  run:\n  - libcurl &gt;=8,&lt;9\n</code></pre>"},{"location":"variants/#channel-sources","title":"Channel sources","text":"<p>You can specify the channels when building by adjusting <code>channel_sources</code> in your variant file:</p> <pre><code>channel_sources: conda-forge/label/rust_dev,conda-forge\n</code></pre>"},{"location":"variants/#prioritizing-variants","title":"Prioritizing variants","text":"<p>You might produce multiple variants for a package, but want to define a priority for a given variant. The variant with the highest priority would be the default package that is selected by the resolver.</p> <p>There are two mechanisms to make this possible: <code>mutex</code> packages and the <code>down_prioritize_variant</code> option in the recipe.</p>"},{"location":"variants/#the-down_prioritize_variant-option","title":"The <code>down_prioritize_variant</code> option","text":"<p>Note</p> <p>It is not always necessary to use the <code>down_prioritize_variant</code> option - only if the solver has no other way to prefer a given variant. For example, if you have a package that has multiple variants for different Python versions, the solver will automatically prefer the variant with the highest Python version.</p> <p>The <code>down_prioritize_variant</code> option allows you to specify a variant that should be down-prioritized. For example:</p> recipe.yaml<pre><code>build:\n  variant:\n    use_keys:\n      # use cuda from the variant config, e.g. to build multiple CUDA variants\n      - cuda\n    # this will down-prioritize the cuda variant versus other variants of the package\n    down_prioritize_variant: ${{ 1 if cuda else 0 }}\n</code></pre> Example: CUDA / CPU variant with automatic fallback <p>A common pattern is to build both GPU and CPU variants, where the solver picks the GPU variant when CUDA is available and falls back to CPU otherwise. The <code>__cuda</code> virtual package in <code>run</code> requirements is the key \u2014 it makes the GPU package uninstallable on non-CUDA systems.</p> recipe.yaml<pre><code>context:\n  # ...\n  cuda_version: ${{ env.get(\"CONDA_OVERRIDE_CUDA\", default=\"None\") }}\n  cuda: ${{ \"enabled\" if cuda_version != \"None\" else \"disabled\" }}\n\nbuild:\n  # ...\n  variant:\n    use_keys:\n      - ${{ \"cuda\" if cuda == \"enabled\" }}\n    # deprioritize the CPU variant so the solver prefers GPU when available\n    down_prioritize_variant: ${{ 0 if cuda == \"enabled\" else 1 }}\n\nrequirements:\n  build:\n    # ...\n    - if: cuda == \"enabled\"\n      then: ${{ compiler('cuda') }}\n  host:\n    # ...\n    - if: cuda == \"enabled\"\n      then:\n        - cuda-version ==${{ cuda_version }}\n        # ... other CUDA host dependencies\n  run:\n    - if: cuda == \"enabled\"\n      then:\n        - __cuda  # ensures this variant is only installed in CUDA environments\n</code></pre>"},{"location":"variants/#mutex-packages","title":"Mutex packages","text":"<p>Another way to make sure the right variants are selected are \"mutex\" packages. A mutex package is a package that is mutually exclusive. We use the fact that only one package of a given name can be installed at a time (the solver has to choose).</p> <p>A mutex package might be useful to make sure that all packages that depend on BLAS are compiled against the same BLAS implementation. The mutex package will serve the purpose that \"<code>openblas</code>\" and \"<code>mkl</code>\" can never be installed at the same time.</p> <p>We could define a BLAS mutex package like this:</p> variant_config.yaml<pre><code>blas_variant:\n  - \"openblas\"\n  - \"mkl\"\n</code></pre> <p>And then the <code>recipe.yaml</code> for the <code>mutex</code> package could look like this:</p> recipe.yaml<pre><code>package:\n  name: blas_mutex\n  version: 1.0\n\nbuild:\n  string: ${{ blas_variant }}${{ hash }}_${{ build_number }}\n  variant:\n    # make sure that `openblas` is preferred over `mkl`\n    down_prioritize_variant: ${{ 1 if blas_variant == \"mkl\" else 0 }}\n</code></pre> <p>This will create two package: <code>blas_mutex-1.0-openblas</code> and <code>blas_mutex-1.0-mkl</code>. Only one of these packages can be installed at a time because they share the same name. The solver will then only select one of these two packages.</p> <p>The <code>blas</code> package in turn should have a <code>run_export</code> for the <code>blas_mutex</code> package, so that any package that links against <code>blas</code> also has a dependency on the correct <code>blas_mutex</code> package:</p> recipe.yaml<pre><code>package:\n  name: openblas\n  version: 1.0\n\nrequirements:\n  # any package depending on openblas should also depend on the correct blas_mutex package\n  run_export:\n    # Add a run export on _any_ version of the blas_mutex package whose build string starts with \"openblas\"\n    - blas_mutex * openblas*\n</code></pre> <p>Then the recipe of a package that wants to build two variants, one for <code>openblas</code> and one for <code>mkl</code> could look like this:</p> recipe.yaml<pre><code>package:\n  name: fastnumerics\n  version: 1.0\n\nrequirements:\n  host:\n    # build against both openblas and mkl\n    - ${{ blas_variant }}\n  run:\n    # implicitly adds the correct blas_mutex package through run exports\n    # - blas_mutex * ${{ blas_variant }}*\n</code></pre>"},{"location":"windows_quirks/","title":"Windows quirks","text":"<p>Building packages on Windows is different from Unix systems (Linux and macOS). There are a few historical quirks, as well as the fact that the MSVC compiler is not redistributable and has to be installed manually on the host system.</p>"},{"location":"windows_quirks/#the-filesystem-layout-on-windows","title":"The filesystem layout on Windows","text":"<p>The Windows filesystem layout is a bit different than the standard Unix one. This means where Unix recipes use <code>$PREFIX</code>, Windows should usually use <code>%LIBRARY_PREFIX%</code> which points to <code>%PREFIX%\\Library\\</code> instead of just <code>%PREFIX%</code>.</p> <p>Note: this is handled automatically when using conda-forge packages for CMake, Meson by using <code>%CMAKE_ARGS%</code> or <code>%MESON_ARGS%</code> which include the correct values for the installation prefix.</p> <p>On the top level, there is an additional <code>Scripts</code> folder, as well as a <code>bin/</code> folder. On Windows (unlike Unix systems), a total of 5 paths are added upon activation:</p> <pre><code>%PREFIX%\n%PREFIX%\\Library\\mingw-w64\\bin\n%PREFIX%\\Library\\usr\\bin\n%PREFIX%\\Library\\bin\n%PREFIX%\\Scripts\n%PREFIX%\\bin\n</code></pre> <p>Additionally, the site-packages folder is also located at the root of the filesystem layout:</p> <pre><code>%PREFIX%\n\u251c\u2500\u2500 Library\n\u2502   \u251c\u2500\u2500 lib\n\u2502   \u251c\u2500\u2500 bin\n\u2502   \u251c\u2500\u2500 share\n\u2502   \u251c\u2500\u2500 etc\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 site-packages\n\u251c\u2500\u2500 Scripts\n\u2514\u2500\u2500 bin\n</code></pre> <p>The reasons for this layout are historical: Python on Windows traditionally installs packages to <code>site-packages</code> at the root, and <code>Scripts</code> is where Python console scripts and entry points are placed. The <code>Library</code> folder mimics a Unix-style hierarchy for non-Python packages.</p> <p>To make this easier, certain shortcut env vars are available on Windows: <code>%LIBRARY_PREFIX%</code>, <code>%LIBRARY_BIN%</code>, <code>%LIBRARY_INC%</code> (for <code>Library\\include</code>), and <code>%LIBRARY_LIB%</code>.</p>"},{"location":"windows_quirks/#build-scripts","title":"Build scripts","text":""},{"location":"windows_quirks/#cmdexe","title":"Cmd.exe","text":"<p>The default interpreter for build scripts on Windows is <code>cmd.exe</code> which has a quite clunky syntax and execution model.</p> <p>It will, for example, skip over errors if you do not manually insert <code>if %ERRORLEVEL% neq 0 exit 1</code> after each statement. If the build script is a list of commands, then rattler-build will automatically inject this after each list item. If you pass in a complete build script or file, you will have to do this manually to recognize issues in command execution early on.</p>"},{"location":"windows_quirks/#using-powershell","title":"Using Powershell","text":"<p>You can select PowerShell as an interpreter, which comes pre-installed on Windows these days. To do so, just set</p> recipe.yaml<pre><code>build:\n  script:\n    interpreter: powershell\n    script: ...\n</code></pre> <p>Or save your build script as <code>build.ps1</code> (which will automatically use powershell based on the file ending), rattler-build will choose it automatically on Windows if <code>build.bat</code> is absent.</p> <p>rattler-build relies on <code>$PSNativeCommandUseErrorActionPreference</code>, which is only available in PowerShell 7.4+. If your PowerShell is not new enough, it will skip over errors from native command and you have to check <code>$?</code> or <code>$LASTEXITCODE</code> manually like in <code>cmd.exe</code>.</p> <p>rattler-build also creates normal variable copies of environment variables, you can use them if you feel <code>Env:</code> prefix is tedious, so you can write</p> build.ps1<pre><code>cmake -S . B build -DCMAKE_INSTALL_PREFIX=$LIBRARY_PREFIX # same as $Env:LIBRARY_PREFIX\n</code></pre> <p>All these variables are strings, because rattler-build just copies them, so variables with value <code>'True'</code> will not be <code>$true</code> in current implementation.</p>"},{"location":"windows_quirks/#using-bash-on-windows","title":"Using <code>Bash</code> on Windows","text":"<p>To use bash on Windows, you can install bash in your build requirements (e.g. on conda-forge it would be <code>m2-bash</code>) and call the bash script from a cmd.exe script:</p> build.bat<pre><code>bash %RECIPE_DIR%/build_win.sh\nif %ERRORLEVEL% neq 0 exit 1\n\n...\n</code></pre> <p>To find more examples of this pattern, try this Github search query.</p>"},{"location":"windows_quirks/#installing-the-correct-msvc-compilers","title":"Installing the correct MSVC compilers","text":"<p>In order to install the correct MSVC compilers, you should get the Community Visual Studio Installer.</p> <p>The <code>C</code> / <code>C++</code> compiler that is installed on the host system needs to match the requirements of the recipe. For example, if the recipe uses <code>vs2022</code>, then you will need <code>Visual Studio Compilers 2022</code> installed on the host system. The same goes for <code>vs2026</code>, <code>vs2017</code>, etc. The installer also allows you to have multiple versions installed simultaneously. The \"activation scripts\" of the package will automatically select the correct version by setting the environment variables properly.</p> <p>You can use the GUI to install the right version of Visual Studio Compilers, or you can use the following commands in Powershell:</p> <pre><code># Install C/C++ build tools with Winget (through community installer)\nwinget install Microsoft.VisualStudio.BuildTools --silent --accept-source-agreements --accept-package-agreements `\n    --override \"--passive --wait --norestart --add Microsoft.VisualStudio.Workload.VCTools --includeRecommended\"\n\n# For VS2019, use --add Microsoft.VisualStudio.ComponentGroup.VC.Tools.142.x86.x64\n# For Windows 11 SDK, --add Microsoft.VisualStudio.Component.Windows11SDK.22621\n</code></pre> <p>You can find more documentation and more identifiers on the Microsoft Visual Studio documentation.</p>"},{"location":"windows_quirks/#mingw64-compiler-stack","title":"MinGW64 compiler stack","text":"<p>Note</p> <p>Everything that follows on this page is specific to <code>conda-forge</code> and choices this distribution made. If you run your own software distribution you might do things differently, or not have certain compilers available.</p> <p>As an alternative to MSVC, conda-forge provides a MinGW-based compiler stack for Windows. This can be useful when porting Unix software that relies on GCC-specific features or when you want to avoid MSVC licensing requirements.</p>"},{"location":"windows_quirks/#using-mingw-compilers-in-recipes","title":"Using MinGW compilers in recipes","text":"<p>To use the MinGW compiler stack, use the following compiler macros in your recipe:</p> <pre><code>requirements:\n  build:\n    - ${{ compiler('m2w64_c') }}      # C compiler (gcc)\n    - ${{ compiler('m2w64_cxx') }}    # C++ compiler (g++)\n    - ${{ compiler('m2w64_fortran') }} # Fortran compiler (gfortran)\n    - ${{ stdlib('m2w64_c') }}        # MinGW C standard library\n</code></pre> <p>These compilers correspond to the <code>gcc</code>, <code>gxx</code>, and <code>gfortran</code> packages from the MSYS2/MinGW-w64 ecosystem.</p>"},{"location":"windows_quirks/#abi-compatibility-warning","title":"ABI compatibility warning","text":"<p>The MinGW C++ and Fortran compilers are not ABI-compatible with the default MSVC stack. This means:</p> <ul> <li>You cannot mix libraries compiled with MinGW and MSVC in the same application</li> <li>Executables built with MinGW may link to MinGW runtime libraries (<code>libgcc</code>, <code>libwinpthread</code>, <code>libgomp</code>)</li> <li>Special care is needed when performing cross-library calls between MinGW and MSVC code</li> </ul>"},{"location":"windows_quirks/#when-to-use-mingw-vs-msvc","title":"When to use MinGW vs MSVC","text":"Use MinGW when... Use MSVC when... Porting Unix/Linux software with GCC-specific code Building native Windows applications The project uses GNU autotools extensively Integrating with other MSVC-compiled libraries You need GCC-specific compiler extensions Maximum compatibility with Windows ecosystem Building Fortran code (simpler than Flang setup) Performance-critical Windows applications Building R packages (requires MingW64)"},{"location":"windows_quirks/#legacy-packages","title":"Legacy packages","text":"<p>Note that the older <code>m2w64-*</code> compiler packages (with the exception of <code>m2w64-sysroot</code>) are obsolete and no longer updated. Use the compiler macros shown above for new recipes.</p>"},{"location":"windows_quirks/#clang-compiler-on-windows","title":"Clang compiler on Windows","text":"<p>Clang can be used as an alternative to both MSVC and MinGW on Windows. The <code>clang</code> compiler package installs two frontends, and conda-forge provides separate activation scripts for each.</p> <p>Note that while Clang replaces the compiler itself, you still need the Windows SDK and MSVC runtime libraries installed on your system. These are provided by Visual Studio or the VS Build Tools installer (see Installing the correct MSVC compilers). Clang uses the Windows SDK headers and links against the MSVC runtime libraries to produce Windows-compatible binaries.</p>"},{"location":"windows_quirks/#clang-vs-clang-cl","title":"clang vs clang-cl","text":"Frontend Argument syntax Use case <code>clang</code> GCC-style arguments Cross-platform builds, porting from Unix <code>clang-cl</code> MSVC-style arguments Drop-in replacement for MSVC's <code>cl.exe</code>"},{"location":"windows_quirks/#using-clang-in-recipes","title":"Using Clang in recipes","text":"<p>To use Clang on Windows (with <code>clang-cl</code> frontend) and other platforms (with standard <code>clang</code> frontend), use:</p> <pre><code>requirements:\n  build:\n    - ${{ compiler('clang') }}    # C compiler\n    - ${{ compiler('clangxx') }}  # C++ compiler\n    - ${{ stdlib('c') }}\n</code></pre>"},{"location":"windows_quirks/#selecting-a-specific-frontend-on-windows","title":"Selecting a specific frontend on Windows","text":"<p>To explicitly select a frontend on Windows, configure your <code>variant_config.yaml</code>:</p> <pre><code># Use clang with GCC argument syntax\nc_compiler:\n  - clang\ncxx_compiler:\n  - clangxx\n\n# Or use clang-cl with MSVC argument syntax\nc_compiler:\n  - clang-cl\ncxx_compiler:\n  - clang-cl\n</code></pre> <p>The <code>clang-cl</code> frontend is particularly useful when:</p> <ul> <li>You want Clang's diagnostics and optimizations but need MSVC ABI compatibility</li> <li>The build system expects MSVC-style compiler flags</li> <li>You're integrating with existing MSVC-compiled libraries</li> </ul>"},{"location":"py-rattler-build/reference/","title":"Reference","text":"<p>Here's the reference documentation for the <code>rattler_build</code> Python bindings API.</p> <p>If you want to learn how to use rattler-build's Python API, check out the Tutorials.</p>"},{"location":"py-rattler-build/reference/#version","title":"Version","text":"<p>Get the version of rattler-build:</p> <pre><code>from rattler_build import rattler_build_version\n\nprint(rattler_build_version())\n</code></pre> <p>Get the version of the rattler-build package</p>"},{"location":"py-rattler-build/reference/#core-api","title":"Core API","text":"<ul> <li>Recipe - Parse and work with conda recipes (<code>Stage0Recipe</code>, <code>Stage1Recipe</code>)</li> <li>Rendering - Render recipes with variants (<code>RenderedVariant</code>, <code>VariantConfig</code>)</li> <li>Package - Inspect packages and run tests (<code>Package</code>, <code>PackageTest</code>)</li> <li>Build Result - Build output information (<code>BuildResult</code>)</li> </ul>"},{"location":"py-rattler-build/reference/#configuration","title":"Configuration","text":"<ul> <li>Configuration - Build and platform settings (<code>ToolConfiguration</code>, <code>PlatformConfig</code>, <code>JinjaConfig</code>, <code>RenderConfig</code>)</li> </ul>"},{"location":"py-rattler-build/reference/#utilities","title":"Utilities","text":"<ul> <li>Upload - Upload packages to various servers</li> <li>Recipe Generation - Generate recipes from PyPI, CRAN, CPAN, LuaRocks</li> <li>Progress - Progress callbacks for monitoring builds</li> </ul>"},{"location":"py-rattler-build/reference/#exceptions","title":"Exceptions","text":"<ul> <li>Exceptions - Error types raised by rattler-build</li> </ul>"},{"location":"py-rattler-build/reference/build_result/","title":"Build Result","text":"<p>Information about a completed package build.</p> <p>You can import <code>BuildResult</code> from <code>rattler_build</code>:</p> <pre><code>from rattler_build import BuildResult\n</code></pre>"},{"location":"py-rattler-build/reference/build_result/#buildresult","title":"<code>BuildResult</code>","text":"<p>Result of a successful package build.</p> <p>Attributes:</p> Name Type Description <code>packages</code> <p>List of paths to built package files (.conda or .tar.bz2)</p> <code>name</code> <p>Package name</p> <code>version</code> <p>Package version</p> <code>build_string</code> <p>Build string (hash and variant identifier)</p> <code>platform</code> <p>Target platform (e.g., \"linux-64\", \"noarch\")</p> <code>variant</code> <p>Dictionary of variant values used for this build</p> <code>build_time</code> <p>Build duration in seconds</p> <code>log</code> <p>Captured build log messages (info level and above)</p> <code>output_dir</code> <p>Directory where the built packages are stored</p>"},{"location":"py-rattler-build/reference/build_result/#rattler_build.BuildResult.packages","title":"packages  <code>instance-attribute</code>","text":"<pre><code>packages = packages\n</code></pre>"},{"location":"py-rattler-build/reference/build_result/#rattler_build.BuildResult.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"py-rattler-build/reference/build_result/#rattler_build.BuildResult.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version = version\n</code></pre>"},{"location":"py-rattler-build/reference/build_result/#rattler_build.BuildResult.build_string","title":"build_string  <code>instance-attribute</code>","text":"<pre><code>build_string = build_string\n</code></pre>"},{"location":"py-rattler-build/reference/build_result/#rattler_build.BuildResult.platform","title":"platform  <code>instance-attribute</code>","text":"<pre><code>platform = platform\n</code></pre>"},{"location":"py-rattler-build/reference/build_result/#rattler_build.BuildResult.variant","title":"variant  <code>instance-attribute</code>","text":"<pre><code>variant = variant\n</code></pre>"},{"location":"py-rattler-build/reference/build_result/#rattler_build.BuildResult.build_time","title":"build_time  <code>instance-attribute</code>","text":"<pre><code>build_time = build_time\n</code></pre>"},{"location":"py-rattler-build/reference/build_result/#rattler_build.BuildResult.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log = log\n</code></pre>"},{"location":"py-rattler-build/reference/configuration/","title":"Configuration","text":"<p>Configuration classes for controlling build behavior and platform settings.</p> <p>You can import the configuration classes from <code>rattler_build</code>:</p> <pre><code>from rattler_build import ToolConfiguration, PlatformConfig, JinjaConfig, RenderConfig\n</code></pre>"},{"location":"py-rattler-build/reference/configuration/#toolconfiguration","title":"<code>ToolConfiguration</code>","text":"<p>Configuration for the rattler-build tool.</p> <p>Parameters:</p> Name Type Description Default <code>keep_build</code> <code>bool</code> <p>Whether to keep the build directory after the build is done</p> <code>False</code> <code>compression_threads</code> <code>int | None</code> <p>Number of threads to use for compression (default: None - auto)</p> <code>None</code> <code>io_concurrency_limit</code> <code>int | None</code> <p>Maximum number of concurrent I/O operations (default: None)</p> <code>None</code> <code>test_strategy</code> <code>Literal['skip', 'native', 'tests']</code> <p>Test strategy to use (\"skip\", \"native\", or \"tests\") (default: \"skip\")</p> <code>'skip'</code> <code>skip_existing</code> <code>Literal['none', 'local', 'all']</code> <p>Whether to skip packages that already exist (\"none\", \"local\", or \"all\") (default: \"none\")</p> <code>'none'</code> <code>continue_on_failure</code> <code>bool</code> <p>Whether to continue building other recipes even if one fails (default: False)</p> <code>False</code> <code>noarch_build_platform</code> <code>str | None</code> <p>Platform to use for noarch builds (default: None)</p> <code>None</code> <code>channel_priority</code> <code>Literal['strict', 'disabled']</code> <p>Channel priority for solving (\"strict\" or \"disabled\") (default: \"strict\")</p> <code>'strict'</code> <code>allow_insecure_host</code> <code>list[str] | None</code> <p>List of hosts for which SSL certificate verification should be skipped</p> <code>None</code> <code>error_prefix_in_binary</code> <code>bool</code> <p>Whether to error if the host prefix is detected in binary files (default: False)</p> <code>False</code> <code>allow_symlinks_on_windows</code> <code>bool</code> <p>Whether to allow symlinks in packages on Windows (default: False)</p> <code>False</code> <code>use_zstd</code> <code>bool</code> <p>Whether to use zstd compression when downloading repodata (default: True)</p> <code>True</code> <code>use_bz2</code> <code>bool</code> <p>Whether to use bzip2 compression when downloading repodata (default: True)</p> <code>True</code> <code>use_sharded</code> <code>bool</code> <p>Whether to use sharded repodata when downloading (default: True)</p> <code>True</code> Example <pre><code>config = ToolConfiguration(\n    keep_build=True,\n    test_strategy=\"native\",\n    compression_threads=4\n)\nprint(config.keep_build)\n# True\nprint(config.test_strategy)\n# Native\n</code></pre>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.keep_build","title":"keep_build  <code>property</code>","text":"<pre><code>keep_build\n</code></pre> <p>Whether to keep the build directory after the build is done.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.test_strategy","title":"test_strategy  <code>property</code>","text":"<pre><code>test_strategy\n</code></pre> <p>The test strategy to use.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.skip_existing","title":"skip_existing  <code>property</code>","text":"<pre><code>skip_existing\n</code></pre> <p>Whether to skip existing packages.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.continue_on_failure","title":"continue_on_failure  <code>property</code>","text":"<pre><code>continue_on_failure\n</code></pre> <p>Whether to continue building on failure.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.channel_priority","title":"channel_priority  <code>property</code>","text":"<pre><code>channel_priority\n</code></pre> <p>The channel priority to use in solving.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.use_zstd","title":"use_zstd  <code>property</code>","text":"<pre><code>use_zstd\n</code></pre> <p>Whether to use zstd compression.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.use_bz2","title":"use_bz2  <code>property</code>","text":"<pre><code>use_bz2\n</code></pre> <p>Whether to use bzip2 compression.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.use_sharded","title":"use_sharded  <code>property</code>","text":"<pre><code>use_sharded\n</code></pre> <p>Whether to use sharded repodata.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.compression_threads","title":"compression_threads  <code>property</code>","text":"<pre><code>compression_threads\n</code></pre> <p>Number of compression threads.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.io_concurrency_limit","title":"io_concurrency_limit  <code>property</code>","text":"<pre><code>io_concurrency_limit\n</code></pre> <p>IO concurrency limit.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.allow_insecure_host","title":"allow_insecure_host  <code>property</code>","text":"<pre><code>allow_insecure_host\n</code></pre> <p>List of hosts for which SSL certificate verification should be skipped.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.error_prefix_in_binary","title":"error_prefix_in_binary  <code>property</code>","text":"<pre><code>error_prefix_in_binary\n</code></pre> <p>Whether to error if the host prefix is detected in binary files.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.allow_symlinks_on_windows","title":"allow_symlinks_on_windows  <code>property</code>","text":"<pre><code>allow_symlinks_on_windows\n</code></pre> <p>Whether to allow symlinks in packages on Windows.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.ToolConfiguration.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    keep_build=False,\n    compression_threads=None,\n    io_concurrency_limit=None,\n    test_strategy=\"skip\",\n    skip_existing=\"none\",\n    continue_on_failure=False,\n    noarch_build_platform=None,\n    channel_priority=\"strict\",\n    allow_insecure_host=None,\n    error_prefix_in_binary=False,\n    allow_symlinks_on_windows=False,\n    use_zstd=True,\n    use_bz2=True,\n    use_sharded=True,\n)\n</code></pre> <p>Create a new tool configuration.</p>"},{"location":"py-rattler-build/reference/configuration/#platformconfig","title":"<code>PlatformConfig</code>","text":"<p>Platform configuration for building packages.</p> <p>This class provides platform settings that are shared across different configuration objects (JinjaConfig, RenderConfig).</p> <p>Parameters:</p> Name Type Description Default <code>target_platform</code> <code>str | None</code> <p>Target platform (e.g., \"linux-64\", \"osx-arm64\"). If not specified, defaults to the current platform.</p> <code>None</code> <code>build_platform</code> <code>str | None</code> <p>Build platform (where the build runs). If not specified, defaults to the target platform.</p> <code>None</code> <code>host_platform</code> <code>str | None</code> <p>Host platform (for cross-compilation). If not specified, defaults to the target platform.</p> <code>None</code> <code>experimental</code> <code>bool</code> <p>Enable experimental features</p> <code>False</code> Example <pre><code># Create with default (current) platform\nconfig = PlatformConfig()\n\n# Create for a specific platform (build and host will default to target)\nconfig = PlatformConfig(target_platform=\"linux-64\")\n\n# Create with different platforms for cross-compilation\nconfig = PlatformConfig(\n    target_platform=\"osx-arm64\",\n    build_platform=\"linux-64\",\n    host_platform=\"osx-arm64\"\n)\n</code></pre>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.PlatformConfig.target_platform","title":"target_platform  <code>instance-attribute</code>","text":"<pre><code>target_platform = target_platform\n</code></pre>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.PlatformConfig.build_platform","title":"build_platform  <code>instance-attribute</code>","text":"<pre><code>build_platform = (\n    build_platform if build_platform is not None else None\n)\n</code></pre>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.PlatformConfig.host_platform","title":"host_platform  <code>instance-attribute</code>","text":"<pre><code>host_platform = (\n    host_platform if host_platform is not None else None\n)\n</code></pre>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.PlatformConfig.experimental","title":"experimental  <code>instance-attribute</code>","text":"<pre><code>experimental = experimental\n</code></pre>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.PlatformConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    target_platform=None,\n    build_platform=None,\n    host_platform=None,\n    experimental=False,\n)\n</code></pre> <p>Create a new platform configuration.</p>"},{"location":"py-rattler-build/reference/configuration/#jinjaconfig","title":"<code>JinjaConfig</code>","text":"<p>Python wrapper for PyJinjaConfig to provide a cleaner interface.</p> <p>Parameters:</p> Name Type Description Default <code>platform</code> <code>PlatformConfig | None</code> <p>Platform configuration (target, build, host platforms, experimental flag)</p> <code>None</code> <code>allow_undefined</code> <code>bool | None</code> <p>Whether to allow undefined variables in Jinja templates</p> <code>None</code> <code>variant</code> <code>dict[str, Any] | None</code> <p>Variant configuration dictionary</p> <code>None</code> <code>recipe_path</code> <code>str | Path | None</code> <p>Path to the recipe file (for relative path resolution in Jinja functions)</p> <code>None</code> Example <pre><code>from rattler_build.tool_config import PlatformConfig\n\nplatform = PlatformConfig(target_platform=\"linux-64\")\nconfig = JinjaConfig(platform=platform)\n</code></pre>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.JinjaConfig.target_platform","title":"target_platform  <code>property</code>","text":"<pre><code>target_platform\n</code></pre> <p>Get the target platform.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.JinjaConfig.host_platform","title":"host_platform  <code>property</code>","text":"<pre><code>host_platform\n</code></pre> <p>Get the host platform.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.JinjaConfig.build_platform","title":"build_platform  <code>property</code>","text":"<pre><code>build_platform\n</code></pre> <p>Get the build platform.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.JinjaConfig.experimental","title":"experimental  <code>property</code>","text":"<pre><code>experimental\n</code></pre> <p>Get whether experimental features are enabled.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.JinjaConfig.allow_undefined","title":"allow_undefined  <code>property</code>","text":"<pre><code>allow_undefined\n</code></pre> <p>Get whether undefined variables are allowed.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.JinjaConfig.variant","title":"variant  <code>property</code>","text":"<pre><code>variant\n</code></pre> <p>Get the variant configuration.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.JinjaConfig.recipe_path","title":"recipe_path  <code>property</code>","text":"<pre><code>recipe_path\n</code></pre> <p>Get the recipe path.</p>"},{"location":"py-rattler-build/reference/configuration/#rattler_build.JinjaConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    platform=None,\n    allow_undefined=None,\n    variant=None,\n    recipe_path=None,\n)\n</code></pre>"},{"location":"py-rattler-build/reference/exceptions/","title":"Exceptions","text":"<p>Exception classes raised by rattler-build operations.</p> <p>All exceptions inherit from <code>RattlerBuildError</code>, so you can catch all rattler-build errors with a single except clause:</p> <pre><code>from rattler_build import RattlerBuildError, RecipeParseError, Stage0Recipe\n\ntry:\n    recipe = Stage0Recipe.from_yaml(invalid_yaml)\nexcept RecipeParseError as e:\n    print(f\"Invalid recipe: {e}\")\nexcept RattlerBuildError as e:\n    print(f\"rattler-build error: {e}\")\n</code></pre> <p>You can import all exceptions from <code>rattler_build</code>:</p> <pre><code>from rattler_build import (\n    RattlerBuildError,\n    AuthError,\n    ChannelError,\n    ChannelPriorityError,\n    IoError,\n    JsonError,\n    PackageFormatError,\n    PlatformParseError,\n    RecipeParseError,\n    UploadError,\n    UrlParseError,\n    VariantError,\n)\n</code></pre>"},{"location":"py-rattler-build/reference/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>All exceptions inherit from <code>RattlerBuildError</code>:</p> <pre><code>RattlerBuildError (base)\n\u251c\u2500\u2500 AuthError\n\u251c\u2500\u2500 ChannelError\n\u251c\u2500\u2500 ChannelPriorityError\n\u251c\u2500\u2500 IoError\n\u251c\u2500\u2500 JsonError\n\u251c\u2500\u2500 PackageFormatError\n\u251c\u2500\u2500 PlatformParseError\n\u251c\u2500\u2500 RecipeParseError\n\u251c\u2500\u2500 UploadError\n\u251c\u2500\u2500 UrlParseError\n\u2514\u2500\u2500 VariantError\n</code></pre>"},{"location":"py-rattler-build/reference/exceptions/#rattlerbuilderror","title":"<code>RattlerBuildError</code>","text":"<p>Base exception for all rattler-build errors. Catch this to handle any error from the library.</p>"},{"location":"py-rattler-build/reference/exceptions/#autherror","title":"<code>AuthError</code>","text":"<p>Raised when authentication fails, such as when credentials are missing or invalid.</p>"},{"location":"py-rattler-build/reference/exceptions/#channelerror","title":"<code>ChannelError</code>","text":"<p>Raised when there's an issue with a conda channel, such as a channel that can't be accessed.</p>"},{"location":"py-rattler-build/reference/exceptions/#channelpriorityerror","title":"<code>ChannelPriorityError</code>","text":"<p>Raised when channel priority configuration is invalid.</p>"},{"location":"py-rattler-build/reference/exceptions/#ioerror","title":"<code>IoError</code>","text":"<p>Raised for I/O operation failures, such as file read/write errors.</p>"},{"location":"py-rattler-build/reference/exceptions/#jsonerror","title":"<code>JsonError</code>","text":"<p>Raised when JSON parsing or serialization fails.</p>"},{"location":"py-rattler-build/reference/exceptions/#packageformaterror","title":"<code>PackageFormatError</code>","text":"<p>Raised when a package file format is invalid or corrupted.</p>"},{"location":"py-rattler-build/reference/exceptions/#platformparseerror","title":"<code>PlatformParseError</code>","text":"<p>Raised when a platform string (e.g., \"linux-64\", \"osx-arm64\") cannot be parsed.</p>"},{"location":"py-rattler-build/reference/exceptions/#recipeparseerror","title":"<code>RecipeParseError</code>","text":"<p>Raised when a recipe cannot be parsed. This includes YAML syntax errors and schema validation failures.</p>"},{"location":"py-rattler-build/reference/exceptions/#uploaderror","title":"<code>UploadError</code>","text":"<p>Raised when uploading a package to a server fails.</p>"},{"location":"py-rattler-build/reference/exceptions/#urlparseerror","title":"<code>UrlParseError</code>","text":"<p>Raised when a URL cannot be parsed.</p>"},{"location":"py-rattler-build/reference/exceptions/#varianterror","title":"<code>VariantError</code>","text":"<p>Raised when variant configuration is invalid, such as mismatched zip_keys lengths.</p>"},{"location":"py-rattler-build/reference/package/","title":"Package","text":"<p>Load, inspect, and test conda packages.</p> <p>You can import the package classes from <code>rattler_build</code>:</p> <pre><code>from rattler_build import Package, PythonTest, CommandsTest, PackageContentsTest, TestResult\n</code></pre> <p>The <code>tests</code> property returns a list of test objects that can be pattern matched (Python 3.10+):</p> <pre><code>for test in pkg.tests:\n    match test:\n        case PythonTest() as py_test:\n            print(f\"Python imports: {py_test.imports}\")\n        case CommandsTest() as cmd_test:\n            print(f\"Commands: {cmd_test.script}\")\n        case PackageContentsTest() as pc_test:\n            print(f\"Package contents check, strict={pc_test.strict}\")\n</code></pre>"},{"location":"py-rattler-build/reference/package/#package_1","title":"<code>Package</code>","text":"<p>A loaded conda package for inspection and testing.</p> <p>This class provides access to package metadata, file contents, and embedded tests. The package is lazily extracted when needed (e.g., when accessing files or tests).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Package name (e.g., \"numpy\")</p> <code>version</code> <code>str</code> <p>Package version (e.g., \"1.26.0\")</p> <code>build_string</code> <code>str</code> <p>Build string (e.g., \"py312_0\")</p> <code>build_number</code> <code>int</code> <p>Build number</p> <code>subdir</code> <code>str | None</code> <p>Target platform subdirectory (e.g., \"linux-64\", \"noarch\")</p> <code>noarch</code> <code>str | None</code> <p>NoArch type (None, \"python\", or \"generic\")</p> <code>depends</code> <code>list[str]</code> <p>List of runtime dependencies</p> <code>constrains</code> <code>list[str]</code> <p>List of dependency constraints</p> <code>license</code> <code>str | None</code> <p>Package license</p> <code>license_family</code> <code>str | None</code> <p>License family</p> <code>timestamp</code> <code>datetime | None</code> <p>Build timestamp as a datetime object</p> <code>arch</code> <code>str | None</code> <p>Architecture (e.g., \"x86_64\")</p> <code>platform</code> <code>str | None</code> <p>Platform (e.g., \"linux\")</p> <code>path</code> <code>Path</code> <p>Path to the package file</p> <code>archive_type</code> <code>str</code> <p>Archive format (\"conda\" or \"tar.bz2\")</p> <code>filename</code> <code>str</code> <p>Filename of the package</p> <code>files</code> <code>list[str]</code> <p>List of all files in the package</p> <code>tests</code> <code>list[PackageTestType]</code> <p>List of tests embedded in the package</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Package name.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.version","title":"version  <code>property</code>","text":"<pre><code>version\n</code></pre> <p>Package version.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.build_string","title":"build_string  <code>property</code>","text":"<pre><code>build_string\n</code></pre> <p>Build string (e.g., \"py312_0\").</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.build_number","title":"build_number  <code>property</code>","text":"<pre><code>build_number\n</code></pre> <p>Build number.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.subdir","title":"subdir  <code>property</code>","text":"<pre><code>subdir\n</code></pre> <p>Target platform subdirectory (e.g., \"linux-64\", \"noarch\").</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.noarch","title":"noarch  <code>property</code>","text":"<pre><code>noarch\n</code></pre> <p>NoArch type (None, \"python\", or \"generic\").</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.depends","title":"depends  <code>property</code>","text":"<pre><code>depends\n</code></pre> <p>List of runtime dependencies.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.constrains","title":"constrains  <code>property</code>","text":"<pre><code>constrains\n</code></pre> <p>List of dependency constraints.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.license","title":"license  <code>property</code>","text":"<pre><code>license\n</code></pre> <p>Package license.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.license_family","title":"license_family  <code>property</code>","text":"<pre><code>license_family\n</code></pre> <p>License family.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Build timestamp as a datetime object (UTC timezone-aware).</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.arch","title":"arch  <code>property</code>","text":"<pre><code>arch\n</code></pre> <p>Architecture (e.g., \"x86_64\").</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.platform","title":"platform  <code>property</code>","text":"<pre><code>platform\n</code></pre> <p>Platform (e.g., \"linux\").</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre> <p>Path to the package file.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.archive_type","title":"archive_type  <code>property</code>","text":"<pre><code>archive_type\n</code></pre> <p>Archive format (\"conda\" or \"tar.bz2\").</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.filename","title":"filename  <code>property</code>","text":"<pre><code>filename\n</code></pre> <p>Filename of the package (e.g., \"numpy-1.26.0-py312_0.conda\").</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.files","title":"files  <code>property</code>","text":"<pre><code>files\n</code></pre> <p>List of all files in the package.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.tests","title":"tests  <code>property</code>","text":"<pre><code>tests\n</code></pre> <p>List of tests embedded in the package.</p> <p>Returns a list of test objects that can be pattern matched:</p> <pre><code>for test in pkg.tests:\n    match test:\n        case PythonTest() as py_test:\n            print(f\"imports: {py_test.imports}\")\n        case CommandsTest() as cmd_test:\n            print(f\"script: {cmd_test.script}\")\n        case PackageContentsTest() as pc_test:\n            print(f\"strict: {pc_test.strict}\")\n</code></pre>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.test_count","title":"test_count  <code>property</code>","text":"<pre><code>test_count\n</code></pre> <p>Get the number of tests in the package.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(path)\n</code></pre> <p>Load a package from a .conda or .tar.bz2 file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the package file</p> required <p>Returns:</p> Type Description <code>Package</code> <p>A Package object for inspection and testing</p> <p>Raises:</p> Type Description <code>RattlerBuildError</code> <p>If the package cannot be loaded or parsed</p> Example <pre><code>pkg = Package.from_file(\"numpy-1.26.0-py312_0.conda\")\nprint(pkg.name)\n# numpy\n</code></pre>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.run_test","title":"run_test","text":"<pre><code>run_test(\n    index,\n    *,\n    channel=None,\n    channel_priority=None,\n    debug=False,\n    auth_file=None,\n    allow_insecure_host=None,\n    compression_threads=None,\n    use_bz2=True,\n    use_zstd=True,\n    use_sharded=True,\n)\n</code></pre> <p>Run a specific test by index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the test to run (0-based)</p> required <code>channel</code> <code>Sequence[str] | None</code> <p>List of channels to use for dependencies</p> <code>None</code> <code>channel_priority</code> <code>Literal['disabled', 'strict', 'flexible'] | None</code> <p>Channel priority (\"disabled\", \"strict\", or \"flexible\")</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug mode (keeps test environment)</p> <code>False</code> <code>auth_file</code> <code>str | Path | None</code> <p>Path to authentication file</p> <code>None</code> <code>allow_insecure_host</code> <code>Sequence[str] | None</code> <p>List of hosts to allow insecure connections</p> <code>None</code> <code>compression_threads</code> <code>int | None</code> <p>Number of compression threads</p> <code>None</code> <code>use_bz2</code> <code>bool</code> <p>Enable bz2 repodata</p> <code>True</code> <code>use_zstd</code> <code>bool</code> <p>Enable zstd repodata</p> <code>True</code> <code>use_sharded</code> <code>bool</code> <p>Enable sharded repodata</p> <code>True</code> <p>Returns:</p> Type Description <code>TestResult</code> <p>TestResult with success status and output</p> <p>Raises:</p> Type Description <code>RattlerBuildError</code> <p>If the test index is out of range or test execution fails</p> Example <pre><code>result = pkg.run_test(0, channel=[\"conda-forge\"])\nif result.success:\n    print(\"Test passed!\")\n</code></pre>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.run_tests","title":"run_tests","text":"<pre><code>run_tests(\n    *,\n    channel=None,\n    channel_priority=None,\n    debug=False,\n    auth_file=None,\n    allow_insecure_host=None,\n    compression_threads=None,\n    use_bz2=True,\n    use_zstd=True,\n    use_sharded=True,\n)\n</code></pre> <p>Run all tests in the package.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Sequence[str] | None</code> <p>List of channels to use for dependencies</p> <code>None</code> <code>channel_priority</code> <code>Literal['disabled', 'strict', 'flexible'] | None</code> <p>Channel priority (\"disabled\", \"strict\", or \"flexible\")</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug mode (keeps test environment)</p> <code>False</code> <code>auth_file</code> <code>str | Path | None</code> <p>Path to authentication file</p> <code>None</code> <code>allow_insecure_host</code> <code>Sequence[str] | None</code> <p>List of hosts to allow insecure connections</p> <code>None</code> <code>compression_threads</code> <code>int | None</code> <p>Number of compression threads</p> <code>None</code> <code>use_bz2</code> <code>bool</code> <p>Enable bz2 repodata</p> <code>True</code> <code>use_zstd</code> <code>bool</code> <p>Enable zstd repodata</p> <code>True</code> <code>use_sharded</code> <code>bool</code> <p>Enable sharded repodata</p> <code>True</code> <p>Returns:</p> Type Description <code>list[TestResult]</code> <p>List of TestResult objects, one per test</p> Example <pre><code>results = pkg.run_tests(channel=[\"conda-forge\"])\nfor r in results:\n    status = \"PASS\" if r.success else \"FAIL\"\n    print(f\"Test {r.test_index}: {status}\")\n</code></pre>"},{"location":"py-rattler-build/reference/package/#rattler_build.Package.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert package metadata to a dictionary.</p>"},{"location":"py-rattler-build/reference/package/#testresult","title":"<code>TestResult</code>","text":"<p>Result of running a test.</p> <p>Attributes:</p> Name Type Description <code>success</code> <code>bool</code> <p>Whether the test passed</p> <code>output</code> <code>list[str]</code> <p>Test output/logs</p> <code>test_index</code> <code>int</code> <p>Index of the test that was run</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.TestResult.success","title":"success  <code>property</code>","text":"<pre><code>success\n</code></pre> <p>Whether the test passed.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.TestResult.output","title":"output  <code>property</code>","text":"<pre><code>output\n</code></pre> <p>Test output/logs.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.TestResult.test_index","title":"test_index  <code>property</code>","text":"<pre><code>test_index\n</code></pre> <p>Index of the test that was run.</p>"},{"location":"py-rattler-build/reference/package/#test-types","title":"Test Types","text":""},{"location":"py-rattler-build/reference/package/#pythontest","title":"<code>PythonTest</code>","text":"<p>Python test - imports modules and optionally runs pip check.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of this test in the package's test list</p> <code>imports</code> <code>list[str]</code> <p>List of modules to import</p> <code>pip_check</code> <code>bool</code> <p>Whether to run pip check (default: True)</p> <code>python_version</code> <code>PythonVersion | None</code> <p>Python version specification</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PythonTest.index","title":"index  <code>property</code>","text":"<pre><code>index\n</code></pre> <p>Index of this test in the package's test list.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PythonTest.imports","title":"imports  <code>property</code>","text":"<pre><code>imports\n</code></pre> <p>List of modules to import.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PythonTest.pip_check","title":"pip_check  <code>property</code>","text":"<pre><code>pip_check\n</code></pre> <p>Whether to run pip check (default: True).</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PythonTest.python_version","title":"python_version  <code>property</code>","text":"<pre><code>python_version\n</code></pre> <p>Python version specification.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PythonTest.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a dictionary.</p>"},{"location":"py-rattler-build/reference/package/#pythonversion","title":"<code>PythonVersion</code>","text":"<p>Python version specification for tests.</p> <p>Can be a single version, multiple versions, or unspecified (None).</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PythonVersion.as_single","title":"as_single","text":"<pre><code>as_single()\n</code></pre> <p>Get the version as a single string (if single version).</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PythonVersion.as_multiple","title":"as_multiple","text":"<pre><code>as_multiple()\n</code></pre> <p>Get the versions as a list (if multiple versions).</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PythonVersion.is_none","title":"is_none","text":"<pre><code>is_none()\n</code></pre> <p>Check if no specific version is set.</p>"},{"location":"py-rattler-build/reference/package/#commandstest","title":"<code>CommandsTest</code>","text":"<p>Commands test - runs arbitrary shell commands.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of this test in the package's test list</p> <code>script</code> <code>dict[str, Any]</code> <p>The script content (as dict)</p> <code>requirements_run</code> <code>list[str]</code> <p>Extra runtime requirements for the test</p> <code>requirements_build</code> <code>list[str]</code> <p>Extra build requirements for the test (e.g., emulators)</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.CommandsTest.index","title":"index  <code>property</code>","text":"<pre><code>index\n</code></pre> <p>Index of this test in the package's test list.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.CommandsTest.script","title":"script  <code>property</code>","text":"<pre><code>script\n</code></pre> <p>The script content.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.CommandsTest.requirements_run","title":"requirements_run  <code>property</code>","text":"<pre><code>requirements_run\n</code></pre> <p>Extra runtime requirements for the test.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.CommandsTest.requirements_build","title":"requirements_build  <code>property</code>","text":"<pre><code>requirements_build\n</code></pre> <p>Extra build requirements for the test (e.g., emulators).</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.CommandsTest.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a dictionary.</p>"},{"location":"py-rattler-build/reference/package/#perltest","title":"<code>PerlTest</code>","text":"<p>Perl test - tests Perl modules.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of this test in the package's test list</p> <code>uses</code> <code>list[str]</code> <p>List of Perl modules to load with 'use'</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PerlTest.index","title":"index  <code>property</code>","text":"<pre><code>index\n</code></pre> <p>Index of this test in the package's test list.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PerlTest.uses","title":"uses  <code>property</code>","text":"<pre><code>uses\n</code></pre> <p>List of Perl modules to load with 'use'.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PerlTest.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a dictionary.</p>"},{"location":"py-rattler-build/reference/package/#rtest","title":"<code>RTest</code>","text":"<p>R test - tests R libraries.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of this test in the package's test list</p> <code>libraries</code> <code>list[str]</code> <p>List of R libraries to load with library()</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.RTest.index","title":"index  <code>property</code>","text":"<pre><code>index\n</code></pre> <p>Index of this test in the package's test list.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.RTest.libraries","title":"libraries  <code>property</code>","text":"<pre><code>libraries\n</code></pre> <p>List of R libraries to load with library().</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.RTest.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a dictionary.</p>"},{"location":"py-rattler-build/reference/package/#rubytest","title":"<code>RubyTest</code>","text":"<p>Ruby test - tests Ruby modules.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of this test in the package's test list</p> <code>requires</code> <code>list[str]</code> <p>List of Ruby modules to require</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.RubyTest.index","title":"index  <code>property</code>","text":"<pre><code>index\n</code></pre> <p>Index of this test in the package's test list.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.RubyTest.requires","title":"requires  <code>property</code>","text":"<pre><code>requires\n</code></pre> <p>List of Ruby modules to require.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.RubyTest.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a dictionary.</p>"},{"location":"py-rattler-build/reference/package/#downstreamtest","title":"<code>DownstreamTest</code>","text":"<p>Downstream test - tests a downstream package that depends on this package.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of this test in the package's test list</p> <code>downstream</code> <code>str</code> <p>Name of the downstream package to test</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.DownstreamTest.index","title":"index  <code>property</code>","text":"<pre><code>index\n</code></pre> <p>Index of this test in the package's test list.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.DownstreamTest.downstream","title":"downstream  <code>property</code>","text":"<pre><code>downstream\n</code></pre> <p>Name of the downstream package to test.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.DownstreamTest.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a dictionary.</p>"},{"location":"py-rattler-build/reference/package/#packagecontentstest","title":"<code>PackageContentsTest</code>","text":"<p>Package contents test - checks that files exist or don't exist in the package.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of this test in the package's test list</p> <code>files</code> <code>FileChecks</code> <p>File checks for all files</p> <code>site_packages</code> <code>FileChecks</code> <p>File checks for Python site-packages</p> <code>bin</code> <code>FileChecks</code> <p>File checks for binaries in bin/</p> <code>lib</code> <code>FileChecks</code> <p>File checks for libraries</p> <code>include</code> <code>FileChecks</code> <p>File checks for include headers</p> <code>strict</code> <code>bool</code> <p>Whether to fail on non-matched glob patterns (strict mode)</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PackageContentsTest.index","title":"index  <code>property</code>","text":"<pre><code>index\n</code></pre> <p>Index of this test in the package's test list.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PackageContentsTest.files","title":"files  <code>property</code>","text":"<pre><code>files\n</code></pre> <p>File checks for all files.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PackageContentsTest.site_packages","title":"site_packages  <code>property</code>","text":"<pre><code>site_packages\n</code></pre> <p>File checks for Python site-packages.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PackageContentsTest.bin","title":"bin  <code>property</code>","text":"<pre><code>bin\n</code></pre> <p>File checks for binaries in bin/.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PackageContentsTest.lib","title":"lib  <code>property</code>","text":"<pre><code>lib\n</code></pre> <p>File checks for libraries.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PackageContentsTest.include","title":"include  <code>property</code>","text":"<pre><code>include\n</code></pre> <p>File checks for include headers.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PackageContentsTest.strict","title":"strict  <code>property</code>","text":"<pre><code>strict\n</code></pre> <p>Whether to fail on non-matched glob patterns (strict mode).</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PackageContentsTest.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a dictionary.</p>"},{"location":"py-rattler-build/reference/package/#filechecks","title":"<code>FileChecks</code>","text":"<p>File existence checks (glob patterns).</p> <p>Attributes:</p> Name Type Description <code>exists</code> <code>list[str]</code> <p>Glob patterns that must match at least one file</p> <code>not_exists</code> <code>list[str]</code> <p>Glob patterns that must NOT match any file</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.FileChecks.exists","title":"exists  <code>property</code>","text":"<pre><code>exists\n</code></pre> <p>Glob patterns that must match at least one file.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.FileChecks.not_exists","title":"not_exists  <code>property</code>","text":"<pre><code>not_exists\n</code></pre> <p>Glob patterns that must NOT match any file.</p>"},{"location":"py-rattler-build/reference/package/#pathentry","title":"<code>PathEntry</code>","text":"<p>Path entry from paths.json.</p> <p>Attributes:</p> Name Type Description <code>relative_path</code> <code>str</code> <p>Relative path of the file in the package</p> <code>no_link</code> <code>bool</code> <p>Whether to skip linking this file</p> <code>path_type</code> <code>str</code> <p>Path type (\"hardlink\", \"softlink\", or \"directory\")</p> <code>size_in_bytes</code> <code>int | None</code> <p>Size of the file in bytes (if available)</p> <code>sha256</code> <code>str | None</code> <p>SHA256 hash of the file (if available)</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PathEntry.relative_path","title":"relative_path  <code>property</code>","text":"<pre><code>relative_path\n</code></pre> <p>Relative path of the file in the package.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PathEntry.no_link","title":"no_link  <code>property</code>","text":"<pre><code>no_link\n</code></pre> <p>Whether to skip linking this file.</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PathEntry.path_type","title":"path_type  <code>property</code>","text":"<pre><code>path_type\n</code></pre> <p>Path type: \"hardlink\", \"softlink\", or \"directory\".</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PathEntry.size_in_bytes","title":"size_in_bytes  <code>property</code>","text":"<pre><code>size_in_bytes\n</code></pre> <p>Size of the file in bytes (if available).</p>"},{"location":"py-rattler-build/reference/package/#rattler_build.PathEntry.sha256","title":"sha256  <code>property</code>","text":"<pre><code>sha256\n</code></pre> <p>SHA256 hash of the file (if available).</p>"},{"location":"py-rattler-build/reference/package_assembler/","title":"Package Assembler","text":"<p>Create conda packages programmatically without a recipe file.</p> <p>You can import the package assembler classes and functions from <code>rattler_build</code>:</p> <pre><code>from rattler_build import assemble_package, collect_files, ArchiveType, FileEntry, PackageOutput\n</code></pre>"},{"location":"py-rattler-build/reference/package_assembler/#assemble_package","title":"<code>assemble_package</code>","text":"<p>Create a conda package from files and metadata.</p> <p>This is a low-level function for creating conda packages without a recipe. Use this when you have files staged and want to package them directly.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Package name.</p> required <code>version</code> <code>str</code> <p>Package version.</p> required <code>target_platform</code> <code>str</code> <p>Target platform (e.g., \"linux-64\", \"osx-arm64\", \"noarch\").</p> required <code>build_string</code> <code>str</code> <p>Build string (e.g., \"py312_0\", \"h1234567_0\").</p> required <code>output_dir</code> <code>str | Path</code> <p>Directory where the package will be created.</p> required <code>files_dir</code> <code>str | Path | None</code> <p>Directory containing files to include. All files in this directory will be added to the package.</p> <code>None</code> <code>files</code> <code>Sequence[FileEntry] | None</code> <p>List of FileEntry objects for explicit file mappings. Use this for fine-grained control over which files to include.</p> <code>None</code> <code>homepage</code> <code>str | None</code> <p>Homepage URL for the package.</p> <code>None</code> <code>license</code> <code>str | None</code> <p>License identifier (e.g., \"MIT\", \"Apache-2.0\").</p> <code>None</code> <code>license_family</code> <code>str | None</code> <p>License family (e.g., \"MIT\", \"GPL\").</p> <code>None</code> <code>summary</code> <code>str | None</code> <p>Short one-line summary of the package.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Full description of the package.</p> <code>None</code> <code>depends</code> <code>Sequence[str] | None</code> <p>List of runtime dependencies (e.g., [\"python &gt;=3.8\", \"numpy\"]).</p> <code>None</code> <code>constrains</code> <code>Sequence[str] | None</code> <p>List of version constraints (e.g., [\"cudatoolkit &gt;=11.0\"]).</p> <code>None</code> <code>build_number</code> <code>int</code> <p>Build number (default: 0).</p> <code>0</code> <code>noarch</code> <code>Literal['python', 'generic'] | None</code> <p>Noarch type (\"python\" or \"generic\") or None for arch-specific.</p> <code>None</code> <code>license_files</code> <code>Sequence[str | Path] | None</code> <p>List of paths to license files to include.</p> <code>None</code> <code>test_files</code> <code>Sequence[str | Path] | None</code> <p>List of paths to test files to include.</p> <code>None</code> <code>recipe_dir</code> <code>str | Path | None</code> <p>Path to recipe directory to include in info/recipe/.</p> <code>None</code> <code>compression_level</code> <code>int</code> <p>Compression level 0-9 (default: 9, higher = smaller but slower).</p> <code>9</code> <code>archive_type</code> <code>ArchiveType</code> <p>Archive format (default: ArchiveType.Conda).</p> <code>Conda</code> <code>timestamp</code> <code>datetime | None</code> <p>Build timestamp as a datetime object for reproducible builds.</p> <code>None</code> <code>compression_threads</code> <code>int | None</code> <p>Number of threads for compression (default: auto-detect).</p> <code>None</code> <code>detect_prefix</code> <code>bool</code> <p>Whether to detect and record prefix placeholders (default: True).</p> <code>True</code> <p>Returns:</p> Type Description <code>PackageOutput</code> <p>PackageOutput with path to the created package and identifier.</p> <p>Raises:</p> Type Description <code>RattlerBuildError</code> <p>If package name, version, or platform is invalid, or if the build fails.</p> Example <pre><code>from rattler_build import assemble_package, ArchiveType\n\n# Simple package\noutput = assemble_package(\n    name=\"mypackage\",\n    version=\"1.0.0\",\n    target_platform=\"linux-64\",\n    build_string=\"py312_0\",\n    output_dir=\"/output\",\n    files_dir=\"/staged/files\",\n)\n\n# Package with metadata\noutput = assemble_package(\n    name=\"mypackage\",\n    version=\"1.0.0\",\n    target_platform=\"linux-64\",\n    build_string=\"py312_0\",\n    output_dir=\"/output\",\n    files_dir=\"/staged/files\",\n    homepage=\"https://github.com/org/mypackage\",\n    license=\"MIT\",\n    summary=\"My awesome package\",\n    depends=[\"python &gt;=3.12\", \"numpy\"],\n)\n</code></pre>"},{"location":"py-rattler-build/reference/package_assembler/#collect_files","title":"<code>collect_files</code>","text":"<p>Collect files from a directory using glob patterns.</p> <p>Parameters:</p> Name Type Description Default <code>source_dir</code> <code>str | Path</code> <p>Directory to scan for files.</p> required <code>include_globs</code> <code>Sequence[str] | None</code> <p>Glob patterns to include (e.g., [\"/.py\", \"bin/\"]). If not specified, all files are included by default.</p> <code>None</code> <code>exclude_globs</code> <code>Sequence[str] | None</code> <p>Glob patterns to exclude. Exclusions take precedence over inclusions.</p> <code>None</code> <code>follow_symlinks</code> <code>bool</code> <p>Whether to follow symlinks when traversing (default: False).</p> <code>False</code> <code>include_hidden</code> <code>bool</code> <p>Whether to include hidden files starting with . (default: False).</p> <code>False</code> <p>Returns:</p> Type Description <code>list[FileEntry]</code> <p>List of FileEntry objects for all matched files.</p> Example <pre><code>from rattler_build import collect_files\n\n# Collect all Python files except tests\nfiles = collect_files(\n    \"/path/to/project\",\n    include_globs=[\"**/*.py\"],\n    exclude_globs=[\"**/test_*.py\", \"**/__pycache__/**\"],\n)\n\n# Collect everything including hidden files\nfiles = collect_files(\"/path/to/project\", include_hidden=True)\n</code></pre>"},{"location":"py-rattler-build/reference/package_assembler/#archivetype","title":"<code>ArchiveType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Archive type for conda packages.</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.ArchiveType.TarBz2","title":"TarBz2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TarBz2 = 0\n</code></pre> <p>Legacy .tar.bz2 format.</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.ArchiveType.Conda","title":"Conda  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Conda = 1\n</code></pre> <p>Modern .conda format (default, recommended).</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.ArchiveType.extension","title":"extension","text":"<pre><code>extension()\n</code></pre> <p>Get the file extension for this archive type.</p>"},{"location":"py-rattler-build/reference/package_assembler/#fileentry","title":"<code>FileEntry</code>","text":"<p>Represents a file to be included in the package.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>Path</code> <p>Source path on disk.</p> <code>destination</code> <code>Path</code> <p>Destination path within the package (relative).</p> <code>is_symlink</code> <code>bool</code> <p>Whether this is a symlink.</p> <code>symlink_target</code> <code>Path | None</code> <p>Symlink target (if this is a symlink).</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.FileEntry.source","title":"source  <code>property</code>","text":"<pre><code>source\n</code></pre> <p>Source path on disk.</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.FileEntry.destination","title":"destination  <code>property</code>","text":"<pre><code>destination\n</code></pre> <p>Destination path within the package.</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.FileEntry.is_symlink","title":"is_symlink  <code>property</code>","text":"<pre><code>is_symlink\n</code></pre> <p>Whether this is a symlink.</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.FileEntry.symlink_target","title":"symlink_target  <code>property</code>","text":"<pre><code>symlink_target\n</code></pre> <p>Symlink target (if this is a symlink).</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.FileEntry.from_paths","title":"from_paths  <code>classmethod</code>","text":"<pre><code>from_paths(source, destination)\n</code></pre> <p>Create a FileEntry from source and destination paths.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | Path</code> <p>Source path on disk.</p> required <code>destination</code> <code>str | Path</code> <p>Destination path within the package (relative).</p> required <p>Returns:</p> Type Description <code>FileEntry</code> <p>A new FileEntry instance.</p>"},{"location":"py-rattler-build/reference/package_assembler/#packageoutput","title":"<code>PackageOutput</code>","text":"<p>Result of successful package creation.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path to the created package file.</p> <code>identifier</code> <code>str</code> <p>Package identifier (name-version-build).</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.PackageOutput.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre> <p>Path to the created package file.</p>"},{"location":"py-rattler-build/reference/package_assembler/#rattler_build.PackageOutput.identifier","title":"identifier  <code>property</code>","text":"<pre><code>identifier\n</code></pre> <p>Package identifier (name-version-build).</p>"},{"location":"py-rattler-build/reference/progress/","title":"Progress","text":"<p>Progress callbacks for monitoring build operations.</p> <p>You can implement the <code>ProgressCallback</code> protocol to receive progress updates, or use one of the built-in implementations.</p> <pre><code>from rattler_build.progress import (\n    ProgressCallback,\n    SimpleProgressCallback,\n    RichProgressCallback,\n    create_callback,\n)\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#creating-callbacks","title":"Creating Callbacks","text":""},{"location":"py-rattler-build/reference/progress/#create_callback","title":"<code>create_callback</code>","text":"<p>Create a progress callback of the specified style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>Literal['simple', 'rich'] | None</code> <p>Style of callback - \"simple\", \"rich\", or None for no output</p> <code>'simple'</code> <code>show_logs</code> <code>bool</code> <p>Show logs in rich output (only used with style=\"rich\")</p> <code>True</code> <code>show_details</code> <code>bool</code> <p>Show detailed progress information (only used with style=\"rich\")</p> <code>False</code> <p>Returns:</p> Type Description <code>ProgressCallback</code> <p>A progress callback instance</p> Example <pre><code># Simple console output\ncallback = create_callback(\"simple\")\n\n# Rich terminal output\ncallback = create_callback(\"rich\", show_logs=True)\n\n# Rich with details\ncallback = create_callback(\"rich\", show_logs=True, show_details=True)\n\n# No output\ncallback = create_callback(None)\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#built-in-callbacks","title":"Built-in Callbacks","text":""},{"location":"py-rattler-build/reference/progress/#simpleprogresscallback","title":"<code>SimpleProgressCallback</code>","text":"<p>Simple console-based progress callback.</p> <p>Prints progress updates to the console with simple formatting.</p> Example <pre><code>from rattler_build import Recipe, VariantConfig\nfrom rattler_build.progress import SimpleProgressCallback\n\nrecipe = Recipe.from_file(\"recipe.yaml\")\nrendered = recipe.render(VariantConfig())\n\ncallback = SimpleProgressCallback()\n# Use callback in build (to be implemented)\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.SimpleProgressCallback.on_download_start","title":"on_download_start","text":"<pre><code>on_download_start(event)\n</code></pre> <p>Print download start message.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.SimpleProgressCallback.on_download_progress","title":"on_download_progress","text":"<pre><code>on_download_progress(event)\n</code></pre> <p>Print download progress (only at 25% intervals to avoid spam).</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.SimpleProgressCallback.on_download_complete","title":"on_download_complete","text":"<pre><code>on_download_complete(event)\n</code></pre> <p>Print download complete message.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.SimpleProgressCallback.on_build_step","title":"on_build_step","text":"<pre><code>on_build_step(event)\n</code></pre> <p>Print build step message.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.SimpleProgressCallback.on_log","title":"on_log","text":"<pre><code>on_log(event)\n</code></pre> <p>Print log message with appropriate prefix.</p>"},{"location":"py-rattler-build/reference/progress/#richprogresscallback","title":"<code>RichProgressCallback</code>","text":"<p>Rich-based progress callback with beautiful terminal output.</p> <p>Automatically creates progress bars for long-running operations by parsing log messages. Shows spinners for operations and bars for downloads.</p> <p>Requires the 'rich' library to be installed:     pip install rich</p> Example <pre><code>from rattler_build import Recipe, VariantConfig\nfrom rattler_build.progress import RichProgressCallback\n\nrecipe = Recipe.from_file(\"recipe.yaml\")\nrendered = recipe.render(VariantConfig())\n\nwith RichProgressCallback() as callback:\n    # Use callback in build (to be implemented)\n    pass\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.RichProgressCallback.__init__","title":"__init__","text":"<pre><code>__init__(show_logs=True, show_details=False)\n</code></pre> <p>Initialize the Rich progress callback.</p> <p>Parameters:</p> Name Type Description Default <code>show_logs</code> <code>bool</code> <p>Whether to display all log messages (default: True - recommended for debugging)</p> <code>True</code> <code>show_details</code> <code>bool</code> <p>Whether to show detailed logs like index operations (default: False)</p> <code>False</code>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.RichProgressCallback.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.RichProgressCallback.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.RichProgressCallback.on_download_start","title":"on_download_start","text":"<pre><code>on_download_start(event)\n</code></pre> <p>Create a progress bar for the download.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.RichProgressCallback.on_download_progress","title":"on_download_progress","text":"<pre><code>on_download_progress(event)\n</code></pre> <p>Update the download progress bar.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.RichProgressCallback.on_download_complete","title":"on_download_complete","text":"<pre><code>on_download_complete(event)\n</code></pre> <p>Mark the download as complete.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.RichProgressCallback.on_build_step","title":"on_build_step","text":"<pre><code>on_build_step(event)\n</code></pre> <p>Update or create a build step task.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.RichProgressCallback.on_log","title":"on_log","text":"<pre><code>on_log(event)\n</code></pre> <p>Parse log messages and create/update progress bars.</p>"},{"location":"py-rattler-build/reference/progress/#protocol","title":"Protocol","text":""},{"location":"py-rattler-build/reference/progress/#progresscallback","title":"<code>ProgressCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for progress callbacks.</p> <p>Implement this protocol to receive progress updates during builds. All methods are optional - only implement the ones you need.</p> Example <pre><code>class MyCallback(ProgressCallback):\n    def on_download_progress(self, event: DownloadProgressEvent):\n        percent = event.bytes_downloaded / event.total_bytes * 100\n        print(f\"Downloaded {percent:.1f}%\")\n\n    def on_build_step(self, event: BuildStepEvent):\n        print(f\"[{event.step_name}] {event.message}\")\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.ProgressCallback.on_download_start","title":"on_download_start","text":"<pre><code>on_download_start(event)\n</code></pre> <p>Called when a download starts.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>DownloadStartEvent</code> <p>Event containing download URL and expected total bytes</p> required"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.ProgressCallback.on_download_progress","title":"on_download_progress","text":"<pre><code>on_download_progress(event)\n</code></pre> <p>Called periodically during download to report progress.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>DownloadProgressEvent</code> <p>Event containing bytes downloaded and total bytes</p> required"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.ProgressCallback.on_download_complete","title":"on_download_complete","text":"<pre><code>on_download_complete(event)\n</code></pre> <p>Called when a download completes successfully.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>DownloadCompleteEvent</code> <p>Event containing the download URL</p> required"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.ProgressCallback.on_build_step","title":"on_build_step","text":"<pre><code>on_build_step(event)\n</code></pre> <p>Called when a new build step begins.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BuildStepEvent</code> <p>Event containing step name and message</p> required"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.ProgressCallback.on_log","title":"on_log","text":"<pre><code>on_log(event)\n</code></pre> <p>Called for log messages.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>LogEvent</code> <p>Event containing log level, message, and optional span</p> required"},{"location":"py-rattler-build/reference/progress/#events","title":"Events","text":""},{"location":"py-rattler-build/reference/progress/#downloadstartevent","title":"<code>DownloadStartEvent</code>","text":"<p>Event fired when a download starts.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.DownloadStartEvent.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.DownloadStartEvent.total_bytes","title":"total_bytes  <code>instance-attribute</code>","text":"<pre><code>total_bytes = total_bytes\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#downloadprogressevent","title":"<code>DownloadProgressEvent</code>","text":"<p>Event fired during download progress.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.DownloadProgressEvent.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.DownloadProgressEvent.bytes_downloaded","title":"bytes_downloaded  <code>instance-attribute</code>","text":"<pre><code>bytes_downloaded = bytes_downloaded\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.DownloadProgressEvent.total_bytes","title":"total_bytes  <code>instance-attribute</code>","text":"<pre><code>total_bytes = total_bytes\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#downloadcompleteevent","title":"<code>DownloadCompleteEvent</code>","text":"<p>Event fired when a download completes.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.DownloadCompleteEvent.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#buildstepevent","title":"<code>BuildStepEvent</code>","text":"<p>Event fired when a build step begins.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.BuildStepEvent.step_name","title":"step_name  <code>instance-attribute</code>","text":"<pre><code>step_name = step_name\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.BuildStepEvent.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#logevent","title":"<code>LogEvent</code>","text":"<p>Event fired for log messages.</p>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.LogEvent.level","title":"level  <code>instance-attribute</code>","text":"<pre><code>level = level\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.LogEvent.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"py-rattler-build/reference/progress/#rattler_build.progress.LogEvent.span","title":"span  <code>instance-attribute</code>","text":"<pre><code>span = span\n</code></pre>"},{"location":"py-rattler-build/reference/recipe/","title":"Recipe","text":"<p>Recipe classes for parsing and working with conda recipes.</p> <p>rattler-build uses a two-stage recipe system:</p> <ol> <li>Stage0 - Parsed YAML recipes before Jinja template evaluation</li> <li>Stage1 - Fully evaluated recipes ready for building</li> </ol> <p>You can import the recipe classes from <code>rattler_build</code>:</p> <pre><code>from rattler_build import Stage0Recipe, SingleOutputRecipe, MultiOutputRecipe, Stage1Recipe\n</code></pre>"},{"location":"py-rattler-build/reference/recipe/#stage0-parsed-recipes","title":"Stage0 - Parsed Recipes","text":""},{"location":"py-rattler-build/reference/recipe/#stage0recipe","title":"<code>Stage0Recipe</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A parsed conda recipe (stage0).</p> <p>This is an abstract base class. Use <code>from_yaml()</code>, <code>from_file()</code>, or <code>from_dict()</code> to create concrete instances (<code>SingleOutputRecipe</code> or <code>MultiOutputRecipe</code>).</p> Example <pre><code>recipe = Stage0Recipe.from_yaml(yaml_string)\nif isinstance(recipe, SingleOutputRecipe):\n    print(recipe.package.name)\n</code></pre>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.schema_version","title":"schema_version  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>schema_version\n</code></pre> <p>Get the schema version.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.context","title":"context  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>context\n</code></pre> <p>Get the context variables as a dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.build","title":"build  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>build\n</code></pre> <p>Get the build configuration.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.about","title":"about  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>about\n</code></pre> <p>Get the about metadata.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(yaml, *, recipe_dir=None)\n</code></pre> <p>Parse a recipe from a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>yaml</code> <code>str</code> <p>The YAML recipe content.</p> required <code>recipe_dir</code> <code>Path | str | None</code> <p>Directory to write the recipe file into.  When <code>None</code> (the default) a temporary directory is created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Stage0Recipe</code> <p>SingleOutputRecipe or MultiOutputRecipe depending on the recipe type.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(path)\n</code></pre> <p>Parse a recipe from a YAML file.</p> <p>The file path is used as the recipe path directly \u2014 no copy is made.</p> <p>Returns:</p> Type Description <code>Stage0Recipe</code> <p>SingleOutputRecipe or MultiOutputRecipe depending on the recipe type.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(recipe_dict, *, recipe_dir=None)\n</code></pre> <p>Create a recipe from a Python dictionary.</p> <p>This method validates the dictionary structure and provides detailed error messages if the structure is invalid or types don't match.</p> <p>Parameters:</p> Name Type Description Default <code>recipe_dict</code> <code>dict[str, Any]</code> <p>Dictionary containing recipe data (must match recipe schema).</p> required <code>recipe_dir</code> <code>Path | str | None</code> <p>Directory to write the recipe file into.  When <code>None</code> (the default) a temporary directory is created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Stage0Recipe</code> <p>SingleOutputRecipe or MultiOutputRecipe depending on the recipe type.</p> <p>Raises:</p> Type Description <code>PyRecipeParseError</code> <p>If the dictionary structure is invalid or types don't match.</p> Example <pre><code>recipe_dict = {\n    \"package\": {\n        \"name\": \"my-package\",\n        \"version\": \"1.0.0\"\n    },\n    \"build\": {\n        \"number\": 0\n    }\n}\nrecipe = Stage0Recipe.from_dict(recipe_dict)\n</code></pre>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.as_single_output","title":"as_single_output","text":"<pre><code>as_single_output()\n</code></pre> <p>Get as a single output recipe.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If this is not a single-output recipe.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.as_multi_output","title":"as_multi_output","text":"<pre><code>as_multi_output()\n</code></pre> <p>Get as a multi output recipe.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If this is not a multi-output recipe.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.render","title":"render","text":"<pre><code>render(variant_config=None, render_config=None)\n</code></pre> <p>Render this recipe with variant configuration.</p> <p>This method takes this Stage0 recipe and evaluates all Jinja templates with different variant combinations to produce ready-to-build Stage1 recipes.</p> <p>The recipe's :attr:<code>recipe_path</code> is automatically injected into the render configuration so that Jinja functions like <code>include()</code> and <code>file_name()</code> can resolve relative paths.</p> <p>Parameters:</p> Name Type Description Default <code>variant_config</code> <code>VariantConfig | None</code> <p>Optional VariantConfig to use. If None, creates an empty config.</p> <code>None</code> <code>render_config</code> <code>RenderConfig | None</code> <p>Optional RenderConfig to use. If None, uses default config.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[RenderedVariant]</code> <p>List of RenderedVariant objects (one for each variant combination)</p> Example <pre><code>recipe = Stage0Recipe.from_yaml(yaml_string)\nvariants = recipe.render(variant_config)\nfor variant in variants:\n    print(variant.recipe.package.name)\n</code></pre>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.Stage0Recipe.run_build","title":"run_build","text":"<pre><code>run_build(\n    variant_config=None,\n    tool_config=None,\n    output_dir=None,\n    channels=None,\n    progress_callback=None,\n    no_build_id=False,\n    package_format=None,\n    no_include_recipe=False,\n    debug=False,\n    exclude_newer=None,\n)\n</code></pre> <p>Build this recipe.</p> <p>This method renders the recipe with variants and then builds the rendered outputs.  The :attr:<code>recipe_path</code> is used automatically for directory setup and recipe inclusion in the package.</p> <p>Parameters:</p> Name Type Description Default <code>variant_config</code> <code>VariantConfig | None</code> <p>Optional VariantConfig to use for building variants.</p> <code>None</code> <code>tool_config</code> <code>ToolConfiguration | None</code> <p>ToolConfiguration to use for the build. If None, uses defaults.</p> <code>None</code> <code>output_dir</code> <code>str | Path | None</code> <p>Directory to store the built packages. Defaults to <code>&lt;recipe_dir&gt;/output</code>.</p> <code>None</code> <code>channels</code> <code>list[str] | None</code> <p>List of channels to use for resolving dependencies. Defaults to [\"conda-forge\"].</p> <code>None</code> <code>progress_callback</code> <code>ProgressCallback | None</code> <p>Optional progress callback for build events.</p> <code>None</code> <code>no_build_id</code> <code>bool</code> <p>Don't include build ID in output directory.</p> <code>False</code> <code>package_format</code> <code>str | None</code> <p>Package format (\"conda\" or \"tar.bz2\").</p> <code>None</code> <code>no_include_recipe</code> <code>bool</code> <p>Don't include recipe in the output package.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Enable debug mode.</p> <code>False</code> <code>exclude_newer</code> <code>datetime | None</code> <p>Exclude packages newer than this timestamp.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[BuildResult]</code> <p>list[BuildResult]: List of build results, one per variant built.</p> Example <pre><code>recipe = Stage0Recipe.from_yaml(yaml_string)\n# Build with default output dir (&lt;recipe_dir&gt;/output)\nresults = recipe.run_build()\nfor result in results:\n    print(f\"Built {result.name} {result.version}\")\n    print(f\"Package at: {result.packages[0]}\")\n\n# Or with custom tool configuration\nfrom rattler_build import ToolConfiguration\nconfig = ToolConfiguration(keep_build=True, test_strategy=\"native\")\nresults = recipe.run_build(tool_config=config, output_dir=\"./output\")\n</code></pre>"},{"location":"py-rattler-build/reference/recipe/#singleoutputrecipe","title":"<code>SingleOutputRecipe</code>","text":"<p>               Bases: <code>Stage0Recipe</code></p> <p>A single-output recipe at stage0 (parsed, not yet evaluated).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.SingleOutputRecipe.schema_version","title":"schema_version  <code>property</code>","text":"<pre><code>schema_version\n</code></pre> <p>Get the schema version.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.SingleOutputRecipe.context","title":"context  <code>property</code>","text":"<pre><code>context\n</code></pre> <p>Get the context variables as a dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.SingleOutputRecipe.package","title":"package  <code>property</code>","text":"<pre><code>package\n</code></pre> <p>Get the package metadata.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.SingleOutputRecipe.build","title":"build  <code>property</code>","text":"<pre><code>build\n</code></pre> <p>Get the build configuration.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.SingleOutputRecipe.requirements","title":"requirements  <code>property</code>","text":"<pre><code>requirements\n</code></pre> <p>Get the requirements.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.SingleOutputRecipe.about","title":"about  <code>property</code>","text":"<pre><code>about\n</code></pre> <p>Get the about metadata.</p>"},{"location":"py-rattler-build/reference/recipe/#multioutputrecipe","title":"<code>MultiOutputRecipe</code>","text":"<p>               Bases: <code>Stage0Recipe</code></p> <p>A multi-output recipe at stage0 (parsed, not yet evaluated).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.MultiOutputRecipe.schema_version","title":"schema_version  <code>property</code>","text":"<pre><code>schema_version\n</code></pre> <p>Get the schema version.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.MultiOutputRecipe.context","title":"context  <code>property</code>","text":"<pre><code>context\n</code></pre> <p>Get the context variables as a dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.MultiOutputRecipe.recipe","title":"recipe  <code>property</code>","text":"<pre><code>recipe\n</code></pre> <p>Get the top-level recipe metadata.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.MultiOutputRecipe.build","title":"build  <code>property</code>","text":"<pre><code>build\n</code></pre> <p>Get the top-level build configuration.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.MultiOutputRecipe.about","title":"about  <code>property</code>","text":"<pre><code>about\n</code></pre> <p>Get the top-level about metadata.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.MultiOutputRecipe.outputs","title":"outputs  <code>property</code>","text":"<pre><code>outputs\n</code></pre> <p>Get all outputs (package and staging).</p>"},{"location":"py-rattler-build/reference/recipe/#stage1-evaluated-recipes","title":"Stage1 - Evaluated Recipes","text":""},{"location":"py-rattler-build/reference/recipe/#stage1recipe","title":"<code>Stage1Recipe</code>","text":"<p>A fully evaluated conda recipe (stage1), ready for building.</p> <p>This represents the recipe after all Jinja templates have been evaluated and all conditionals resolved.</p> Example <pre><code># After parsing and rendering a Stage0Recipe\nstage0_recipe = Stage0Recipe.from_yaml(yaml_string)\nrendered = stage0_recipe.render(variant_config)\nstage1_recipe = rendered[0].recipe\nprint(stage1_recipe.package.name)\nprint(stage1_recipe.package.version)\n</code></pre>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.package","title":"package  <code>property</code>","text":"<pre><code>package\n</code></pre> <p>Get the package metadata.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.build","title":"build  <code>property</code>","text":"<pre><code>build\n</code></pre> <p>Get the build configuration.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.requirements","title":"requirements  <code>property</code>","text":"<pre><code>requirements\n</code></pre> <p>Get the requirements.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.about","title":"about  <code>property</code>","text":"<pre><code>about\n</code></pre> <p>Get the about metadata.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.context","title":"context  <code>property</code>","text":"<pre><code>context\n</code></pre> <p>Get the evaluation context.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.used_variant","title":"used_variant  <code>property</code>","text":"<pre><code>used_variant\n</code></pre> <p>Get the variant values used in this build.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.sources","title":"sources  <code>property</code>","text":"<pre><code>sources\n</code></pre> <p>Get all sources for this recipe.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.staging_caches","title":"staging_caches  <code>property</code>","text":"<pre><code>staging_caches\n</code></pre> <p>Get all staging caches.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.inherits_from","title":"inherits_from  <code>property</code>","text":"<pre><code>inherits_from\n</code></pre> <p>Get inheritance information if this output inherits from a cache.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Stage1Recipe.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#supporting-types","title":"Supporting Types","text":""},{"location":"py-rattler-build/reference/recipe/#stage0-types","title":"Stage0 Types","text":"<p>Package metadata at stage0.</p> <p>A package output in a multi-output recipe.</p> <p>A staging output in a multi-output recipe.</p> <p>Recipe metadata for multi-output recipes.</p> <p>Build configuration at stage0.</p> <p>Requirements at stage0.</p> <p>About metadata at stage0.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Package.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Get the package name (may be a template string like '${{ name }}').</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Package.version","title":"version  <code>property</code>","text":"<pre><code>version\n</code></pre> <p>Get the package version (may be a template string like '${{ version }}').</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Package.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.PackageOutput.package","title":"package  <code>property</code>","text":"<pre><code>package\n</code></pre> <p>Get the package metadata for this output.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.PackageOutput.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.StagingOutput.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.RecipeMetadata.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Build.number","title":"number  <code>property</code>","text":"<pre><code>number\n</code></pre> <p>Get the build number (may be a template).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Build.string","title":"string  <code>property</code>","text":"<pre><code>string\n</code></pre> <p>Get the build string (may be a template or None for auto-generated).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Build.script","title":"script  <code>property</code>","text":"<pre><code>script\n</code></pre> <p>Get the build script configuration.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Build.noarch","title":"noarch  <code>property</code>","text":"<pre><code>noarch\n</code></pre> <p>Get the noarch type (may be a template or None).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Build.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Requirements.build","title":"build  <code>property</code>","text":"<pre><code>build\n</code></pre> <p>Get build-time requirements (list of matchspecs or templates).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Requirements.host","title":"host  <code>property</code>","text":"<pre><code>host\n</code></pre> <p>Get host-time requirements (list of matchspecs or templates).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Requirements.run","title":"run  <code>property</code>","text":"<pre><code>run\n</code></pre> <p>Get run-time requirements (list of matchspecs or templates).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Requirements.run_constraints","title":"run_constraints  <code>property</code>","text":"<pre><code>run_constraints\n</code></pre> <p>Get run-time constraints (list of matchspecs or templates).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.Requirements.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.About.homepage","title":"homepage  <code>property</code>","text":"<pre><code>homepage\n</code></pre> <p>Get the homepage URL (may be a template or None).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.About.license","title":"license  <code>property</code>","text":"<pre><code>license\n</code></pre> <p>Get the license (may be a template or None).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.About.license_family","title":"license_family  <code>property</code>","text":"<pre><code>license_family\n</code></pre> <p>Get the license family (deprecated, may be a template or None).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.About.summary","title":"summary  <code>property</code>","text":"<pre><code>summary\n</code></pre> <p>Get the summary (may be a template or None).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.About.description","title":"description  <code>property</code>","text":"<pre><code>description\n</code></pre> <p>Get the description (may be a template or None).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.About.documentation","title":"documentation  <code>property</code>","text":"<pre><code>documentation\n</code></pre> <p>Get the documentation URL (may be a template or None).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.About.repository","title":"repository  <code>property</code>","text":"<pre><code>repository\n</code></pre> <p>Get the repository URL (may be a template or None).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage0.About.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#stage1-types","title":"Stage1 Types","text":"<p>Package metadata at stage1 (fully evaluated).</p> <p>Build configuration at stage1 (fully evaluated).</p> <p>Requirements at stage1 (fully evaluated).</p> <p>About metadata at stage1 (fully evaluated).</p> <p>Source information at stage1 (fully evaluated).</p> <p>Staging cache information at stage1 (fully evaluated).</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Package.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Get the package name.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Package.version","title":"version  <code>property</code>","text":"<pre><code>version\n</code></pre> <p>Get the package version.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Package.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Build.number","title":"number  <code>property</code>","text":"<pre><code>number\n</code></pre> <p>Get the build number.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Build.string","title":"string  <code>property</code>","text":"<pre><code>string\n</code></pre> <p>Get the build string.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Build.script","title":"script  <code>property</code>","text":"<pre><code>script\n</code></pre> <p>Get the build script.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Build.noarch","title":"noarch  <code>property</code>","text":"<pre><code>noarch\n</code></pre> <p>Get the noarch configuration if any.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Build.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Requirements.build","title":"build  <code>property</code>","text":"<pre><code>build\n</code></pre> <p>Get build requirements.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Requirements.host","title":"host  <code>property</code>","text":"<pre><code>host\n</code></pre> <p>Get host requirements.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Requirements.run","title":"run  <code>property</code>","text":"<pre><code>run\n</code></pre> <p>Get run requirements.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Requirements.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.About.homepage","title":"homepage  <code>property</code>","text":"<pre><code>homepage\n</code></pre> <p>Get the homepage URL.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.About.repository","title":"repository  <code>property</code>","text":"<pre><code>repository\n</code></pre> <p>Get the repository URL.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.About.documentation","title":"documentation  <code>property</code>","text":"<pre><code>documentation\n</code></pre> <p>Get the documentation URL.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.About.license","title":"license  <code>property</code>","text":"<pre><code>license\n</code></pre> <p>Get the license string.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.About.summary","title":"summary  <code>property</code>","text":"<pre><code>summary\n</code></pre> <p>Get the summary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.About.description","title":"description  <code>property</code>","text":"<pre><code>description\n</code></pre> <p>Get the description.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.About.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.Source.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.StagingCache.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Get the cache name.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.StagingCache.build","title":"build  <code>property</code>","text":"<pre><code>build\n</code></pre> <p>Get the build configuration for this cache.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.StagingCache.requirements","title":"requirements  <code>property</code>","text":"<pre><code>requirements\n</code></pre> <p>Get the requirements for this cache.</p>"},{"location":"py-rattler-build/reference/recipe/#rattler_build.stage1.StagingCache.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to Python dictionary.</p>"},{"location":"py-rattler-build/reference/recipe_generation/","title":"Recipe Generation","text":"<p>Generate conda recipes from various package ecosystems.</p> <p>These functions fetch package metadata from upstream repositories and generate ready-to-use <code>Stage0Recipe</code> objects.</p> <p>You can import the generation functions from <code>rattler_build</code>:</p> <pre><code>from rattler_build import (\n    generate_pypi_recipe,\n    generate_cran_recipe,\n    generate_cpan_recipe,\n    generate_luarocks_recipe,\n)\n</code></pre>"},{"location":"py-rattler-build/reference/recipe_generation/#generate_pypi_recipe","title":"<code>generate_pypi_recipe</code>","text":"<p>Generate a conda recipe from a PyPI package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The name of the PyPI package to generate a recipe for.</p> required <code>version</code> <code>str | None</code> <p>Specific version of the package to use. If None, uses the latest version.</p> <code>None</code> <code>use_mapping</code> <code>bool</code> <p>Whether to use conda-forge package name mappings for dependencies. This helps map PyPI names to their corresponding conda-forge package names.</p> <code>True</code> <p>Returns:</p> Type Description <code>Stage0Recipe</code> <p>A Stage0Recipe object representing the generated recipe.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the package cannot be found or if there's a network error.</p> Example <p>Generate a recipe for the latest version of flit-core:</p> <pre><code>from rattler_build import generate_pypi_recipe\n\nrecipe = generate_pypi_recipe(\"flit-core\")\nrecipe.as_single_output().package.name\n# 'flit-core'\n</code></pre>"},{"location":"py-rattler-build/reference/recipe_generation/#generate_cran_recipe","title":"<code>generate_cran_recipe</code>","text":"<p>Generate a conda recipe from a CRAN (R) package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The name of the CRAN package to generate a recipe for.</p> required <code>universe</code> <code>str | None</code> <p>The R universe to fetch the package from. Defaults to \"cran\" if not specified. Other options include specific R-universe repositories.</p> <code>None</code> <p>Returns:</p> Type Description <code>Stage0Recipe</code> <p>A Stage0Recipe object representing the generated recipe.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the package cannot be found or if there's a network error.</p> Example <p>Generate a recipe for a CRAN package:</p> <pre><code>from rattler_build import generate_cran_recipe\n\nrecipe = generate_cran_recipe(\"assertthat\")\nrecipe.as_single_output().package.name\n# 'r-assertthat'\n</code></pre>"},{"location":"py-rattler-build/reference/recipe_generation/#generate_cpan_recipe","title":"<code>generate_cpan_recipe</code>","text":"<p>Generate a conda recipe from a CPAN (Perl) package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The name of the CPAN package to generate a recipe for.</p> required <code>version</code> <code>str | None</code> <p>Specific version of the package to use. If None, uses the latest version.</p> <code>None</code> <p>Returns:</p> Type Description <code>Stage0Recipe</code> <p>A Stage0Recipe object representing the generated recipe.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the package cannot be found or if there's a network error.</p> Example <p>Generate a recipe for a CPAN package:</p> <pre><code>from rattler_build import generate_cpan_recipe\n\nrecipe = generate_cpan_recipe(\"Try-Tiny\")\nrecipe.as_single_output().package.name\n# 'perl-try-tiny'\n</code></pre>"},{"location":"py-rattler-build/reference/recipe_generation/#generate_luarocks_recipe","title":"<code>generate_luarocks_recipe</code>","text":"<p>Generate a conda recipe from a LuaRocks package.</p> <p>Parameters:</p> Name Type Description Default <code>rock</code> <code>str</code> <p>The LuaRocks package specification. Can be in one of these formats: - \"module\" - uses the latest version - \"module/version\" - uses a specific version - \"author/module/version\" - specifies author, module and version - Direct rockspec URL</p> required <p>Returns:</p> Type Description <code>Stage0Recipe</code> <p>A Stage0Recipe object representing the generated recipe.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the package cannot be found or if there's a network error.</p> Example <p>Generate a recipe for a LuaRocks package:</p> <pre><code>from rattler_build import generate_luarocks_recipe\n\nrecipe = generate_luarocks_recipe(\"luafilesystem\")\nrecipe.as_single_output().package.name\n# 'lua-luafilesystem'\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/","title":"Rendering","text":"<p>Render recipes with variant configurations to produce buildable outputs.</p> <p>You can import the rendering classes from <code>rattler_build</code>:</p> <pre><code>from rattler_build import VariantConfig, RenderConfig, RenderedVariant\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#variantconfig","title":"<code>VariantConfig</code>","text":"<p>Configuration for build variants.</p> <p>Variants allow building the same recipe with different configurations, such as different Python versions, compilers, or other parameters.</p> <p>This class provides a dict-like interface for managing variants.</p> Example <pre><code># Create from dict\nconfig = VariantConfig({\n    \"python\": [\"3.8\", \"3.9\", \"3.10\"],\n    \"numpy\": [\"1.21\", \"1.22\"]\n})\nlen(config.combinations())  # 3 * 2 = 6 combinations\n# 6\n\n# Dict-like access\nprint(config[\"python\"])\n# ['3.8', '3.9', '3.10']\n\n# Get values\nprint(config.get_values(\"python\"))\n# ['3.8', '3.9', '3.10']\n\n# Load from YAML file\nconfig = VariantConfig.from_file(\"variant_config.yaml\")\nprint(config.keys())\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.zip_keys","title":"zip_keys  <code>property</code>","text":"<pre><code>zip_keys\n</code></pre> <p>Get zip_keys - groups of keys that should be zipped together.</p> <p>Zip keys ensure that certain variant keys are synchronized when creating combinations. For example, if python and numpy are zipped, then python=3.9 will always be paired with numpy=1.20, not with other numpy versions.</p> <p>Returns:</p> Type Description <code>list[list[str]] | None</code> <p>List of groups (each group is a list of keys), or None if no zip keys are defined</p> Example <pre><code>config = VariantConfig(\n    {\"python\": [\"3.9\", \"3.10\"], \"numpy\": [\"1.20\", \"1.21\"]},\n    zip_keys=[[\"python\", \"numpy\"]]\n)\nlen(config.combinations())  # 2, not 4\n# 2\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.__init__","title":"__init__","text":"<pre><code>__init__(variants=None, zip_keys=None)\n</code></pre> <p>Create a new VariantConfig.</p> <p>Parameters:</p> Name Type Description Default <code>variants</code> <code>dict[str, list[Any]] | None</code> <p>A dictionary mapping variant keys to value lists.      If None, creates empty config.</p> <code>None</code> <code>zip_keys</code> <code>list[list[str]] | None</code> <p>Optional list of groups (each group is a list of keys) that should be      zipped together. Ensures that certain variant keys are synchronized.</p> <code>None</code> Example <pre><code># Create from dict\nconfig = VariantConfig({\"python\": [\"3.9\", \"3.10\"]})\n\n# Create with zip_keys\nconfig = VariantConfig(\n    {\"python\": [\"3.9\", \"3.10\"], \"numpy\": [\"1.21\", \"1.22\"]},\n    zip_keys=[[\"python\", \"numpy\"]]\n)\n\n# Create empty\nconfig = VariantConfig()\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(path)\n</code></pre> <p>Load VariantConfig from a YAML file (variants.yaml format).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the variant configuration YAML file</p> required <p>Returns:</p> Type Description <code>VariantConfig</code> <p>A new VariantConfig instance</p> Example <pre><code>config = VariantConfig.from_file(\"variants.yaml\")\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.from_file_with_context","title":"from_file_with_context  <code>classmethod</code>","text":"<pre><code>from_file_with_context(path, jinja_config)\n</code></pre> <p>Load VariantConfig from a YAML file with a JinjaConfig context (variants.yaml format).</p> <p>This allows evaluation of conditionals and templates in the variant file. The jinja_config provides platform information and other context needed for evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the variant configuration YAML file</p> required <code>jinja_config</code> <code>JinjaConfig</code> <p>JinjaConfig providing context for evaluation</p> required <p>Returns:</p> Type Description <code>VariantConfig</code> <p>A new VariantConfig instance</p> Example <pre><code>from rattler_build import JinjaConfig\n\njinja_config = JinjaConfig(target_platform=\"linux-64\")\nconfig = VariantConfig.from_file_with_context(\"variants.yaml\", jinja_config)\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.from_conda_build_config","title":"from_conda_build_config  <code>classmethod</code>","text":"<pre><code>from_conda_build_config(path, jinja_config)\n</code></pre> <p>Load VariantConfig from a conda_build_config.yaml file.</p> <p>This supports the legacy conda-build format with <code># [selector]</code> syntax. Selectors are evaluated using the provided JinjaConfig.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the conda_build_config.yaml file</p> required <code>jinja_config</code> <code>JinjaConfig</code> <p>JinjaConfig providing context for selector evaluation</p> required <p>Returns:</p> Type Description <code>VariantConfig</code> <p>A new VariantConfig instance</p> Example <pre><code>from rattler_build import JinjaConfig\n\njinja_config = JinjaConfig(target_platform=\"linux-64\")\nconfig = VariantConfig.from_conda_build_config(\"conda_build_config.yaml\", jinja_config)\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(yaml)\n</code></pre> <p>Load VariantConfig from a YAML string (variants.yaml format).</p> <p>Parameters:</p> Name Type Description Default <code>yaml</code> <code>str</code> <p>YAML string containing variant configuration</p> required <p>Returns:</p> Type Description <code>VariantConfig</code> <p>A new VariantConfig instance</p> Example <pre><code>yaml_str = '''\npython:\n  - \"3.8\"\n  - \"3.9\"\n'''\nconfig = VariantConfig.from_yaml(yaml_str)\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.from_yaml_with_context","title":"from_yaml_with_context  <code>classmethod</code>","text":"<pre><code>from_yaml_with_context(yaml, jinja_config)\n</code></pre> <p>Load VariantConfig from a YAML string with a JinjaConfig context (variants.yaml format).</p> <p>This allows evaluation of conditionals and templates in the variant YAML. The jinja_config provides platform information and other context needed for evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>yaml</code> <code>str</code> <p>YAML string containing variant configuration</p> required <code>jinja_config</code> <code>JinjaConfig</code> <p>JinjaConfig providing context for evaluation</p> required <p>Returns:</p> Type Description <code>VariantConfig</code> <p>A new VariantConfig instance</p> Example <pre><code>from rattler_build import JinjaConfig\n\nyaml_str = '''\nc_compiler:\n  - if: unix\n    then: gcc\n  - if: win\n    then: msvc\n'''\njinja_config = JinjaConfig(target_platform=\"linux-64\")\nconfig = VariantConfig.from_yaml_with_context(yaml_str, jinja_config)\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Get all variant keys.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of variant key names</p> Example <pre><code>config = VariantConfig({\"python\": [\"3.8\", \"3.9\"], \"numpy\": [\"1.21\"]})\nconfig.keys()\n# ['numpy', 'python']\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.get_values","title":"get_values","text":"<pre><code>get_values(key)\n</code></pre> <p>Get values for a specific variant key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The variant key name</p> required <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>List of values for the key, or None if key doesn't exist</p> Example <pre><code>config = VariantConfig({\"python\": [\"3.8\", \"3.9\", \"3.10\"]})\nconfig.get_values(\"python\")\n# ['3.8', '3.9', '3.10']\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Get all variants as a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, list[Any]]</code> <p>Dictionary mapping variant keys to their value lists</p> Example <pre><code>config = VariantConfig({\"python\": [\"3.8\", \"3.9\"]})\nconfig.to_dict()\n# {'python': ['3.8', '3.9']}\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.combinations","title":"combinations","text":"<pre><code>combinations()\n</code></pre> <p>Generate all combinations of variant values.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of dictionaries, each representing one variant combination</p> Example <pre><code>config = VariantConfig({\"python\": [\"3.8\", \"3.9\"], \"numpy\": [\"1.21\", \"1.22\"]})\ncombos = config.combinations()\nlen(combos)\n# 4\ncombos[0]\n# {'python': '3.8', 'numpy': '1.21'}\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.get","title":"get","text":"<pre><code>get(key, default=None)\n</code></pre> <p>Get values for a variant key with a default.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The variant key name</p> required <code>default</code> <code>list[Any] | None</code> <p>Default value if key doesn't exist</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>List of values for the key, or default if key doesn't exist</p> Example <pre><code>config = VariantConfig({\"python\": [\"3.9\"]})\nconfig.get(\"python\")\n# ['3.9']\nconfig.get(\"ruby\", [\"2.7\"])\n# ['2.7']\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Get all variant key-value pairs.</p> <p>Returns:</p> Type Description <code>ItemsView[str, list[str]]</code> <p>Iterator of (key, values) tuples</p> Example <pre><code>config = VariantConfig({\"python\": [\"3.9\", \"3.10\"]})\ndict(config.items())\n# {'python': ['3.9', '3.10']}\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.VariantConfig.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Get all variant value lists.</p> <p>Returns:</p> Type Description <code>ValuesView[list[str]]</code> <p>Iterator of value lists</p> Example <pre><code>config = VariantConfig({\"python\": [\"3.9\", \"3.10\"]})\nlist(config.values())\n# [['3.9', '3.10']]\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#renderconfig","title":"<code>RenderConfig</code>","text":"<p>Configuration for rendering recipes with variants.</p> <p>This class configures how recipes are rendered, including platform settings, experimental features, and additional Jinja context variables.</p> <p>The <code>recipe_path</code> is not set here \u2014 it is automatically injected from the :class:<code>~rattler_build.stage0.Stage0Recipe</code> during :meth:<code>render</code>.</p> <p>Parameters:</p> Name Type Description Default <code>platform</code> <code>PlatformConfig | None</code> <p>Platform configuration (target, build, host platforms, experimental flag)</p> <code>None</code> <code>extra_context</code> <code>dict[str, ContextValue] | None</code> <p>Dictionary of extra context variables for Jinja rendering</p> <code>None</code> Example <pre><code>from rattler_build.tool_config import PlatformConfig\n\nplatform = PlatformConfig(target_platform=\"linux-64\")\nconfig = RenderConfig(\n    platform=platform,\n    extra_context={\"custom_var\": \"value\", \"build_num\": 42}\n)\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderConfig.target_platform","title":"target_platform  <code>property</code>","text":"<pre><code>target_platform\n</code></pre> <p>Get the target platform.</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderConfig.build_platform","title":"build_platform  <code>property</code>","text":"<pre><code>build_platform\n</code></pre> <p>Get the build platform.</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderConfig.host_platform","title":"host_platform  <code>property</code>","text":"<pre><code>host_platform\n</code></pre> <p>Get the host platform.</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderConfig.experimental","title":"experimental  <code>property</code>","text":"<pre><code>experimental\n</code></pre> <p>Get whether experimental features are enabled.</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderConfig.__init__","title":"__init__","text":"<pre><code>__init__(platform=None, extra_context=None)\n</code></pre> <p>Create a new render configuration.</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderConfig.get_context","title":"get_context","text":"<pre><code>get_context(key)\n</code></pre> <p>Get an extra context variable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Variable name</p> required <p>Returns:</p> Type Description <code>ContextValue | None</code> <p>The variable value, or None if not found</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderConfig.get_all_context","title":"get_all_context","text":"<pre><code>get_all_context()\n</code></pre> <p>Get all extra context variables as a dictionary.</p>"},{"location":"py-rattler-build/reference/rendering/#renderedvariant","title":"<code>RenderedVariant</code>","text":"<p>Result of rendering a recipe with a specific variant combination.</p> <p>Each RenderedVariant represents one specific variant of a recipe after all Jinja templates have been evaluated and variant values applied.</p> <p>The :attr:<code>recipe_path</code> is carried over from the :class:<code>~rattler_build.stage0.Stage0Recipe</code> that produced this variant and is used automatically by :meth:<code>run_build</code>.</p> <p>Attributes:</p> Name Type Description <code>variant</code> <code>dict[str, str]</code> <p>The variant combination used (variable name -&gt; value)</p> <code>recipe</code> <code>Stage1Recipe</code> <p>The rendered Stage1 recipe</p> <code>hash_info</code> <code>HashInfo | None</code> <p>Build string hash information</p> <code>pin_subpackages</code> <code>dict[str, PinSubpackageInfo]</code> <p>Pin subpackage dependencies</p> <code>recipe_path</code> <code>Path</code> <p>Path to the recipe file on disk</p> Example <pre><code>for variant in rendered_variants:\n    print(f\"Package: {variant.recipe.package.name}\")\n    print(f\"Variant: {variant.variant}\")\n    print(f\"Build string: {variant.recipe.build.string}\")\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderedVariant.variant","title":"variant  <code>property</code>","text":"<pre><code>variant\n</code></pre> <p>Get the variant combination used for this render.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping variable names to their values</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderedVariant.recipe","title":"recipe  <code>property</code>","text":"<pre><code>recipe\n</code></pre> <p>Get the rendered Stage1 recipe.</p> <p>Returns:</p> Type Description <code>Stage1Recipe</code> <p>The fully evaluated Stage1 recipe ready for building</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderedVariant.hash_info","title":"hash_info  <code>property</code>","text":"<pre><code>hash_info\n</code></pre> <p>Get hash info if available.</p> <p>Returns:</p> Type Description <code>HashInfo | None</code> <p>HashInfo object with 'hash' and 'prefix' attributes, or None</p> Example <pre><code>rendered = recipe.render(variant_config)[0]\nhash_info = rendered.hash_info\nif hash_info:\n    print(f\"Hash: {hash_info.hash}\")\n    print(f\"Prefix: {hash_info.prefix}\")\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderedVariant.pin_subpackages","title":"pin_subpackages  <code>property</code>","text":"<pre><code>pin_subpackages\n</code></pre> <p>Get pin_subpackage information.</p> <p>Returns:</p> Type Description <code>dict[str, PinSubpackageInfo]</code> <p>Dictionary mapping package names to PinSubpackageInfo objects</p> Example <pre><code>rendered = recipe.render(variant_config)[0]\nfor name, info in rendered.pin_subpackages.items():\n    print(f\"{name}: version={info.version}, exact={info.exact}\")\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.RenderedVariant.run_build","title":"run_build","text":"<pre><code>run_build(\n    tool_config=None,\n    output_dir=None,\n    channels=None,\n    progress_callback=None,\n    no_build_id=False,\n    package_format=None,\n    no_include_recipe=False,\n    debug=False,\n    exclude_newer=None,\n)\n</code></pre> <p>Build this rendered variant.</p> <p>This method builds a single rendered variant directly without needing to go back through the Stage0 recipe.  The recipe path is taken from this variant automatically (set during :meth:<code>Stage0Recipe.render</code>).</p> <p>Parameters:</p> Name Type Description Default <code>tool_config</code> <code>ToolConfiguration | None</code> <p>ToolConfiguration to use for the build. If None, uses defaults.</p> <code>None</code> <code>output_dir</code> <code>str | Path | None</code> <p>Directory to store the built package. Defaults to <code>&lt;recipe_dir&gt;/output</code>.</p> <code>None</code> <code>channels</code> <code>list[str] | None</code> <p>List of channels to use for resolving dependencies. Defaults to [\"conda-forge\"].</p> <code>None</code> <code>progress_callback</code> <code>ProgressCallback | None</code> <p>Optional progress callback for build events.</p> <code>None</code> <code>no_build_id</code> <code>bool</code> <p>Don't include build ID in output directory.</p> <code>False</code> <code>package_format</code> <code>str | None</code> <p>Package format (\"conda\" or \"tar.bz2\").</p> <code>None</code> <code>no_include_recipe</code> <code>bool</code> <p>Don't include recipe in the output package.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Enable debug mode.</p> <code>False</code> <code>exclude_newer</code> <code>datetime | None</code> <p>Exclude packages newer than this timestamp.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BuildResult</code> <code>BuildResult</code> <p>Information about the built package including paths, metadata, and timing.</p> Example <pre><code>from rattler_build import Stage0Recipe, VariantConfig\n\nrecipe = Stage0Recipe.from_yaml(yaml_string)\nrendered = recipe.render(VariantConfig())\n# Build just the first variant (output goes to &lt;recipe_dir&gt;/output)\nresult = rendered[0].run_build()\nprint(f\"Built package: {result.packages[0]}\")\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#supporting-types","title":"Supporting Types","text":""},{"location":"py-rattler-build/reference/rendering/#hashinfo","title":"<code>HashInfo</code>","text":"<p>Hash information for a rendered variant.</p> <p>This class wraps the Rust HashInfo type and provides convenient access to hash information computed during recipe rendering.</p> <p>Attributes:</p> Name Type Description <code>hash</code> <code>str</code> <p>The hash string (first 7 letters of the sha1sum)</p> <code>prefix</code> <code>str</code> <p>The hash prefix (e.g., 'py38' or 'np111')</p> Example <pre><code>hash_info = variant.hash_info\nif hash_info:\n    print(f\"Hash: {hash_info.hash}\")\n    print(f\"Prefix: {hash_info.prefix}\")\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.render.HashInfo.hash","title":"hash  <code>property</code>","text":"<pre><code>hash\n</code></pre> <p>Get the hash string (first 7 letters of sha1sum).</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.render.HashInfo.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix\n</code></pre> <p>Get the hash prefix (e.g., 'py38' or 'np111').</p>"},{"location":"py-rattler-build/reference/rendering/#pinsubpackageinfo","title":"<code>PinSubpackageInfo</code>","text":"<p>Information about a pin_subpackage dependency.</p> <p>This class wraps the Rust PinSubpackageInfo type and provides information about packages pinned via the pin_subpackage() Jinja function.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the pinned subpackage</p> <code>version</code> <code>str</code> <p>The version of the pinned subpackage</p> <code>build_string</code> <code>str | None</code> <p>The build string of the pinned subpackage (if known)</p> <code>exact</code> <code>bool</code> <p>Whether this is an exact pin</p> Example <pre><code>pins = variant.pin_subpackages\nfor name, info in pins.items():\n    print(f\"{name}: {info.version} (exact={info.exact})\")\n</code></pre>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.render.PinSubpackageInfo.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Get the package name.</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.render.PinSubpackageInfo.version","title":"version  <code>property</code>","text":"<pre><code>version\n</code></pre> <p>Get the package version.</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.render.PinSubpackageInfo.build_string","title":"build_string  <code>property</code>","text":"<pre><code>build_string\n</code></pre> <p>Get the build string if available.</p>"},{"location":"py-rattler-build/reference/rendering/#rattler_build.render.PinSubpackageInfo.exact","title":"exact  <code>property</code>","text":"<pre><code>exact\n</code></pre> <p>Check if this is an exact pin.</p>"},{"location":"py-rattler-build/reference/upload/","title":"Upload","text":"<p>Upload built packages to various conda package servers.</p> <p>You can import the upload functions from <code>rattler_build</code>:</p> <pre><code>from rattler_build import (\n    upload_package_to_quetz,\n    upload_package_to_artifactory,\n    upload_package_to_prefix,\n    upload_package_to_anaconda,\n    upload_packages_to_conda_forge,\n)\n</code></pre>"},{"location":"py-rattler-build/reference/upload/#upload_package_to_quetz","title":"<code>upload_package_to_quetz</code>","text":"<p>Upload to a Quetz server. Authentication is used from the keychain / auth-file.</p> <p>Parameters:</p> Name Type Description Default <code>package_files</code> <code>list[str]</code> <p>The package files to upload.</p> required <code>url</code> <code>str</code> <p>The URL of the Quetz server.</p> required <code>channels</code> <code>str</code> <p>The channels to upload the package to.</p> required <code>api_key</code> <code>str | None</code> <p>The API key for authentication.</p> <code>None</code> <code>auth_file</code> <code>str | Path | None</code> <p>The authentication file.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"py-rattler-build/reference/upload/#upload_package_to_artifactory","title":"<code>upload_package_to_artifactory</code>","text":"<p>Upload to an Artifactory channel. Authentication is used from the keychain / auth-file.</p> <p>Parameters:</p> Name Type Description Default <code>package_files</code> <code>list[str]</code> <p>The package files to upload.</p> required <code>url</code> <code>str</code> <p>The URL to your Artifactory server.</p> required <code>channels</code> <code>str</code> <p>The URL to your channel.</p> required <code>token</code> <code>str | None</code> <p>Your Artifactory token.</p> <code>None</code> <code>auth_file</code> <code>str | Path | None</code> <p>The authentication file.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"py-rattler-build/reference/upload/#upload_package_to_prefix","title":"<code>upload_package_to_prefix</code>","text":"<p>Upload to a prefix.dev server. Authentication is used from the keychain / auth-file.</p> <p>Parameters:</p> Name Type Description Default <code>package_files</code> <code>list[str]</code> <p>The package files to upload.</p> required <code>url</code> <code>str</code> <p>The URL to the prefix.dev server (only necessary for self-hosted instances).</p> required <code>channels</code> <code>str</code> <p>The channel to upload the package to.</p> required <code>api_key</code> <code>str | None</code> <p>The prefix.dev API key, if none is provided, the token is read from the keychain / auth-file.</p> <code>None</code> <code>auth_file</code> <code>str | Path | None</code> <p>The authentication file.</p> <code>None</code> <code>skip_existing</code> <code>bool</code> <p>Skip upload if package is existed.</p> <code>False</code> <code>force</code> <code>bool</code> <p>Whether to force overwrite existing packages.</p> <code>False</code> <code>generate_attestation</code> <code>bool</code> <p>Whether to generate an attestation for the uploaded packages.</p> <code>False</code> <code>attestation_file</code> <code>str | Path | None</code> <p>Path to an attestation file to upload along with the packages (note: only a single package can be uploaded when using this).</p> <code>None</code> <code>store_github_attestation</code> <code>bool</code> <p>Whether to store the GitHub attestation.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"py-rattler-build/reference/upload/#upload_package_to_anaconda","title":"<code>upload_package_to_anaconda</code>","text":"<p>Upload to an Anaconda.org server.</p> <p>Parameters:</p> Name Type Description Default <code>package_files</code> <code>list[str]</code> <p>The package files to upload.</p> required <code>owner</code> <code>str</code> <p>The owner of the Anaconda.org account.</p> required <code>channel</code> <code>list[str] | None</code> <p>The channels to upload the package to.</p> <code>None</code> <code>api_key</code> <code>str | None</code> <p>The Anaconda.org API key.</p> <code>None</code> <code>url</code> <code>str | None</code> <p>The URL to the Anaconda.org server.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Whether to force the upload.</p> <code>False</code> <code>auth_file</code> <code>str | Path | None</code> <p>The authentication file.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"py-rattler-build/reference/upload/#upload_packages_to_conda_forge","title":"<code>upload_packages_to_conda_forge</code>","text":"<p>Upload to conda forge.</p> <p>Parameters:</p> Name Type Description Default <code>package_files</code> <code>list[str | Path]</code> <p>The package files to upload.</p> required <code>staging_token</code> <code>str</code> <p>The staging token for conda forge.</p> required <code>feedstock</code> <code>str</code> <p>The feedstock repository.</p> required <code>feedstock_token</code> <code>str</code> <p>The feedstock token.</p> required <code>staging_channel</code> <code>str | None</code> <p>The staging channel for the upload.</p> <code>None</code> <code>anaconda_url</code> <code>str | None</code> <p>The URL to the Anaconda.org server.</p> <code>None</code> <code>validation_endpoint</code> <code>str | None</code> <p>The validation endpoint.</p> <code>None</code> <code>provider</code> <code>str | None</code> <p>The provider for the upload.</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>Whether to perform a dry run.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/","title":"Inspecting Built Packages","text":"<p>This tutorial teaches you how to work with built conda packages:</p> <ol> <li>Load packages from <code>.conda</code> or <code>.tar.bz2</code> files</li> <li>Inspect package metadata (name, version, dependencies)</li> <li>List all files contained in the package</li> <li>Discover and inspect embedded tests</li> <li>Run tests programmatically and capture results</li> <li>Rebuild packages to verify reproducibility</li> </ol> <p>Let's get started!</p> <pre><code>import json\nfrom pathlib import Path\n\nfrom rattler_build import Package, RenderConfig, Stage0Recipe, VariantConfig\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-1-build-a-package-with-tests","title":"Step 1: Build a Package with Tests","text":"<p>First, let's build a package that has embedded tests. We'll create a simple noarch Python package with: - A Python module - Package content checks</p> <pre><code># Define a recipe with multiple test types\ntest_recipe_yaml = \"\"\"\npackage:\n  name: test-demo-package\n  version: \"1.0.0\"\n\nbuild:\n  number: 0\n  noarch: python\n  script:\n    interpreter: python\n    content: |\n      import os\n      from pathlib import Path\n\n      prefix = Path(os.environ[\"PREFIX\"])\n\n      # Create a Python module (noarch packages use site-packages directly)\n      site_packages = prefix / \"site-packages\"\n      site_packages.mkdir(parents=True, exist_ok=True)\n\n      module_file = site_packages / \"demo_module.py\"\n      module_file.write_text('''\n\n      __version__ = \"1.0.0\"\n\n      def greet(name: str) -&gt; str:\n          return f\"Hello, {name}!\"\n\n      def add(a: int, b: int) -&gt; int:\n          return a + b\n      ''')\n      print(f\"Created module at {module_file}\")\n\nrequirements:\n  run:\n    - python\n\ntests:\n  # Test 1: Python import test (embedded in package)\n  - python:\n      imports:\n        - demo_module\n\n  # Test 2: Package contents check (runs at build time)\n  - package_contents:\n      files:\n        - site-packages/demo_module.py\nabout:\n  license: MIT\n\"\"\"\n\n# Parse and render the recipe\ndemo_recipe = Stage0Recipe.from_yaml(test_recipe_yaml)\ndemo_variants = VariantConfig()\ndemo_render = RenderConfig()\ndemo_results = demo_recipe.render(demo_variants, demo_render)\n\nprint(\"Recipe with Tests Created\")\nprint(\"=\" * 60)\nprint(f\"Package: {demo_recipe.package.name}\")\nprint(f\"Version: {demo_recipe.package.version}\")\n\n# Build the package (skip tests during build, we'll run them manually)\nprint(\"\\nBuilding package...\")\nvariant = demo_results[0]\nfrom rattler_build import ToolConfiguration\n\ntool_config = ToolConfiguration(test_strategy=\"skip\")\nbuild_result = variant.run_build(\n    tool_config=tool_config,\n)\n\nbuilt_package_path = build_result.packages[0]\nprint(f\"Built: {built_package_path}\")\n</code></pre> <pre><code>Recipe with Tests Created\n============================================================\nPackage: test-demo-package\nVersion: 1.0.0\n\nBuilding package...\nBuilt: /tmp/rattler_build_23t5w31f/output/noarch/test-demo-package-1.0.0-pyh4616a5c_0.conda\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-2-loading-a-package","title":"Step 2: Loading a Package","text":"<p>Use <code>Package.from_file()</code> to load a built package. This reads the package metadata without extracting the entire archive.</p> <pre><code># Load the package\npkg = Package.from_file(built_package_path)\n\nprint(\"Package Loaded Successfully!\")\nprint(\"=\" * 60)\nprint(f\"Path: {pkg.path}\")\nprint(f\"Type: {type(pkg).__name__}\")\nprint(f\"\\nString representation: {repr(pkg)}\")\n</code></pre> <pre><code>Package Loaded Successfully!\n============================================================\nPath: /tmp/rattler_build_23t5w31f/output/noarch/test-demo-package-1.0.0-pyh4616a5c_0.conda\nType: Package\n\nString representation: Package(test-demo-package-1.0.0-pyh4616a5c_0)\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-3-inspecting-package-metadata","title":"Step 3: Inspecting Package Metadata","text":"<p>The <code>Package</code> class provides direct access to all metadata from <code>index.json</code>:</p> <pre><code>print(\"Package Metadata\")\nprint(\"=\" * 60)\nprint(f\"Name:           {pkg.name}\")\nprint(f\"Version:        {pkg.version}\")\nprint(f\"Build string:   {pkg.build_string}\")\nprint(f\"Build number:   {pkg.build_number}\")\nprint(f\"Subdir:         {pkg.subdir}\")\nprint(f\"NoArch:         {pkg.noarch}\")\nprint(f\"License:        {pkg.license}\")\nprint(f\"Arch:           {pkg.arch}\")\nprint(f\"Platform:       {pkg.platform}\")\nprint(f\"Timestamp:      {pkg.timestamp}\")\n\nprint(\"\\nArchive Information\")\nprint(\"-\" * 40)\nprint(f\"Archive type:   {pkg.archive_type}\")\nprint(f\"Filename:       {pkg.filename}\")\n\nprint(\"\\nDependencies\")\nprint(\"-\" * 40)\nprint(\"Runtime dependencies (depends):\")\nfor dep in pkg.depends:\n    print(f\"  - {dep}\")\n\nprint(\"\\nConstraints (constrains):\")\nif pkg.constrains:\n    for constraint in pkg.constrains:\n        print(f\"  - {constraint}\")\nelse:\n    print(\"  (none)\")\n</code></pre> <pre><code>Package Metadata\n============================================================\nName:           test-demo-package\nVersion:        1.0.0\nBuild string:   pyh4616a5c_0\nBuild number:   0\nSubdir:         noarch\nNoArch:         python\nLicense:        MIT\nArch:           None\nPlatform:       None\nTimestamp:      2026-03-02 13:51:36.293000+00:00\n\nArchive Information\n----------------------------------------\nArchive type:   conda\nFilename:       test-demo-package-1.0.0-pyh4616a5c_0.conda\n\nDependencies\n----------------------------------------\nRuntime dependencies (depends):\n  - python\n\nConstraints (constrains):\n  (none)\n</code></pre> <pre><code># Convert to dictionary for programmatic access\nmetadata_dict = pkg.to_dict()\n\nprint(\"Metadata as Dictionary\")\nprint(\"=\" * 60)\n\nprint(json.dumps(metadata_dict, indent=2, default=str))\n</code></pre> <pre><code>Metadata as Dictionary\n============================================================\n{\n  \"name\": \"test-demo-package\",\n  \"version\": \"1.0.0\",\n  \"build_string\": \"pyh4616a5c_0\",\n  \"build_number\": 0,\n  \"subdir\": \"noarch\",\n  \"noarch\": \"python\",\n  \"depends\": [\n    \"python\"\n  ],\n  \"constrains\": [],\n  \"license\": \"MIT\",\n  \"license_family\": null,\n  \"timestamp\": \"2026-03-02 13:51:36.293000+00:00\",\n  \"arch\": null,\n  \"platform\": null,\n  \"path\": \"/tmp/rattler_build_23t5w31f/output/noarch/test-demo-package-1.0.0-pyh4616a5c_0.conda\",\n  \"archive_type\": \"conda\",\n  \"filename\": \"test-demo-package-1.0.0-pyh4616a5c_0.conda\"\n}\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-4-listing-package-contents","title":"Step 4: Listing Package Contents","text":"<p>The <code>files</code> property lists all files contained in the package (from <code>paths.json</code>):</p> <pre><code>print(\"Package Contents\")\nprint(\"=\" * 60)\n\nfiles = pkg.files\nprint(f\"Total files: {len(files)}\")\nprint(\"\\nAll files:\")\n\n# Group files by directory\nfrom collections import defaultdict\n\ndirs = defaultdict(list)\nfor f in files:\n    parts = f.split(\"/\")\n    if len(parts) &gt; 1:\n        dirs[parts[0]].append(f)\n    else:\n        dirs[\"(root)\"].append(f)\n\nfor dir_name, dir_files in sorted(dirs.items()):\n    print(f\"\\n  {dir_name}/\")\n    for f in sorted(dir_files):\n        print(f\"    {f}\")\n</code></pre> <pre><code>Package Contents\n============================================================\nTotal files: 1\n\nAll files:\n\n  site-packages/\n    site-packages/demo_module.py\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-5-discovering-embedded-tests","title":"Step 5: Discovering Embedded Tests","text":"<p>Packages built with rattler-build can include embedded tests in <code>info/tests/tests.yaml</code>. Let's inspect them:</p> <pre><code>print(\"Embedded Tests\")\nprint(\"=\" * 60)\nprint(f\"Number of tests: {pkg.test_count}\")\n\npkg_tests = pkg.tests\nfor test in pkg_tests:\n    print(f\"\\nTest {test.index}: {type(test).__name__}\")\n    print(\"-\" * 40)\n    print(f\"  Type: {type(test).__name__}\")\n    print(f\"  Index: {test.index}\")\n    print(f\"  Repr: {repr(test)}\")\n</code></pre> <pre><code>Embedded Tests\n============================================================\nNumber of tests: 1\n\nTest 0: PythonTest\n----------------------------------------\n  Type: PythonTest\n  Index: 0\n  Repr: PythonTest(imports=['demo_module'], pip_check=True)\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-6-inspecting-specific-test-types","title":"Step 6: Inspecting Specific Test Types","text":"<p>Each test type has specific properties. Use Python's pattern matching (3.10+) to handle different test types:</p> <pre><code>from rattler_build.package import PythonTest, CommandsTest, PackageContentsTest\n\nprint(\"Test Type Details\")\nprint(\"=\" * 60)\n\nfor test in pkg_tests:\n    print(f\"\\nTest {test.index}: {type(test).__name__}\")\n    print(\"-\" * 40)\n\n    match test:\n        case PythonTest() as py_test:\n            print(\"  Python Test:\")\n            print(f\"    Imports: {py_test.imports}\")\n            print(f\"    Pip check: {py_test.pip_check}\")\n            if py_test.python_version:\n                pv = py_test.python_version\n                if pv.is_none():\n                    print(\"    Python version: any\")\n                elif pv.as_single():\n                    print(f\"    Python version: {pv.as_single()}\")\n                elif pv.as_multiple():\n                    print(f\"    Python versions: {pv.as_multiple()}\")\n\n        case CommandsTest() as cmd_test:\n            print(\"  Commands Test:\")\n            print(f\"    Script: {cmd_test.script}\")\n            print(f\"    Run requirements: {cmd_test.requirements_run}\")\n            print(f\"    Build requirements: {cmd_test.requirements_build}\")\n\n        case PackageContentsTest() as pc_test:\n            print(\"  Package Contents Test:\")\n            print(f\"    Strict mode: {pc_test.strict}\")\n\n            sections = [\n                (\"files\", pc_test.files),\n                (\"site_packages\", pc_test.site_packages),\n                (\"bin\", pc_test.bin),\n                (\"lib\", pc_test.lib),\n                (\"include\", pc_test.include),\n            ]\n\n            for name, checks in sections:\n                if checks.exists or checks.not_exists:\n                    print(f\"    {name}:\")\n                    if checks.exists:\n                        print(f\"      exists: {checks.exists}\")\n                    if checks.not_exists:\n                        print(f\"      not_exists: {checks.not_exists}\")\n\n        case _:\n            print(f\"  Other test type: {type(test).__name__}\")\n</code></pre> <pre><code>Test Type Details\n============================================================\n\nTest 0: PythonTest\n----------------------------------------\n  Python Test:\n    Imports: ['demo_module']\n    Pip check: True\n    Python version: any\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-7-running-tests","title":"Step 7: Running Tests","text":"<p>Now let's run the tests! You can run individual tests by index or all tests at once:</p> <pre><code>print(\"Running Individual Tests\")\nprint(\"=\" * 60)\n\nfor i in range(pkg.test_count):\n    print(f\"\\nRunning test {i}...\")\n    result = pkg.run_test(i)\n\n    status = \"PASS\" if result.success else \"FAIL\"\n    print(f\"   {status}\")\n    print(f\"   Test index: {result.test_index}\")\n\n    if result.output:\n        print(f\"   Output ({len(result.output)} lines):\")\n        for line in result.output[:5]:  # Show first 5 lines\n            print(f\"     {line}\")\n        if len(result.output) &gt; 5:\n            print(f\"     ... and {len(result.output) - 5} more lines\")\n</code></pre> <pre><code>Running Individual Tests\n============================================================\n\nRunning test 0...\n   PASS\n   Test index: 0\n</code></pre> <pre><code>print(\"Running All Tests at Once\")\nprint(\"=\" * 60)\n\nall_results = pkg.run_tests()\n\nprint(f\"\\nTotal tests: {len(all_results)}\")\npassed = sum(1 for r in all_results if r.success)\nfailed = len(all_results) - passed\n\nprint(f\"Passed: {passed}\")\nprint(f\"Failed: {failed}\")\n\nprint(\"\\nResults summary:\")\nfor result in all_results:\n    status = \"PASS\" if result.success else \"FAIL\"\n    print(f\"  {status} Test {result.test_index}\")\n\n    # TestResult can be used as a boolean\n    if result:\n        print(\"     (result is truthy)\")\n    else:\n        print(\"     (result is falsy)\")\n</code></pre> <pre><code>Running All Tests at Once\n============================================================\n\nTotal tests: 1\nPassed: 1\nFailed: 0\n\nResults summary:\n  PASS Test 0\n     (result is truthy)\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-8-using-test-results","title":"Step 8: Using Test Results","text":"<p>The <code>TestResult</code> object provides: - <code>success</code>: Boolean indicating pass/fail - <code>test_index</code>: Which test was run - <code>output</code>: List of output/log lines - Can be used directly as a boolean in conditions</p> <pre><code>print(\"TestResult Properties\")\nprint(\"=\" * 60)\n\nfor result in all_results:\n    print(f\"\\nTest {result.test_index}:\")\n    print(f\"  success:    {result.success}\")\n    print(f\"  test_index: {result.test_index}\")\n    print(f\"  output:     {len(result.output)} lines\")\n    print(f\"  bool():     {bool(result)}\")\n    print(f\"  repr():     {repr(result)}\")\n\n# Example: Filter results\nprint(\"\\n\" + \"=\" * 60)\npassed_tests = [r for r in all_results if r]\nfailed_tests = [r for r in all_results if not r]\n\nprint(f\"Passed tests: {[r.test_index for r in passed_tests]}\")\nprint(f\"Failed tests: {[r.test_index for r in failed_tests]}\")\n</code></pre> <pre><code>TestResult Properties\n============================================================\n\nTest 0:\n  success:    True\n  test_index: 0\n  output:     0 lines\n  bool():     True\n  repr():     TestResult(index=0, status=PASS)\n\n============================================================\nPassed tests: [0]\nFailed tests: []\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-9-running-tests-with-custom-configuration","title":"Step 9: Running Tests with Custom Configuration","text":"<p>You can customize test execution with channels, authentication, and other options:</p> <pre><code>print(\"Test Configuration Options\")\nprint(\"=\" * 60)\n\nprint(\n    \"\"\"\nAvailable options for run_test() and run_tests():\n\n- channel: List[str]           # Channels to use for dependencies\n                               # e.g., [\"conda-forge\", \"defaults\"]\n\n- channel_priority: str        # \"disabled\", \"strict\", or \"flexible\"\n\n- debug: bool                  # Keep test environment for debugging\n                               # Default: False\n\n- auth_file: str | Path        # Path to authentication file\n\n- allow_insecure_host: List[str]  # Hosts to allow insecure connections\n\n- compression_threads: int     # Number of compression threads\n\n- use_bz2: bool               # Enable bz2 repodata (default: True)\n- use_zstd: bool              # Enable zstd repodata (default: True)\n- use_sharded: bool           # Enable sharded repodata (default: True)\n\"\"\"\n)\n\n# Example with custom channel\nprint(\"\\nExample: Running test with conda-forge channel:\")\nresult = pkg.run_test(\n    0,\n    channel=[\"conda-forge\"],\n    channel_priority=\"strict\",\n)\nprint(f\"  Result: {'PASS' if result.success else 'FAIL'}\")\n</code></pre> <pre><code>Test Configuration Options\n============================================================\n\nAvailable options for run_test() and run_tests():\n\n- channel: List[str]           # Channels to use for dependencies\n                               # e.g., [\"conda-forge\", \"defaults\"]\n\n- channel_priority: str        # \"disabled\", \"strict\", or \"flexible\"\n\n- debug: bool                  # Keep test environment for debugging\n                               # Default: False\n\n- auth_file: str | Path        # Path to authentication file\n\n- allow_insecure_host: List[str]  # Hosts to allow insecure connections\n\n- compression_threads: int     # Number of compression threads\n\n- use_bz2: bool               # Enable bz2 repodata (default: True)\n- use_zstd: bool              # Enable zstd repodata (default: True)\n- use_sharded: bool           # Enable sharded repodata (default: True)\n\n\nExample: Running test with conda-forge channel:\n  Result: PASS\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#step-10-rebuilding-packages","title":"Step 10: Rebuilding Packages","text":"<p>Conda packages built with rattler-build embed their recipe, allowing you to rebuild them from scratch. This is useful for verifying reproducibility - checking if a package can be rebuilt to produce identical output.</p> <p>The <code>rebuild()</code> method extracts the embedded recipe and rebuilds the package, then compares SHA256 hashes to verify if the builds are identical.</p> <pre><code>print(\"Rebuilding Package\")\nprint(\"=\" * 60)\n\n# Rebuild the package and compare hashes\nrebuild_result = pkg.rebuild(test=\"skip\")\n\nprint(f\"Original package: {rebuild_result.original_path}\")\nprint(f\"Rebuilt package:  {rebuild_result.rebuilt_path}\")\nprint()\nprint(f\"Original SHA256:  {rebuild_result.original_sha256}\")\nprint(f\"Rebuilt SHA256:   {rebuild_result.rebuilt_sha256}\")\nprint()\nprint(f\"Identical (reproducible): {rebuild_result.is_identical}\")\n</code></pre> <pre><code>Rebuilding Package\n============================================================\nOriginal package: /tmp/rattler_build_23t5w31f/output/noarch/test-demo-package-1.0.0-pyh4616a5c_0.conda\nRebuilt package:  output/test-demo-package-1.0.0-pyh4616a5c_0-rebuilt-20260302-135140.conda\n\nOriginal SHA256:  24bf7fb26d70f570d545d4e50d702a893d3f81d7d79632b8aa2b82d761f811f1\nRebuilt SHA256:   24bf7fb26d70f570d545d4e50d702a893d3f81d7d79632b8aa2b82d761f811f1\n\nIdentical (reproducible): True\n</code></pre> <p>The <code>RebuildResult</code> provides access to the rebuilt package for further inspection:</p> <pre><code># Access the rebuilt package for inspection\nrebuilt_pkg = rebuild_result.rebuilt_package\n\nprint(\"Rebuilt Package Details\")\nprint(\"=\" * 60)\nprint(f\"Name:         {rebuilt_pkg.name}\")\nprint(f\"Version:      {rebuilt_pkg.version}\")\nprint(f\"Build string: {rebuilt_pkg.build_string}\")\nprint(f\"Path:         {rebuilt_pkg.path}\")\nprint(f\"Files:        {len(rebuilt_pkg.files)} files\")\n</code></pre> <pre><code>Rebuilt Package Details\n============================================================\nName:         test-demo-package\nVersion:      1.0.0\nBuild string: pyh4616a5c_0\nPath:         output/test-demo-package-1.0.0-pyh4616a5c_0-rebuilt-20260302-135140.conda\nFiles:        1 files\n</code></pre>"},{"location":"py-rattler-build/tutorials/inspecting_built_packages/#summary","title":"Summary","text":"<p>In this tutorial, you learned how to:</p> <ul> <li>Load packages: Use <code>Package.from_file()</code> to load <code>.conda</code> or <code>.tar.bz2</code> files</li> <li>Inspect metadata: Access <code>name</code>, <code>version</code>, <code>depends</code>, <code>license</code>, etc.</li> <li>Archive information: Use <code>archive_type</code> and <code>filename</code> to get package format details</li> <li>List contents: Use <code>files</code> to see all files in the package</li> <li>Discover tests: Access <code>tests</code> to see embedded test definitions</li> <li>Inspect test types: Use pattern matching with <code>PythonTest</code>, <code>CommandsTest</code>, <code>PackageContentsTest</code>, etc.</li> <li>Run tests: Use <code>run_test(index)</code> or <code>run_tests()</code> to execute tests</li> <li>Handle results: <code>TestResult</code> provides <code>success</code>, <code>output</code>, and works as boolean</li> <li>Rebuild packages: Use <code>rebuild()</code> to verify reproducibility by comparing SHA256 hashes</li> </ul> <p>The Package API provides a complete interface for inspecting, testing, and rebuilding conda packages programmatically!</p>"},{"location":"py-rattler-build/tutorials/multi_output_and_staging/","title":"Multi-Output Recipes and Staging Caches","text":"<p>This tutorial teaches you about advanced recipe structures:</p> <ol> <li>Multi-output recipes - Build multiple packages from one source</li> <li>Staging outputs - Create temporary build artifacts</li> <li>Output inheritance - Reuse build configurations</li> <li>Inspecting Stage1 staging caches</li> <li>Variants with multi-output recipes</li> <li>Complete build pipeline visualization</li> </ol> <p>Let's get started!</p> <pre><code>import json\n\nfrom rattler_build import (\n    MultiOutputRecipe,\n    PlatformConfig,\n    RenderConfig,\n    Stage0Recipe,\n    VariantConfig,\n)\n</code></pre>"},{"location":"py-rattler-build/tutorials/multi_output_and_staging/#example-1-multi-output-with-inter-output-dependencies","title":"Example 1: Multi-Output with Inter-Output Dependencies","text":"<p>Multi-output recipes build multiple packages from one recipe. When one output needs another, you list it as a host (or build) dependency. The dependency package is installed into the build environment, and your build script can use its files.</p> <p>In this example: - <code>myproject-lib</code> creates a Python module - <code>myproject-tools</code> depends on <code>myproject-lib</code> as a host dependency and reads that file during its build</p> <pre><code># Multi-output recipe with inter-output dependency\nmulti_output_yaml = \"\"\"\nschema_version: 1\n\ncontext:\n  name: myproject\n  version: \"2.0.0\"\n\nrecipe:\n  version: ${{ version }}\n\noutputs:\n  # First output: The library\n  - package:\n      name: ${{ name }}-lib\n    build:\n      script:\n        interpreter: python\n        content: |\n          import os\n          from pathlib import Path\n\n          prefix = Path(os.environ[\"PREFIX\"])\n          lib_dir = prefix / \"lib\" / \"python\"\n          lib_dir.mkdir(parents=True, exist_ok=True)\n\n          (lib_dir / \"myproject_lib.py\").write_text('VERSION = \"2.0.0\"')\n          print(f\"Created library at {lib_dir}\")\n    requirements:\n      build:\n        - python\n\n  # Second output: Uses the library as a host dependency\n  - package:\n      name: ${{ name }}-tools\n    build:\n      script:\n        interpreter: python\n        content: |\n          import os\n          from pathlib import Path\n\n          prefix = Path(os.environ[\"PREFIX\"])\n\n          # Read and print the lib file (installed as host dependency)\n          lib_file = prefix / \"lib\" / \"python\" / \"myproject_lib.py\"\n          print(f\"Reading library from: {lib_file}\")\n          print(lib_file.read_text())\n    requirements:\n      build:\n        - python\n      host:\n        - ${{ name }}-lib\n\"\"\"\n\nmulti_recipe = Stage0Recipe.from_yaml(multi_output_yaml)\n\nprint(\"Multi-Output Recipe Loaded\")\nprint(\"=\" * 60)\nprint(f\"Recipe type: {type(multi_recipe).__name__}\")\nprint(f\"Is multi-output: {isinstance(multi_recipe, MultiOutputRecipe)}\")\nprint(f\"Number of outputs: {len(multi_recipe.outputs)}\")\n\nprint(\"\\nOutputs:\")\nfor idx, output in enumerate(multi_recipe.outputs, 1):\n    print(f\"  {idx}. {output.to_dict()['package']['name']}\")\n\n# Render the recipe\nmo_variants = VariantConfig()\nmo_render = RenderConfig()\nmo_results = multi_recipe.render(mo_variants, mo_render)\n\nprint(f\"\\nRendered {len(mo_results)} package(s):\")\nprint(\"=\" * 60)\n\nfor rendered in mo_results:\n    stage1 = rendered.recipe\n    print(f\"\\nPackage: {stage1.package.name} {stage1.package.version}\")\n    print(f\"   Build script: {stage1.build.script}\")\n    print(f\"   Run requirements: {stage1.requirements.run}\")\n</code></pre> <pre><code>Multi-Output Recipe Loaded\n============================================================\nRecipe type: MultiOutputRecipe\nIs multi-output: True\nNumber of outputs: 2\n\nOutputs:\n  1. ${{ name }}-lib\n  2. ${{ name }}-tools\n\nRendered 2 package(s):\n============================================================\n\nPackage: myproject-lib 2.0.0\n   Build script: {'interpreter': 'python', 'content': 'import os\\nfrom pathlib import Path\\n\\nprefix = Path(os.environ[\"PREFIX\"])\\nlib_dir = prefix / \"lib\" / \"python\"\\nlib_dir.mkdir(parents=True, exist_ok=True)\\n\\n(lib_dir / \"myproject_lib.py\").write_text(\\'VERSION = \"2.0.0\"\\')\\nprint(f\"Created library at {lib_dir}\")\\n'}\n   Run requirements: []\n\nPackage: myproject-tools 2.0.0\n   Build script: {'interpreter': 'python', 'content': 'import os\\nfrom pathlib import Path\\n\\nprefix = Path(os.environ[\"PREFIX\"])\\n\\n# Read and print the lib file (installed as host dependency)\\nlib_file = prefix / \"lib\" / \"python\" / \"myproject_lib.py\"\\nprint(f\"Reading library from: {lib_file}\")\\nprint(lib_file.read_text())\\n'}\n   Run requirements: []\n</code></pre> <pre><code># Build each variant\nprint(\"Building Example 1 packages...\")\nprint(\"=\" * 60)\nprint(f\"Recipe path: {multi_recipe.recipe_path}\")\n\nfor i, variant in enumerate(mo_results, 1):\n    print(f\"\\nBuilding variant {i}/{len(mo_results)}\")\n    stage1_recipe = variant.recipe\n    package = stage1_recipe.package\n    build = stage1_recipe.build\n\n    print(f\"  Package: {package.name}\")\n    print(f\"  Version: {package.version}\")\n    print(f\"  Build string: {build.string}\")\n\n    result = variant.run_build()\n\n    # Display build result information\n    print(f\"  Build complete in {result.build_time:.2f}s!\")\n    print(f\"  Package: {result.packages[0]}\")\n    if result.variant:\n        print(f\"  Variant: {result.variant}\")\n\n    # Display build log\n    if result.log:\n        print(f\"  Build log: {len(result.log)} messages captured\")\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Example 1 builds completed successfully!\")\nprint(f\"\\nBuilt packages are available in: {result.output_dir}\")\n</code></pre> <pre><code>Building Example 1 packages...\n============================================================\nRecipe path: /tmp/rattler_build_5u_b31dq/recipe.yaml\n\nBuilding variant 1/2\n  Package: myproject-lib\n  Version: 2.0.0\n  Build string: hb0f4dca_0\n\n\n  Build complete in 1.48s!\n  Package: /tmp/rattler_build_5u_b31dq/output/linux-64/myproject-lib-2.0.0-hb0f4dca_0.conda\n  Variant: {'target_platform': 'linux-64'}\n  Build log: 54 messages captured\n\nBuilding variant 2/2\n  Package: myproject-tools\n  Version: 2.0.0\n  Build string: hb0f4dca_0\n\n\n  Build complete in 1.44s!\n  Package: /tmp/rattler_build_5u_b31dq/output/linux-64/myproject-tools-2.0.0-hb0f4dca_0.conda\n  Variant: {'target_platform': 'linux-64'}\n  Build log: 55 messages captured\n\n============================================================\nExample 1 builds completed successfully!\n\nBuilt packages are available in: /tmp/rattler_build_5u_b31dq/output\n</code></pre>"},{"location":"py-rattler-build/tutorials/multi_output_and_staging/#example-2-staging-outputs-shared-build-artifacts","title":"Example 2: Staging Outputs - Shared Build Artifacts","text":"<p>Staging is different from regular dependencies (Example 1). A staging output runs its build script once, then copies its files directly into each inheriting package's prefix. Since these are \"new\" files in the prefix, they will be included in the final package.</p> <p>Use the <code>files</code> field to select which subset of files to include from the staging prefix.</p> <p>In this example: - <code>shared-build</code> staging creates both <code>/lib/shared.py</code> AND <code>/bin/tool.py</code> - <code>compiled-project-python</code> inherits and uses <code>files: [lib/**]</code> to only include lib files - <code>compiled-project-cli</code> inherits and uses <code>files: [bin/**]</code> to only include bin files</p> <pre><code># Recipe with staging output\nstaging_yaml = \"\"\"\nschema_version: 1\n\ncontext:\n  name: compiled-project\n  version: \"1.5.0\"\n\nrecipe:\n  version: ${{ version }}\n\noutputs:\n  # Staging output: Creates shared artifacts for multiple packages\n  - staging:\n      name: shared-build\n    build:\n      script:\n        interpreter: python\n        content: |\n          import os\n          from pathlib import Path\n\n          prefix = Path(os.environ[\"PREFIX\"])\n\n          # Create lib files\n          lib_dir = prefix / \"lib\"\n          lib_dir.mkdir(parents=True, exist_ok=True)\n          (lib_dir / \"shared.py\").write_text('SHARED_VERSION = \"1.5.0\"')\n          print(f\"Created shared library at {lib_dir}\")\n\n          # Create bin files\n          bin_dir = prefix / \"bin\"\n          bin_dir.mkdir(parents=True, exist_ok=True)\n          (bin_dir / \"tool.py\").write_text('#!/usr/bin/env python\\\\nprint(\"CLI tool\")')\n          print(f\"Created CLI tool at {bin_dir}\")\n    requirements:\n      build:\n        - python\n\n  # Package output 1: Python bindings (inherits lib files from staging)\n  - package:\n      name: ${{ name }}-python\n    inherit: shared-build\n    build:\n      files:\n        - lib/**\n\n  # Package output 2: CLI tool (inherits bin files from staging)\n  - package:\n      name: ${{ name }}-cli\n    inherit: shared-build\n    build:\n      files:\n        - bin/**\n\"\"\"\n\nstaging_recipe = Stage0Recipe.from_yaml(staging_yaml)\n\nprint(\"Recipe with Staging Output\")\nprint(\"=\" * 60)\nprint(f\"Total outputs defined: {len(staging_recipe.outputs)}\")\n\nprint(\"\\nOutput types:\")\nfor idx, output in enumerate(staging_recipe.outputs, 1):\n    output_dict = output.to_dict()\n    if \"staging\" in output_dict:\n        print(f\"  {idx}. Staging: {output_dict['staging']['name']}\")\n    elif \"package\" in output_dict:\n        pkg_name = output_dict[\"package\"][\"name\"]\n        inherits = output_dict.get(\"inherits_from\", None)\n        print(f\"  {idx}. Package: {pkg_name}\", end=\"\")\n        if inherits:\n            print(f\" (inherits from: {inherits})\")\n        else:\n            print()\n\n# Render the recipe\nstaging_variants = VariantConfig()\nplatform_config = PlatformConfig(experimental=True)  # Staging is still experimental\nstaging_render = RenderConfig(platform=platform_config)\nstaging_results = staging_recipe.render(staging_variants, staging_render)\n\nprint(f\"\\nRendered {len(staging_results)} package(s)\")\nprint(\"(Staging outputs don't produce packages)\")\nprint(\"=\" * 60)\n\nfor rendered in staging_results:\n    stage1 = rendered.recipe\n    print(f\"\\n{stage1.package.name} {stage1.package.version}\")\n\n    # Check for staging caches\n    if stage1.staging_caches:\n        print(f\"   Uses {len(stage1.staging_caches)} staging cache(s):\")\n        for cache in stage1.staging_caches:\n            print(f\"     - {cache.name}\")\n            print(f\"       Build script: {cache.build.script}\")\n\n    # Check inheritance\n    if stage1.inherits_from:\n        print(f\"   Inherits from: {json.dumps(stage1.inherits_from, indent=6)}\")\n</code></pre> <pre><code>Recipe with Staging Output\n============================================================\nTotal outputs defined: 3\n\nOutput types:\n  1. Staging: shared-build\n  2. Package: ${{ name }}-python\n  3. Package: ${{ name }}-cli\n\nRendered 2 package(s)\n(Staging outputs don't produce packages)\n============================================================\n\ncompiled-project-python 1.5.0\n   Uses 1 staging cache(s):\n     - shared-build\n       Build script: {'interpreter': 'python', 'content': 'import os\\nfrom pathlib import Path\\n\\nprefix = Path(os.environ[\"PREFIX\"])\\n\\n# Create lib files\\nlib_dir = prefix / \"lib\"\\nlib_dir.mkdir(parents=True, exist_ok=True)\\n(lib_dir / \"shared.py\").write_text(\\'SHARED_VERSION = \"1.5.0\"\\')\\nprint(f\"Created shared library at {lib_dir}\")\\n\\n# Create bin files\\nbin_dir = prefix / \"bin\"\\nbin_dir.mkdir(parents=True, exist_ok=True)\\n(bin_dir / \"tool.py\").write_text(\\'#!/usr/bin/env python\\\\nprint(\"CLI tool\")\\')\\nprint(f\"Created CLI tool at {bin_dir}\")\\n'}\n   Inherits from: {\n      \"cache_name\": \"shared-build\",\n      \"inherit_run_exports\": true\n}\n\ncompiled-project-cli 1.5.0\n   Uses 1 staging cache(s):\n     - shared-build\n       Build script: {'interpreter': 'python', 'content': 'import os\\nfrom pathlib import Path\\n\\nprefix = Path(os.environ[\"PREFIX\"])\\n\\n# Create lib files\\nlib_dir = prefix / \"lib\"\\nlib_dir.mkdir(parents=True, exist_ok=True)\\n(lib_dir / \"shared.py\").write_text(\\'SHARED_VERSION = \"1.5.0\"\\')\\nprint(f\"Created shared library at {lib_dir}\")\\n\\n# Create bin files\\nbin_dir = prefix / \"bin\"\\nbin_dir.mkdir(parents=True, exist_ok=True)\\n(bin_dir / \"tool.py\").write_text(\\'#!/usr/bin/env python\\\\nprint(\"CLI tool\")\\')\\nprint(f\"Created CLI tool at {bin_dir}\")\\n'}\n   Inherits from: {\n      \"cache_name\": \"shared-build\",\n      \"inherit_run_exports\": true\n}\n</code></pre> <pre><code># Build each variant\nprint(\"Building Example 2 packages (with staging)...\")\nprint(\"=\" * 60)\nprint(f\"Recipe path: {staging_recipe.recipe_path}\")\n\nfor i, variant in enumerate(staging_results, 1):\n    print(f\"\\nBuilding variant {i}/{len(staging_results)}\")\n    stage1_recipe = variant.recipe\n    package = stage1_recipe.package\n    build = stage1_recipe.build\n\n    print(f\"  Package: {package.name}\")\n    print(f\"  Version: {package.version}\")\n    print(f\"  Build string: {build.string}\")\n\n    if stage1_recipe.staging_caches:\n        print(f\"  Staging caches: {[c.name for c in stage1_recipe.staging_caches]}\")\n\n    result = variant.run_build()\n\n    # Display build result information\n    print(f\"  Build complete in {result.build_time:.2f}s!\")\n    print(f\"  Package: {result.packages[0]}\")\n    if result.variant:\n        print(f\"  Variant: {result.variant}\")\n\n    # Display build log\n    if result.log:\n        print(f\"  Build log: {len(result.log)} messages captured\")\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Example 2 builds completed successfully!\")\nprint(f\"\\nBuilt packages are available in: {result.output_dir}\")\n</code></pre> <pre><code>Building Example 2 packages (with staging)...\n============================================================\nRecipe path: /tmp/rattler_build_av8_bic7/recipe.yaml\n\nBuilding variant 1/2\n  Package: compiled-project-python\n  Version: 1.5.0\n  Build string: hb0f4dca_0\n  Staging caches: ['shared-build']\n  Build complete in 1.50s!\n  Package: /tmp/rattler_build_av8_bic7/output/linux-64/compiled-project-python-1.5.0-hb0f4dca_0.conda\n  Variant: {'target_platform': 'linux-64'}\n  Build log: 71 messages captured\n\nBuilding variant 2/2\n  Package: compiled-project-cli\n  Version: 1.5.0\n  Build string: hb0f4dca_0\n  Staging caches: ['shared-build']\n\n\n  Build complete in 1.48s!\n  Package: /tmp/rattler_build_av8_bic7/output/linux-64/compiled-project-cli-1.5.0-hb0f4dca_0.conda\n  Variant: {'target_platform': 'linux-64'}\n  Build log: 66 messages captured\n\n============================================================\nExample 2 builds completed successfully!\n\nBuilt packages are available in: /tmp/rattler_build_av8_bic7/output\n</code></pre>"},{"location":"py-rattler-build/tutorials/multi_output_and_staging/#summary","title":"Summary","text":"<p>In this tutorial, you learned about multi-output recipes and staging:</p> <ul> <li>Multi-Output Recipes: Build multiple packages from one recipe using the <code>outputs</code> list</li> <li>Staging Outputs: Create temporary build artifacts with <code>staging:</code> that other packages can inherit</li> </ul>"},{"location":"py-rattler-build/tutorials/package_assembly/","title":"Package Assembly","text":"<p>This tutorial teaches you how to create conda packages programmatically using the <code>assemble_package</code> function. This is useful when you already have files staged and want to package them directly, without going through the full recipe build process.</p>"},{"location":"py-rattler-build/tutorials/package_assembly/#when-to-use-assemble_package","title":"When to Use <code>assemble_package</code>","text":"<p>Use <code>assemble_package</code> when:</p> <ul> <li>You have files already compiled/staged and just need to package them</li> <li>You're building packages in a custom CI/CD pipeline</li> </ul> <p>For building from recipes, use <code>Stage0Recipe.from_yaml()</code> with <code>render()</code> and <code>run_build()</code> instead.</p> <pre><code>import tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\n\nfrom rattler_build import (\n    ArchiveType,\n    FileEntry,\n    assemble_package,\n    collect_files,\n)\n</code></pre>"},{"location":"py-rattler-build/tutorials/package_assembly/#example-1-minimal-package","title":"Example 1: Minimal Package","text":"<p>Let's create the simplest possible package - just a name, version, and some files:</p> <pre><code># Create temporary directories for our example\nwork_dir = Path(tempfile.mkdtemp())\nfiles_dir = work_dir / \"files\"\noutput_dir = work_dir / \"output\"\nfiles_dir.mkdir()\noutput_dir.mkdir()\n\n# Create some example files to package\n(files_dir / \"bin\").mkdir()\n(files_dir / \"bin\" / \"hello\").write_text(\"#!/bin/bash\\necho 'Hello, World!'\")\n\n# Create the package\noutput = assemble_package(\n    name=\"hello\",\n    version=\"1.0.0\",\n    target_platform=\"linux-64\",\n    build_string=\"0\",\n    output_dir=output_dir,\n    files_dir=files_dir,\n)\n\nprint(f\"Package created: {output.path.name}\")\nprint(f\"Identifier: {output.identifier}\")\n</code></pre> <pre><code>Package created: hello-1.0.0-0.conda\nIdentifier: hello-1.0.0-0\n</code></pre>"},{"location":"py-rattler-build/tutorials/package_assembly/#example-2-package-with-metadata","title":"Example 2: Package with Metadata","text":"<p>Add package metadata like license, homepage, and dependencies:</p> <pre><code># Create new directories\nfiles_dir2 = work_dir / \"files2\"\noutput_dir2 = work_dir / \"output2\"\nfiles_dir2.mkdir()\noutput_dir2.mkdir()\n\n# Create a Python package structure\n(files_dir2 / \"lib\" / \"python3.12\" / \"site-packages\" / \"mylib\").mkdir(parents=True)\n(files_dir2 / \"lib\" / \"python3.12\" / \"site-packages\" / \"mylib\" / \"__init__.py\").write_text(\n    '\"\"\"My library.\"\"\"\\n__version__ = \"2.0.0\"\\n'\n)\n\n# Create package with full metadata\noutput = assemble_package(\n    name=\"mylib\",\n    version=\"2.0.0\",\n    target_platform=\"linux-64\",\n    build_string=\"py312_0\",\n    output_dir=output_dir2,\n    files_dir=files_dir2,\n    # Metadata\n    homepage=\"https://github.com/example/mylib\",\n    license=\"MIT\",\n    license_family=\"MIT\",\n    summary=\"A demonstration library\",\n    description=\"This is a longer description of the library.\",\n    # Dependencies\n    depends=[\"python &gt;=3.12,&lt;3.13\", \"numpy &gt;=1.20\"],\n    constrains=[\"scipy &gt;=1.0\"],\n    build_number=0,\n)\n\nprint(f\"Package: {output.path.name}\")\nprint(f\"Identifier: {output.identifier}\")\n</code></pre> <pre><code>Package: mylib-2.0.0-py312_0.conda\nIdentifier: mylib-2.0.0-py312_0\n</code></pre>"},{"location":"py-rattler-build/tutorials/package_assembly/#example-3-collecting-files-with-glob-patterns","title":"Example 3: Collecting Files with Glob Patterns","text":"<p>For more control over which files to include, use <code>collect_files</code>:</p> <pre><code># Create a directory with mixed content\nmixed_dir = work_dir / \"mixed\"\nmixed_dir.mkdir()\n\n# Create various files\n(mixed_dir / \"src\").mkdir()\n(mixed_dir / \"src\" / \"main.py\").write_text(\"print('main')\")\n(mixed_dir / \"src\" / \"utils.py\").write_text(\"print('utils')\")\n(mixed_dir / \"src\" / \"__pycache__\").mkdir()\n(mixed_dir / \"src\" / \"__pycache__\" / \"main.cpython-312.pyc\").write_bytes(b\"bytecode\")\n(mixed_dir / \"tests\").mkdir()\n(mixed_dir / \"tests\" / \"test_main.py\").write_text(\"def test(): pass\")\n(mixed_dir / \"README.md\").write_text(\"# My Project\")\n\n# Use collect_files to select only Python source files, excluding pycache\nfiles = collect_files(\n    mixed_dir,\n    include_globs=[\"**/*.py\"],\n    exclude_globs=[\"**/__pycache__/**\", \"**/tests/**\"],\n)\n\nprint(\"Files selected:\")\nfor f in files:\n    print(f\"  {f.destination}\")\n\n# Now create a package with these files\noutput_dir3 = work_dir / \"output3\"\noutput_dir3.mkdir()\n\noutput = assemble_package(\n    name=\"filtered-pkg\",\n    version=\"1.0.0\",\n    target_platform=\"noarch\",\n    build_string=\"py_0\",\n    output_dir=output_dir3,\n    files=files,\n    noarch=\"python\",\n)\n\nprint(f\"\\nPackage: {output.path.name}\")\n</code></pre> <pre><code>Files selected:\n  src/main.py\n  src/utils.py\n\nPackage: filtered-pkg-1.0.0-py_0.conda\n</code></pre>"},{"location":"py-rattler-build/tutorials/package_assembly/#example-4-reproducible-builds-with-timestamps","title":"Example 4: Reproducible Builds with Timestamps","text":"<p>For reproducible builds, set a fixed timestamp:</p> <pre><code>import hashlib\n\n# Create simple files\nrepro_dir = work_dir / \"repro\"\nrepro_dir.mkdir()\n(repro_dir / \"data.txt\").write_text(\"Hello\")\n\noutput_dir4 = work_dir / \"output4\"\noutput_dir4.mkdir()\n\n# Fixed timestamp: 2024-01-01 00:00:00 UTC\nFIXED_TIMESTAMP = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)\n\n# Build twice with the same timestamp\noutput1 = assemble_package(\n    name=\"repro-test\",\n    version=\"1.0.0\",\n    target_platform=\"noarch\",\n    build_string=\"0\",\n    output_dir=output_dir4,\n    files_dir=repro_dir,\n    timestamp=FIXED_TIMESTAMP,\n    noarch=\"generic\",\n)\n\n# Rename first package to avoid overwrite\noutput1.path.rename(output_dir4 / \"first.conda\")\n\noutput2 = assemble_package(\n    name=\"repro-test\",\n    version=\"1.0.0\",\n    target_platform=\"noarch\",\n    build_string=\"0\",\n    output_dir=output_dir4,\n    files_dir=repro_dir,\n    timestamp=FIXED_TIMESTAMP,\n    noarch=\"generic\",\n)\n\n# Compare hashes\nhash1 = hashlib.sha256((output_dir4 / \"first.conda\").read_bytes()).hexdigest()[:16]\nhash2 = hashlib.sha256(output2.path.read_bytes()).hexdigest()[:16]\n\nprint(f\"First build hash:  {hash1}\")\nprint(f\"Second build hash: {hash2}\")\nprint(f\"Reproducible: {hash1 == hash2}\")\n</code></pre> <pre><code>First build hash:  34e60cd2d5ccde9a\nSecond build hash: 34e60cd2d5ccde9a\nReproducible: True\n</code></pre>"},{"location":"py-rattler-build/tutorials/package_assembly/#archive-formats","title":"Archive Formats","text":"<p>You can choose between <code>.conda</code> (modern, recommended) and <code>.tar.bz2</code> (legacy) formats:</p> <pre><code>print(\"Available archive types:\")\nprint(f\"  ArchiveType.Conda  -&gt; {ArchiveType.Conda.extension()}\")\nprint(f\"  ArchiveType.TarBz2 -&gt; {ArchiveType.TarBz2.extension()}\")\n\n# Create a .tar.bz2 package\noutput_dir5 = work_dir / \"output5\"\noutput_dir5.mkdir()\n\noutput = assemble_package(\n    name=\"legacy-format\",\n    version=\"1.0.0\",\n    target_platform=\"linux-64\",\n    build_string=\"0\",\n    output_dir=output_dir5,\n    files_dir=repro_dir,\n    archive_type=ArchiveType.TarBz2,\n)\n\nprint(f\"\\nCreated: {output.path.name}\")\n</code></pre> <pre><code>Available archive types:\n  ArchiveType.Conda  -&gt; .conda\n  ArchiveType.TarBz2 -&gt; .tar.bz2\n\nCreated: legacy-format-1.0.0-0.tar.bz2\n</code></pre>"},{"location":"py-rattler-build/tutorials/package_assembly/#summary","title":"Summary","text":"Function/Class Purpose <code>assemble_package()</code> Main function to create packages from files <code>collect_files()</code> Collect files with glob patterns <code>FileEntry</code> Represent a single file with source/destination paths <code>ArchiveType</code> Choose <code>.conda</code> or <code>.tar.bz2</code> format <code>PackageOutput</code> Result with <code>path</code> and <code>identifier</code>"},{"location":"py-rattler-build/tutorials/package_assembly/#key-parameters-for-assemble_package","title":"Key Parameters for <code>assemble_package()</code>","text":"<p>Required:</p> <ul> <li><code>name</code>, <code>version</code>, <code>target_platform</code>, <code>build_string</code>, <code>output_dir</code></li> <li>At least one of <code>files_dir</code> or <code>files</code></li> </ul> <p>Metadata (optional):</p> <ul> <li><code>homepage</code>, <code>license</code>, <code>license_family</code>, <code>summary</code>, <code>description</code></li> </ul> <p>Dependencies (optional):</p> <ul> <li><code>depends</code>, <code>constrains</code>, <code>build_number</code>, <code>noarch</code></li> </ul> <p>Build options (optional):</p> <ul> <li><code>compression_level</code> (0-9), <code>archive_type</code>, <code>timestamp</code> (datetime object), <code>detect_prefix</code></li> </ul>"},{"location":"py-rattler-build/tutorials/recipe_rendering_basics/","title":"Recipe Rendering Basics","text":"<p>Welcome to the rattler-build Python bindings tutorial! This tutorial will teach you how to:</p> <ol> <li>Load recipes from YAML strings and Python dictionaries</li> <li>Configure variants (different build configurations)</li> <li>Render recipes to produce fully evaluated build specifications</li> <li>Understand the difference between Stage0 (template) and Stage1 (evaluated) recipes</li> </ol> <p>Let's get started!</p> <pre><code>import json\nimport pprint\n\nimport yaml\n\nfrom rattler_build import (\n    MultiOutputRecipe,\n    PlatformConfig,\n    RenderConfig,\n    SingleOutputRecipe,\n    Stage0Recipe,\n    VariantConfig,\n)\n</code></pre>"},{"location":"py-rattler-build/tutorials/recipe_rendering_basics/#example-1-loading-a-simple-recipe-from-yaml","title":"Example 1: Loading a Simple Recipe from YAML","text":"<p>The most common way to define a recipe is using YAML format. Let's create a simple package recipe:</p> <pre><code># Define a simple recipe in YAML format with Jinja templates\nsimple_recipe_yaml = \"\"\"\npackage:\n  name: my-simple-package\n  version: \"1.0.0\"\n\nbuild:\n  number: 0\n  script:\n    - echo \"Building my package\"\n\nrequirements:\n  host:\n    - python ${{ python }}.*\n    - numpy ${{ numpy }}.*\n  run:\n    - python\n    - numpy &gt;=${{ numpy }}\n\nabout:\n  homepage: https://github.com/example/my-package\n  license: MIT\n  summary: A simple example package\n\"\"\"\n\n# Parse the YAML into a Stage0Recipe object\nsimple_recipe = Stage0Recipe.from_yaml(simple_recipe_yaml)\n\nprint(\"Recipe loaded successfully!\")\nprint(f\"Type: {type(simple_recipe).__name__}\")\nprint(f\"Is single output: {isinstance(simple_recipe, SingleOutputRecipe)}\")\nprint(f\"Is multi output: {isinstance(simple_recipe, MultiOutputRecipe)}\")\nprint(\"\\nRecipe structure (as dict):\")\nprint(json.dumps(simple_recipe.to_dict(), indent=2))\n</code></pre> <pre><code>Recipe loaded successfully!\nType: SingleOutputRecipe\nIs single output: True\nIs multi output: False\n\nRecipe structure (as dict):\n{\n  \"package\": {\n    \"name\": \"my-simple-package\",\n    \"version\": \"1.0.0\"\n  },\n  \"build\": {\n    \"number\": 0,\n    \"string\": null,\n    \"script\": {\n      \"content\": [\n        \"echo \\\"Building my package\\\"\"\n      ]\n    },\n    \"noarch\": null,\n    \"python\": {\n      \"entry_points\": [],\n      \"skip_pyc_compilation\": [],\n      \"use_python_app_entrypoint\": false,\n      \"site_packages_path\": null\n    },\n    \"skip\": [],\n    \"always_copy_files\": [],\n    \"always_include_files\": [],\n    \"merge_build_and_host_envs\": false,\n    \"files\": [],\n    \"dynamic_linking\": {\n      \"rpaths\": [],\n      \"binary_relocation\": true,\n      \"missing_dso_allowlist\": [],\n      \"rpath_allowlist\": [],\n      \"overdepending_behavior\": null,\n      \"overlinking_behavior\": null\n    },\n    \"variant\": {\n      \"use_keys\": [],\n      \"ignore_keys\": [],\n      \"down_prioritize_variant\": null\n    },\n    \"prefix_detection\": {\n      \"force_file_type\": {\n        \"text\": [],\n        \"binary\": []\n      },\n      \"ignore\": false,\n      \"ignore_binary_files\": false\n    },\n    \"post_process\": []\n  },\n  \"requirements\": {\n    \"host\": [\n      \"python ${{ python }}.*\",\n      \"numpy ${{ numpy }}.*\"\n    ],\n    \"run\": [\n      \"python\",\n      \"numpy &gt;=${{ numpy }}\"\n    ]\n  },\n  \"about\": {\n    \"homepage\": \"https://github.com/example/my-package\",\n    \"license\": \"MIT\",\n    \"license_family\": null,\n    \"summary\": \"A simple example package\",\n    \"description\": null,\n    \"documentation\": null,\n    \"repository\": null\n  },\n  \"extra\": {}\n}\n</code></pre>"},{"location":"py-rattler-build/tutorials/recipe_rendering_basics/#example-2-creating-a-recipe-from-a-python-dictionary","title":"Example 2: Creating a Recipe from a Python Dictionary","text":"<p>You can also create recipes from Python dictionaries. Let's verify that <code>Recipe.from_yaml()</code> and <code>Recipe.from_dict()</code> produce the same result when given the same data:</p> <pre><code># Parse the same YAML as a Python dictionary\nrecipe_dict = yaml.safe_load(simple_recipe_yaml)\n\n# Create Stage0Recipe from dictionary\ndict_recipe = Stage0Recipe.from_dict(recipe_dict)\n\nprint(\"Recipe created from dictionary!\")\n\n# Assert that both recipes are the same\nyaml_dict = simple_recipe.to_dict()\ndict_dict = dict_recipe.to_dict()\nassert yaml_dict == dict_dict, \"Recipes should be identical!\"\n\nprint(\"\\nBoth recipes are identical!\")\n</code></pre> <pre><code>Recipe created from dictionary!\n\nBoth recipes are identical!\n</code></pre>"},{"location":"py-rattler-build/tutorials/recipe_rendering_basics/#example-3-understanding-variantconfig-with-zip-keys","title":"Example 3: Understanding VariantConfig with Zip Keys","text":"<p>Variants allow you to build the same package with different configurations (e.g., different Python versions, compilers, or dependencies). By default, VariantConfig creates all possible combinations (Cartesian product), but we can use <code>zip_keys</code> to pair specific variants together:</p> <pre><code># Create a VariantConfig from a dictionary\nvariant_dict = {\n    \"python\": [\"3.9\", \"3.10\", \"3.11\"],\n    \"numpy\": [\"1.21\", \"1.22\", \"1.23\"],\n}\nvariant_config_without_zip = VariantConfig(variant_dict)\n\nprint(\"Variant Configuration\")\nprint(\"=\" * 60)\nprint(f\"Variant keys: {variant_config_without_zip.keys()}\")\nprint(f\"Python versions: {variant_config_without_zip.get_values('python')}\")\nprint(f\"Numpy versions: {variant_config_without_zip.get_values('numpy')}\")\n\nprint(\"\\nWITHOUT zip_keys (Cartesian product):\")\nprint(f\"Total combinations: {len(variant_config_without_zip.combinations())} (3 x 3)\")\nprint(\"\\nAll possible combinations:\")\npprint.pprint(variant_config_without_zip.combinations())\n\n# Create a new VariantConfig with zip_keys (python and numpy zipped together by index)\nvariant_config = VariantConfig(variant_dict, zip_keys=[[\"python\", \"numpy\"]])\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"WITH zip_keys (paired by index):\")\nprint(f\"Zip keys: {variant_config.zip_keys}\")\nprint(f\"Total combinations: {len(variant_config.combinations())} (paired)\")\nprint(\"\\nPaired combinations:\")\npprint.pprint(variant_config.combinations())\n\nprint(\"\\nVariant config as dict:\")\nprint(json.dumps(variant_config.to_dict(), indent=2))\n</code></pre> <pre><code>Variant Configuration\n============================================================\nVariant keys: ['numpy', 'python']\nPython versions: ['3.9', '3.10', '3.11']\nNumpy versions: ['1.21', '1.22', '1.23']\n\nWITHOUT zip_keys (Cartesian product):\nTotal combinations: 9 (3 x 3)\n\nAll possible combinations:\n[{'numpy': '1.21', 'python': '3.10'},\n {'numpy': '1.21', 'python': '3.11'},\n {'numpy': '1.21', 'python': '3.9'},\n {'numpy': '1.22', 'python': '3.10'},\n {'numpy': '1.22', 'python': '3.11'},\n {'numpy': '1.22', 'python': '3.9'},\n {'numpy': '1.23', 'python': '3.10'},\n {'numpy': '1.23', 'python': '3.11'},\n {'numpy': '1.23', 'python': '3.9'}]\n\n============================================================\nWITH zip_keys (paired by index):\nZip keys: [['python', 'numpy']]\nTotal combinations: 3 (paired)\n\nPaired combinations:\n[{'numpy': '1.21', 'python': '3.9'},\n {'numpy': '1.22', 'python': '3.10'},\n {'numpy': '1.23', 'python': '3.11'}]\n\nVariant config as dict:\n{\n  \"numpy\": [\n    \"1.21\",\n    \"1.22\",\n    \"1.23\"\n  ],\n  \"python\": [\n    \"3.9\",\n    \"3.10\",\n    \"3.11\"\n  ]\n}\n</code></pre>"},{"location":"py-rattler-build/tutorials/recipe_rendering_basics/#example-4-renderconfig-controlling-the-build-environment","title":"Example 4: RenderConfig - Controlling the Build Environment","text":"<p>RenderConfig lets you specify the target platform and add custom context variables for recipe rendering:</p> <pre><code># Create a render config with custom settings\nplatform_config = PlatformConfig(\n    target_platform=\"linux-64\",\n    build_platform=\"linux-64\",\n    host_platform=\"linux-64\",\n    experimental=False,\n)\nrender_config = RenderConfig(\n    platform=platform_config,\n    extra_context={\n        \"custom_var\": \"custom_value\",\n        \"build_timestamp\": \"2024-01-01\",\n        \"my_number\": 42,\n    },\n)\n\nprint(\"Render Configuration\")\nprint(\"=\" * 60)\nprint(f\"Target platform: {render_config.target_platform}\")\nprint(f\"Build platform: {render_config.build_platform}\")\nprint(f\"Host platform: {render_config.host_platform}\")\nprint(f\"Experimental: {render_config.experimental}\")\nprint(\"\\nCustom context variables:\")\nprint(json.dumps(render_config.get_all_context(), indent=2))\n</code></pre> <pre><code>Render Configuration\n============================================================\nTarget platform: linux-64\nBuild platform: linux-64\nHost platform: linux-64\nExperimental: False\n\nCustom context variables:\n{\n  \"custom_var\": \"custom_value\",\n  \"build_timestamp\": \"2024-01-01\",\n  \"my_number\": 42\n}\n</code></pre>"},{"location":"py-rattler-build/tutorials/recipe_rendering_basics/#example-5-rendering-recipe-with-variants","title":"Example 5: Rendering Recipe with Variants","text":"<p>Now let's put it all together! We'll use the recipe from Example 1, the variant config from Example 3, and the render config from Example 4 to render our recipe with multiple variants.</p> <p>Stage0 is the parsed recipe with Jinja templates still intact (e.g., <code>${{ python }}</code>). Stage1 is the fully evaluated recipe with all templates resolved to actual values.</p> <pre><code># Render the recipe with all the configurations we've created\nrendered_variants = simple_recipe.render(variant_config, render_config)\n\nprint(\"STAGE 0 (Parsed, templates intact)\")\nprint(\"=\" * 60)\nprint(f\"Package name (raw): {simple_recipe.package.name}\")\nprint(f\"Package version (raw): {simple_recipe.package.version}\")\nprint(f\"Host requirements (raw): {simple_recipe.requirements.host}\")\n\nprint(f\"\\nRendered {len(rendered_variants)} variant(s)\")\nprint(\"=\" * 60)\n\nfor i, rendered_variant in enumerate(rendered_variants, 1):\n    variant_values = rendered_variant.variant\n    stage1_recipe = rendered_variant.recipe\n\n    print(f\"\\nSTAGE 1 - Variant {i} (Rendered, templates evaluated)\")\n    print(\"-\" * 60)\n    print(f\"  Variant config: {json.dumps(variant_values, indent=4)}\")\n    print(f\"  Package name: {stage1_recipe.package.name}\")\n    print(f\"  Package version: {stage1_recipe.package.version}\")\n    print(f\"  Python: {variant_values.get('python')}\")\n    print(f\"  Numpy: {variant_values.get('numpy')}\")\n    print(f\"  Host requirements: {stage1_recipe.requirements.host}\")\n    print(f\"  Run requirements: {stage1_recipe.requirements.run}\")\n    print(f\"  Build string: {stage1_recipe.build.string}\")\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Recipe rendering complete!\")\n</code></pre> <pre><code>STAGE 0 (Parsed, templates intact)\n============================================================\nPackage name (raw): my-simple-package\nPackage version (raw): 1.0.0\nHost requirements (raw): ['python ${{ python }}.*', 'numpy ${{ numpy }}.*']\n\nRendered 3 variant(s)\n============================================================\n\nSTAGE 1 - Variant 1 (Rendered, templates evaluated)\n------------------------------------------------------------\n  Variant config: {\n    \"numpy\": \"1.21\",\n    \"python\": \"3.9\",\n    \"target_platform\": \"linux-64\"\n}\n  Package name: my-simple-package\n  Package version: 1.0.0\n  Python: 3.9\n  Numpy: 1.21\n  Host requirements: ['python 3.9.*', 'numpy 1.21.*']\n  Run requirements: ['python', 'numpy &gt;=1.21']\n  Build string: np121py39h13fef27_0\n\nSTAGE 1 - Variant 2 (Rendered, templates evaluated)\n------------------------------------------------------------\n  Variant config: {\n    \"numpy\": \"1.22\",\n    \"python\": \"3.10\",\n    \"target_platform\": \"linux-64\"\n}\n  Package name: my-simple-package\n  Package version: 1.0.0\n  Python: 3.10\n  Numpy: 1.22\n  Host requirements: ['python 3.10.*', 'numpy 1.22.*']\n  Run requirements: ['python', 'numpy &gt;=1.22']\n  Build string: np122py310h27bf20f_0\n\nSTAGE 1 - Variant 3 (Rendered, templates evaluated)\n------------------------------------------------------------\n  Variant config: {\n    \"numpy\": \"1.23\",\n    \"python\": \"3.11\",\n    \"target_platform\": \"linux-64\"\n}\n  Package name: my-simple-package\n  Package version: 1.0.0\n  Python: 3.11\n  Numpy: 1.23\n  Host requirements: ['python 3.11.*', 'numpy 1.23.*']\n  Run requirements: ['python', 'numpy &gt;=1.23']\n  Build string: np123py311hadc6f11_0\n\n============================================================\nRecipe rendering complete!\n</code></pre>"},{"location":"py-rattler-build/tutorials/recipe_rendering_basics/#example-6-building-the-package","title":"Example 6: Building the Package","text":"<p>Finally, let's actually build the package! We'll take the rendered variants and build them into conda packages:</p> <pre><code># Build each variant\nprint(\"Building packages...\")\nprint(\"=\" * 60)\nprint(f\"Recipe path: {simple_recipe.recipe_path}\")\n\nfor i, variant in enumerate(rendered_variants, 1):\n    print(f\"\\nBuilding variant {i}/{len(rendered_variants)}\")\n    stage1_recipe = variant.recipe\n    package = stage1_recipe.package\n    build = stage1_recipe.build\n\n    print(f\"  Package: {package.name}\")\n    print(f\"  Version: {package.version}\")\n    print(f\"  Build string: {build.string}\")\n\n    result = variant.run_build()\n\n    # Display build result information\n    print(f\"  Build complete in {result.build_time:.2f}s!\")\n    print(f\"  Package: {result.packages[0]}\")\n    if result.variant:\n        print(f\"  Variant: {result.variant}\")\n\n    # Display build log\n    if result.log:\n        print(f\"  Build log: {len(result.log)} messages captured\")\n        print(\"\\n  Build log details:\")\n        for log_entry in result.log[:10]:  # Show first 10 log entries\n            print(f\"    {log_entry}\")\n        if len(result.log) &gt; 10:\n            print(f\"    ... and {len(result.log) - 10} more messages\")\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"All builds completed successfully!\")\nprint(f\"\\nBuilt packages are available in: {result.output_dir}\")\n</code></pre> <pre><code>Building packages...\n============================================================\nRecipe path: /tmp/rattler_build_bqkabwty/recipe.yaml\n\nBuilding variant 1/3\n  Package: my-simple-package\n  Version: 1.0.0\n  Build string: np121py39h13fef27_0\n\n\n  Build complete in 2.76s!\n  Package: /tmp/rattler_build_bqkabwty/output/linux-64/my-simple-package-1.0.0-np121py39h13fef27_0.conda\n  Variant: {'python': '3.9', 'numpy': '1.21', 'target_platform': 'linux-64'}\n  Build log: 52 messages captured\n\n  Build log details:\n    Starting build of 1 outputs\n    No sources to fetch\n    Could not find noarch/repodata.json. Creating new one.\n    Adding 0 packages to subdir noarch.\n    Successfully added 0 packages to subdir noarch.\n    Writing repodata to noarch/repodata.json\n    Could not find linux-64/repodata.json. Creating new one.\n    Adding 0 packages to subdir linux-64.\n    Successfully added 0 packages to subdir linux-64.\n    Writing repodata to linux-64/repodata.json\n    ... and 42 more messages\n\nBuilding variant 2/3\n  Package: my-simple-package\n  Version: 1.0.0\n  Build string: np122py310h27bf20f_0\n\n\n  Build complete in 2.57s!\n  Package: /tmp/rattler_build_bqkabwty/output/linux-64/my-simple-package-1.0.0-np122py310h27bf20f_0.conda\n  Variant: {'numpy': '1.22', 'target_platform': 'linux-64', 'python': '3.10'}\n  Build log: 47 messages captured\n\n  Build log details:\n    Starting build of 1 outputs\n    No sources to fetch\n    Adding 0 packages to subdir linux-64.\n    Successfully added 0 packages to subdir linux-64.\n    Writing repodata to linux-64/repodata.json\n\nResolving host environment:\n\n      Platform: linux-64 \u001b[2m[__unix=0=0, __linux=6.14.0=0, __glibc=2.39=0, __archspec=1=zen2]\u001b[0m\n      Channels: \n       - file:///tmp/rattler_build_bqkabwty/output/\n       - conda-forge\n    ... and 37 more messages\n\nBuilding variant 3/3\n  Package: my-simple-package\n  Version: 1.0.0\n  Build string: np123py311hadc6f11_0\n  Build complete in 2.26s!\n  Package: /tmp/rattler_build_bqkabwty/output/linux-64/my-simple-package-1.0.0-np123py311hadc6f11_0.conda\n  Variant: {'python': '3.11', 'target_platform': 'linux-64', 'numpy': '1.23'}\n  Build log: 47 messages captured\n\n  Build log details:\n    Starting build of 1 outputs\n    No sources to fetch\n    Adding 0 packages to subdir linux-64.\n    Successfully added 0 packages to subdir linux-64.\n    Writing repodata to linux-64/repodata.json\n\nResolving host environment:\n\n      Platform: linux-64 \u001b[2m[__unix=0=0, __linux=6.14.0=0, __glibc=2.39=0, __archspec=1=zen2]\u001b[0m\n      Channels: \n       - file:///tmp/rattler_build_bqkabwty/output/\n       - conda-forge\n    ... and 37 more messages\n\n============================================================\nAll builds completed successfully!\n\nBuilt packages are available in: /tmp/rattler_build_bqkabwty/output\n</code></pre>"},{"location":"py-rattler-build/tutorials/recipe_rendering_basics/#summary","title":"Summary","text":"<p>In this tutorial, you learned:</p> <ul> <li>Recipe Creation: Load recipes from YAML strings (<code>Stage0Recipe.from_yaml()</code>) or Python dicts (<code>Stage0Recipe.from_dict()</code>)</li> <li>VariantConfig: Define build variants and use <code>zip_keys</code> to pair specific combinations</li> <li>RenderConfig: Configure target platforms and add custom context variables</li> <li>Stage0 vs Stage1: Understand the difference between parsed templates and evaluated recipes</li> <li>Rendering: Use <code>recipe.render()</code> to transform Stage0 -&gt; Stage1 with variants</li> <li>Building: Use <code>variant.run_build()</code> to build conda packages, which returns a <code>BuildResult</code> with package paths, metadata, timing information, and captured build logs</li> </ul>"},{"location":"reference/cli/","title":"Command-Line Help for <code>rattler-build</code>","text":"<p>This document contains the help content for the <code>rattler-build</code> command-line program.</p>"},{"location":"reference/cli/#rattler-build","title":"<code>rattler-build</code>","text":"<p>Usage: <code>rattler-build [OPTIONS] [COMMAND]</code></p>"},{"location":"reference/cli/#subcommands","title":"Subcommands:","text":"<ul> <li><code>build</code> \u2014 Build a package from a recipe</li> <li><code>publish</code> \u2014 Publish packages to a channel. This command builds packages from recipes (or uses already built packages), uploads them to a channel, and runs indexing</li> <li><code>test</code> \u2014 Run a test for a single package</li> <li><code>rebuild</code> \u2014 Rebuild a package from a package file instead of a recipe</li> <li><code>upload</code> \u2014 Upload a package</li> <li><code>completion</code> \u2014 Generate shell completion script</li> <li><code>generate-recipe</code> \u2014 Generate a recipe from PyPI, CRAN, CPAN, or LuaRocks</li> <li><code>auth</code> \u2014 Handle authentication to external channels</li> <li><code>debug</code> \u2014 Debug a recipe build</li> <li><code>package</code> \u2014 Package-related subcommands</li> <li><code>bump-recipe</code> \u2014 Bump a recipe to a new version</li> <li><code>migrate-recipe</code> \u2014 Migrate a recipe from the deprecated <code>cache:</code> format to <code>staging:</code> outputs</li> </ul>"},{"location":"reference/cli/#options","title":"Options:","text":"<ul> <li> <p><code>-v</code>, <code>--verbose</code></p> <p>Increase logging verbosity</p> </li> <li> <p><code>-q</code>, <code>--quiet</code></p> <p>Decrease logging verbosity</p> </li> <li> <p><code>--log-style &lt;LOG_STYLE&gt;</code></p> <p>Logging style</p> <ul> <li>Default value: <code>fancy</code></li> <li>Possible values:<ul> <li><code>fancy</code>:     Use fancy logging output</li> <li><code>json</code>:     Use JSON logging output</li> <li><code>plain</code>:     Use plain logging output</li> <li><code>simple</code>:     Use simple logging output (colored, no box-drawing frames)</li> </ul> </li> </ul> </li> <li> <p><code>--wrap-log-lines &lt;WRAP_LOG_LINES&gt;</code></p> <p>Wrap log lines at the terminal width. This is automatically disabled on CI (by detecting the <code>CI</code> environment variable)</p> <ul> <li>Possible values: <code>true</code>, <code>false</code></li> </ul> </li> <li> <p><code>--config-file &lt;CONFIG_FILE&gt;</code></p> <p>The rattler-build configuration file to use</p> </li> <li> <p><code>--color &lt;COLOR&gt;</code></p> <p>Enable or disable colored output from rattler-build. Also honors the <code>CLICOLOR</code> and <code>CLICOLOR_FORCE</code> environment variable</p> <ul> <li>Default value: <code>auto</code></li> <li>Possible values:<ul> <li><code>always</code>:     Always use colors</li> <li><code>never</code>:     Never use colors</li> <li><code>auto</code>:     Use colors when the output is a terminal</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/cli/#build","title":"<code>build</code>","text":"<p>Build a package from a recipe</p> <p>Usage: <code>rattler-build build [OPTIONS]</code></p>"},{"location":"reference/cli/#options_1","title":"Options:","text":"<ul> <li> <p><code>-r</code>, <code>--recipe &lt;RECIPES&gt;</code></p> <p>The recipe file or directory containing <code>recipe.yaml</code>. Defaults to the current directory</p> <ul> <li>Default value: <code>.</code></li> </ul> </li> <li> <p><code>--recipe-dir &lt;RECIPE_DIR&gt;</code></p> <p>The directory that contains recipes</p> </li> <li> <p><code>--up-to &lt;UP_TO&gt;</code></p> <p>Build recipes up to the specified package</p> </li> <li> <p><code>--build-platform &lt;BUILD_PLATFORM&gt;</code></p> <p>The build platform to use for the build (e.g. for building with emulation, or rendering)</p> </li> <li> <p><code>--target-platform &lt;TARGET_PLATFORM&gt;</code></p> <p>The target platform for the build</p> </li> <li> <p><code>--host-platform &lt;HOST_PLATFORM&gt;</code></p> <p>The host platform for the build. If set, it will be used to determine also the target_platform (as long as it is not noarch)</p> </li> <li> <p><code>-c</code>, <code>--channel &lt;CHANNELS&gt;</code></p> <p>Add a channel to search for dependencies in</p> </li> <li> <p><code>-m</code>, <code>--variant-config &lt;VARIANT_CONFIG&gt;</code></p> <p>Variant configuration files for the build</p> </li> <li> <p><code>--variant &lt;VARIANT_OVERRIDES&gt;</code></p> <p>Override specific variant values (e.g. --variant python=3.12 or --variant python=3.12,3.11). Multiple values separated by commas will create multiple build variants</p> </li> <li> <p><code>--ignore-recipe-variants</code></p> <p>Do not read the <code>variants.yaml</code> file next to a recipe</p> </li> <li> <p><code>--render-only</code></p> <p>Render the recipe files without executing the build</p> </li> <li> <p><code>--with-solve</code></p> <p>Render the recipe files with solving dependencies</p> </li> <li> <p><code>--keep-build</code></p> <p>Keep intermediate build artifacts after the build</p> </li> <li> <p><code>--no-build-id</code></p> <p>Don't use build id(timestamp) when creating build directory name</p> </li> <li> <p><code>--compression-threads &lt;COMPRESSION_THREADS&gt;</code></p> <p>The number of threads to use for compression (only relevant when also using <code>--package-format conda</code>)</p> </li> <li> <p><code>--io-concurrency-limit &lt;IO_CONCURRENCY_LIMIT&gt;</code></p> <p>The maximum number of concurrent I/O operations to use when installing packages This can be controlled by the <code>RATTLER_IO_CONCURRENCY_LIMIT</code> environment variable Defaults to 8 times the number of CPUs</p> </li> <li> <p><code>--experimental</code></p> <p>Enable experimental features</p> </li> <li> <p><code>--allow-insecure-host &lt;ALLOW_INSECURE_HOST&gt;</code></p> <p>List of hosts for which SSL certificate verification should be skipped</p> </li> <li> <p><code>--channel-priority &lt;CHANNEL_PRIORITY&gt;</code></p> <p>Channel priority to use when solving</p> </li> <li> <p><code>--extra-meta &lt;EXTRA_META&gt;</code></p> <p>Extra metadata to include in about.json</p> </li> <li> <p><code>--continue-on-failure</code></p> <p>Continue building even if (one) of the packages fails to build. This is useful when building many packages with <code>--recipe-dir</code>.`</p> </li> </ul>"},{"location":"reference/cli/#modifying-result","title":"Modifying result","text":"<ul> <li> <p><code>--package-format &lt;PACKAGE_FORMAT&gt;</code></p> <p>The package format to use for the build. Can be one of <code>tar-bz2</code> or <code>conda</code>. You can also add a compression level to the package format, e.g. <code>tar-bz2:&lt;number&gt;</code> (from 1 to 9) or <code>conda:&lt;number&gt;</code> (from -7 to 22).</p> </li> <li> <p><code>--no-include-recipe</code></p> <p>Don't store the recipe in the final package</p> </li> <li> <p><code>--test &lt;TEST&gt;</code></p> <p>The strategy to use for running tests</p> <ul> <li>Possible values:<ul> <li><code>skip</code>:     Skip the tests</li> <li><code>native</code>:     Run the tests only if the build platform is the same as the host platform. Otherwise, skip the tests. If the target platform is noarch, the tests are always executed</li> <li><code>native-and-emulated</code>:     Always run the tests</li> </ul> </li> </ul> </li> <li> <p><code>--color-build-log</code></p> <p>Don't force colors in the output of the build script</p> </li> <li> <p><code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory for build artifacts.</p> </li> <li> <p><code>--skip-existing &lt;SKIP_EXISTING&gt;</code></p> <p>Whether to skip packages that already exist in any channel If set to <code>none</code>, do not skip any packages, default when not specified. If set to <code>local</code>, only skip packages that already exist locally, default when using <code>--skip-existing. If set to</code>all`, skip packages that already exist in any channel</p> <ul> <li>Possible values:<ul> <li><code>none</code>:     Do not skip any packages</li> <li><code>local</code>:     Skip packages that already exist locally</li> <li><code>all</code>:     Skip packages that already exist in any channel</li> </ul> </li> </ul> </li> <li> <p><code>--noarch-build-platform &lt;NOARCH_BUILD_PLATFORM&gt;</code></p> <p>Define a \"noarch platform\" for which the noarch packages will be built for. The noarch builds will be skipped on the other platforms</p> </li> <li> <p><code>--debug</code></p> <p>Enable debug output in build scripts</p> </li> <li> <p><code>--markdown-summary &lt;MARKDOWN_SUMMARY&gt;</code></p> <p>Write a markdown summary to the specified file (appends to the file). Useful for generating PR comments or custom reports</p> </li> <li> <p><code>--error-prefix-in-binary</code></p> <p>Error if the host prefix is detected in any binary files</p> </li> <li> <p><code>--allow-symlinks-on-windows</code></p> <p>Allow symlinks in packages on Windows (defaults to false - symlinks are forbidden on Windows)</p> </li> <li> <p><code>--exclude-newer &lt;EXCLUDE_NEWER&gt;</code></p> <p>Exclude packages newer than this date from the solver, in RFC3339 format (e.g. 2024-03-15T12:00:00Z)</p> </li> <li> <p><code>--build-num &lt;BUILD_NUM&gt;</code></p> <p>Override the build number for all outputs (defaults to the build number in the recipe)</p> </li> </ul>"},{"location":"reference/cli/#sandbox-arguments","title":"Sandbox arguments","text":"<ul> <li> <p><code>--sandbox</code></p> <p>Enable the sandbox</p> </li> <li> <p><code>--allow-network</code></p> <p>Allow network access during build (default: false if sandbox is enabled)</p> </li> <li> <p><code>--allow-read &lt;ALLOW_READ&gt;</code></p> <p>Allow read access to the specified paths</p> </li> <li> <p><code>--allow-read-execute &lt;ALLOW_READ_EXECUTE&gt;</code></p> <p>Allow read and execute access to the specified paths</p> </li> <li> <p><code>--allow-read-write &lt;ALLOW_READ_WRITE&gt;</code></p> <p>Allow read and write access to the specified paths</p> </li> <li> <p><code>--overwrite-default-sandbox-config</code></p> <p>Overwrite the default sandbox configuration</p> </li> </ul>"},{"location":"reference/cli/#publish","title":"<code>publish</code>","text":"<p>Publish packages to a channel. This command builds packages from recipes (or uses already built packages), uploads them to a channel, and runs indexing</p> <p>Usage: <code>rattler-build publish [OPTIONS] --to &lt;TO&gt; [PACKAGE_OR_RECIPE]...</code></p>"},{"location":"reference/cli/#arguments","title":"Arguments:","text":"<ul> <li> <p><code>&lt;PACKAGE_OR_RECIPE&gt;</code></p> <p>Package files (.conda, .tar.bz2) to publish directly, or recipe files (*.yaml) to build and publish. If .conda or .tar.bz2 files are provided, they will be published directly without building. If .yaml files are provided, they will be built first, then published. Use --recipe-dir (from build options below) to scan a directory for recipes instead. Defaults to \"recipe.yaml\" in the current directory if not specified</p> <ul> <li>Default value: <code>recipe.yaml</code></li> </ul> </li> </ul>"},{"location":"reference/cli/#options_2","title":"Options:","text":"<ul> <li> <p><code>-r</code>, <code>--recipe &lt;RECIPES&gt;</code></p> <p>The recipe file or directory containing <code>recipe.yaml</code>. Defaults to the current directory</p> <ul> <li>Default value: <code>.</code></li> </ul> </li> <li> <p><code>--recipe-dir &lt;RECIPE_DIR&gt;</code></p> <p>The directory that contains recipes</p> </li> <li> <p><code>--up-to &lt;UP_TO&gt;</code></p> <p>Build recipes up to the specified package</p> </li> <li> <p><code>--build-platform &lt;BUILD_PLATFORM&gt;</code></p> <p>The build platform to use for the build (e.g. for building with emulation, or rendering)</p> </li> <li> <p><code>--target-platform &lt;TARGET_PLATFORM&gt;</code></p> <p>The target platform for the build</p> </li> <li> <p><code>--host-platform &lt;HOST_PLATFORM&gt;</code></p> <p>The host platform for the build. If set, it will be used to determine also the target_platform (as long as it is not noarch)</p> </li> <li> <p><code>-c</code>, <code>--channel &lt;CHANNELS&gt;</code></p> <p>Add a channel to search for dependencies in</p> </li> <li> <p><code>-m</code>, <code>--variant-config &lt;VARIANT_CONFIG&gt;</code></p> <p>Variant configuration files for the build</p> </li> <li> <p><code>--variant &lt;VARIANT_OVERRIDES&gt;</code></p> <p>Override specific variant values (e.g. --variant python=3.12 or --variant python=3.12,3.11). Multiple values separated by commas will create multiple build variants</p> </li> <li> <p><code>--ignore-recipe-variants</code></p> <p>Do not read the <code>variants.yaml</code> file next to a recipe</p> </li> <li> <p><code>--render-only</code></p> <p>Render the recipe files without executing the build</p> </li> <li> <p><code>--with-solve</code></p> <p>Render the recipe files with solving dependencies</p> </li> <li> <p><code>--keep-build</code></p> <p>Keep intermediate build artifacts after the build</p> </li> <li> <p><code>--no-build-id</code></p> <p>Don't use build id(timestamp) when creating build directory name</p> </li> <li> <p><code>--compression-threads &lt;COMPRESSION_THREADS&gt;</code></p> <p>The number of threads to use for compression (only relevant when also using <code>--package-format conda</code>)</p> </li> <li> <p><code>--io-concurrency-limit &lt;IO_CONCURRENCY_LIMIT&gt;</code></p> <p>The maximum number of concurrent I/O operations to use when installing packages This can be controlled by the <code>RATTLER_IO_CONCURRENCY_LIMIT</code> environment variable Defaults to 8 times the number of CPUs</p> </li> <li> <p><code>--experimental</code></p> <p>Enable experimental features</p> </li> <li> <p><code>--allow-insecure-host &lt;ALLOW_INSECURE_HOST&gt;</code></p> <p>List of hosts for which SSL certificate verification should be skipped</p> </li> <li> <p><code>--channel-priority &lt;CHANNEL_PRIORITY&gt;</code></p> <p>Channel priority to use when solving</p> </li> <li> <p><code>--extra-meta &lt;EXTRA_META&gt;</code></p> <p>Extra metadata to include in about.json</p> </li> <li> <p><code>--continue-on-failure</code></p> <p>Continue building even if (one) of the packages fails to build. This is useful when building many packages with <code>--recipe-dir</code>.`</p> </li> </ul>"},{"location":"reference/cli/#modifying-result_1","title":"Modifying result","text":"<ul> <li> <p><code>--package-format &lt;PACKAGE_FORMAT&gt;</code></p> <p>The package format to use for the build. Can be one of <code>tar-bz2</code> or <code>conda</code>. You can also add a compression level to the package format, e.g. <code>tar-bz2:&lt;number&gt;</code> (from 1 to 9) or <code>conda:&lt;number&gt;</code> (from -7 to 22).</p> </li> <li> <p><code>--no-include-recipe</code></p> <p>Don't store the recipe in the final package</p> </li> <li> <p><code>--test &lt;TEST&gt;</code></p> <p>The strategy to use for running tests</p> <ul> <li>Possible values:<ul> <li><code>skip</code>:     Skip the tests</li> <li><code>native</code>:     Run the tests only if the build platform is the same as the host platform. Otherwise, skip the tests. If the target platform is noarch, the tests are always executed</li> <li><code>native-and-emulated</code>:     Always run the tests</li> </ul> </li> </ul> </li> <li> <p><code>--color-build-log</code></p> <p>Don't force colors in the output of the build script</p> </li> <li> <p><code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory for build artifacts.</p> </li> <li> <p><code>--skip-existing &lt;SKIP_EXISTING&gt;</code></p> <p>Whether to skip packages that already exist in any channel If set to <code>none</code>, do not skip any packages, default when not specified. If set to <code>local</code>, only skip packages that already exist locally, default when using <code>--skip-existing. If set to</code>all`, skip packages that already exist in any channel</p> <ul> <li>Possible values:<ul> <li><code>none</code>:     Do not skip any packages</li> <li><code>local</code>:     Skip packages that already exist locally</li> <li><code>all</code>:     Skip packages that already exist in any channel</li> </ul> </li> </ul> </li> <li> <p><code>--noarch-build-platform &lt;NOARCH_BUILD_PLATFORM&gt;</code></p> <p>Define a \"noarch platform\" for which the noarch packages will be built for. The noarch builds will be skipped on the other platforms</p> </li> <li> <p><code>--debug</code></p> <p>Enable debug output in build scripts</p> </li> <li> <p><code>--markdown-summary &lt;MARKDOWN_SUMMARY&gt;</code></p> <p>Write a markdown summary to the specified file (appends to the file). Useful for generating PR comments or custom reports</p> </li> <li> <p><code>--error-prefix-in-binary</code></p> <p>Error if the host prefix is detected in any binary files</p> </li> <li> <p><code>--allow-symlinks-on-windows</code></p> <p>Allow symlinks in packages on Windows (defaults to false - symlinks are forbidden on Windows)</p> </li> <li> <p><code>--exclude-newer &lt;EXCLUDE_NEWER&gt;</code></p> <p>Exclude packages newer than this date from the solver, in RFC3339 format (e.g. 2024-03-15T12:00:00Z)</p> </li> <li> <p><code>--build-num &lt;BUILD_NUM&gt;</code></p> <p>Override the build number for all outputs (defaults to the build number in the recipe)</p> </li> </ul>"},{"location":"reference/cli/#publishing","title":"Publishing","text":"<ul> <li> <p><code>--to &lt;TO&gt;</code></p> <p>The channel or URL to publish the package to.</p> <p>Examples: - prefix.dev: https://prefix.dev/my-channel - anaconda.org: https://anaconda.org/my-org - S3: s3://my-bucket - Filesystem: file:///path/to/channel or /path/to/channel - Quetz: quetz://server.company.com/channel - Artifactory: artifactory://server.company.com/channel</p> <p>Note: This channel is also used as the highest priority channel when solving dependencies.</p> </li> <li> <p><code>--build-number &lt;BUILD_NUMBER&gt;</code></p> <p>Override the build number for all outputs. Use an absolute value (e.g., <code>--build-number=12</code>) or a relative bump (e.g., <code>--build-number=+1</code>). When using a relative bump, the highest build number from the target channel is used as the base</p> </li> <li> <p><code>--force</code></p> <p>Force upload even if the package already exists (not recommended - may break lockfiles). Only works with S3, filesystem, Anaconda.org, and prefix.dev channels</p> </li> <li> <p><code>--generate-attestation</code></p> <p>Automatically generate attestations when uploading to prefix.dev channels. Only works when uploading to prefix.dev channels with trusted publishing enabled</p> </li> </ul>"},{"location":"reference/cli/#sandbox-arguments_1","title":"Sandbox arguments","text":"<ul> <li> <p><code>--sandbox</code></p> <p>Enable the sandbox</p> </li> <li> <p><code>--allow-network</code></p> <p>Allow network access during build (default: false if sandbox is enabled)</p> </li> <li> <p><code>--allow-read &lt;ALLOW_READ&gt;</code></p> <p>Allow read access to the specified paths</p> </li> <li> <p><code>--allow-read-execute &lt;ALLOW_READ_EXECUTE&gt;</code></p> <p>Allow read and execute access to the specified paths</p> </li> <li> <p><code>--allow-read-write &lt;ALLOW_READ_WRITE&gt;</code></p> <p>Allow read and write access to the specified paths</p> </li> <li> <p><code>--overwrite-default-sandbox-config</code></p> <p>Overwrite the default sandbox configuration</p> </li> </ul>"},{"location":"reference/cli/#test","title":"<code>test</code>","text":"<p>Run a test for a single package</p> <p>This creates a temporary directory, copies the package file into it, and then runs the indexing. It then creates a test environment that installs the package and any extra dependencies specified in the package test dependencies file.</p> <p>With the activated test environment, the packaged test files are run:</p> <ul> <li><code>info/test/run_test.sh</code> or <code>info/test/run_test.bat</code> on Windows * <code>info/test/run_test.py</code></li> </ul> <p>These test files are written at \"package creation time\" and are part of the package.</p> <p>Usage: <code>rattler-build test [OPTIONS] --package-file &lt;PACKAGE_FILE&gt;</code></p>"},{"location":"reference/cli/#options_3","title":"Options:","text":"<ul> <li> <p><code>-c</code>, <code>--channel &lt;CHANNELS&gt;</code></p> <p>Channels to use when testing</p> </li> <li> <p><code>-p</code>, <code>--package-file &lt;PACKAGE_FILE&gt;</code></p> <p>The package file or extracted package directory to test</p> </li> <li> <p><code>--compression-threads &lt;COMPRESSION_THREADS&gt;</code></p> <p>The number of threads to use for compression</p> </li> <li> <p><code>--test-index &lt;TEST_INDEX&gt;</code></p> <p>The index of the test to run. This is used to run a specific test from the package</p> </li> <li> <p><code>--debug</code></p> <p>Build test environment and output debug information for manual debugging</p> </li> <li> <p><code>--experimental</code></p> <p>Enable experimental features</p> </li> <li> <p><code>--allow-insecure-host &lt;ALLOW_INSECURE_HOST&gt;</code></p> <p>List of hosts for which SSL certificate verification should be skipped</p> </li> <li> <p><code>--channel-priority &lt;CHANNEL_PRIORITY&gt;</code></p> <p>Channel priority to use when solving</p> </li> </ul>"},{"location":"reference/cli/#modifying-result_2","title":"Modifying result","text":"<ul> <li> <p><code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory for build artifacts.</p> </li> </ul>"},{"location":"reference/cli/#rebuild","title":"<code>rebuild</code>","text":"<p>Rebuild a package from a package file instead of a recipe</p> <p>Usage: <code>rattler-build rebuild [OPTIONS] --package-file &lt;PACKAGE_FILE&gt;</code></p>"},{"location":"reference/cli/#options_4","title":"Options:","text":"<ul> <li> <p><code>-p</code>, <code>--package-file &lt;PACKAGE_FILE&gt;</code></p> <p>The package file to rebuild (can be a local path or URL)</p> </li> <li> <p><code>--compression-threads &lt;COMPRESSION_THREADS&gt;</code></p> <p>The number of threads to use for compression</p> </li> <li> <p><code>--io-concurrency-limit &lt;IO_CONCURRENCY_LIMIT&gt;</code></p> <p>The number of threads to use for I/O operations when installing packages</p> </li> <li> <p><code>--experimental</code></p> <p>Enable experimental features</p> </li> <li> <p><code>--allow-insecure-host &lt;ALLOW_INSECURE_HOST&gt;</code></p> <p>List of hosts for which SSL certificate verification should be skipped</p> </li> <li> <p><code>--channel-priority &lt;CHANNEL_PRIORITY&gt;</code></p> <p>Channel priority to use when solving</p> </li> </ul>"},{"location":"reference/cli/#modifying-result_3","title":"Modifying result","text":"<ul> <li> <p><code>--test &lt;TEST&gt;</code></p> <p>The strategy to use for running tests</p> <ul> <li>Possible values:<ul> <li><code>skip</code>:     Skip the tests</li> <li><code>native</code>:     Run the tests only if the build platform is the same as the host platform. Otherwise, skip the tests. If the target platform is noarch, the tests are always executed</li> <li><code>native-and-emulated</code>:     Always run the tests</li> </ul> </li> </ul> </li> <li> <p><code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory for build artifacts.</p> </li> </ul>"},{"location":"reference/cli/#upload","title":"<code>upload</code>","text":"<p>Upload a package</p> <p>Usage: <code>rattler-build upload [OPTIONS] [PACKAGE_FILES]... &lt;COMMAND&gt;</code></p>"},{"location":"reference/cli/#subcommands_1","title":"Subcommands:","text":"<ul> <li><code>quetz</code> \u2014 Upload to a Quetz server. Authentication is used from the keychain / auth-file</li> <li><code>artifactory</code> \u2014 Options for uploading to a Artifactory channel. Authentication is used from the keychain / auth-file</li> <li><code>prefix</code> \u2014 Options for uploading to a prefix.dev server. Authentication is used from the keychain / auth-file</li> <li><code>anaconda</code> \u2014 Options for uploading to a Anaconda.org server</li> <li><code>s3</code> \u2014 Options for uploading to S3</li> </ul>"},{"location":"reference/cli/#arguments_1","title":"Arguments:","text":"<ul> <li> <p><code>&lt;PACKAGE_FILES&gt;</code></p> <p>The package file to upload</p> </li> </ul>"},{"location":"reference/cli/#options_5","title":"Options:","text":"<ul> <li> <p><code>--allow-insecure-host &lt;ALLOW_INSECURE_HOST&gt;</code></p> <p>List of hosts for which SSL certificate verification should be skipped</p> </li> </ul>"},{"location":"reference/cli/#quetz","title":"<code>quetz</code>","text":"<p>Upload to a Quetz server. Authentication is used from the keychain / auth-file</p> <p>Usage: <code>rattler-build upload quetz [OPTIONS] --url &lt;URL&gt; --channel &lt;CHANNELS&gt;</code></p>"},{"location":"reference/cli/#options_6","title":"Options:","text":"<ul> <li> <p><code>-u</code>, <code>--url &lt;URL&gt;</code></p> <p>The URL to your Quetz server</p> </li> <li> <p><code>-c</code>, <code>--channel &lt;CHANNELS&gt;</code></p> <p>The URL to your channel</p> </li> <li> <p><code>-a</code>, <code>--api-key &lt;API_KEY&gt;</code></p> <p>The Quetz API key, if none is provided, the token is read from the keychain / auth-file</p> </li> </ul>"},{"location":"reference/cli/#artifactory","title":"<code>artifactory</code>","text":"<p>Options for uploading to a Artifactory channel. Authentication is used from the keychain / auth-file</p> <p>Usage: <code>rattler-build upload artifactory [OPTIONS] --url &lt;URL&gt; --channel &lt;CHANNELS&gt;</code></p>"},{"location":"reference/cli/#options_7","title":"Options:","text":"<ul> <li> <p><code>-u</code>, <code>--url &lt;URL&gt;</code></p> <p>The URL to your Artifactory server</p> </li> <li> <p><code>-c</code>, <code>--channel &lt;CHANNELS&gt;</code></p> <p>The URL to your channel</p> </li> <li> <p><code>-t</code>, <code>--token &lt;TOKEN&gt;</code></p> <p>Your Artifactory token</p> </li> </ul>"},{"location":"reference/cli/#prefix","title":"<code>prefix</code>","text":"<p>Options for uploading to a prefix.dev server. Authentication is used from the keychain / auth-file</p> <p>Usage: <code>rattler-build upload prefix [OPTIONS] --channel &lt;CHANNEL&gt;</code></p>"},{"location":"reference/cli/#options_8","title":"Options:","text":"<ul> <li> <p><code>-u</code>, <code>--url &lt;URL&gt;</code></p> <p>The URL to the prefix.dev server (only necessary for self-hosted instances)</p> <ul> <li>Default value: <code>https://prefix.dev</code></li> </ul> </li> <li> <p><code>-c</code>, <code>--channel &lt;CHANNEL&gt;</code></p> <p>The channel to upload the package to</p> </li> <li> <p><code>-a</code>, <code>--api-key &lt;API_KEY&gt;</code></p> <p>The prefix.dev API key, if none is provided, the token is read from the keychain / auth-file</p> </li> <li> <p><code>--attestation &lt;ATTESTATION&gt;</code></p> <p>Upload an attestation file alongside the package. Note: if you add an attestation, you can only upload a single package. Mutually exclusive with --generate-attestation</p> </li> <li> <p><code>--generate-attestation</code></p> <p>Automatically generate attestation using cosign in CI. Mutually exclusive with --attestation</p> </li> <li> <p><code>--store-github-attestation</code></p> <p>Also store the generated attestation to GitHub's attestation API. Requires <code>GITHUB_TOKEN</code> environment variable and only works in GitHub Actions. The attestation will be associated with the current repository</p> </li> <li> <p><code>-s</code>, <code>--skip-existing</code></p> <p>Skip upload if package already exists</p> </li> <li> <p><code>--force</code></p> <p>Force overwrite existing packages</p> </li> </ul>"},{"location":"reference/cli/#anaconda","title":"<code>anaconda</code>","text":"<p>Options for uploading to a Anaconda.org server</p> <p>Usage: <code>rattler-build upload anaconda [OPTIONS] --owner &lt;OWNER&gt;</code></p>"},{"location":"reference/cli/#options_9","title":"Options:","text":"<ul> <li> <p><code>-o</code>, <code>--owner &lt;OWNER&gt;</code></p> <p>The owner of the distribution (e.g. conda-forge or your username)</p> </li> <li> <p><code>-c</code>, <code>--channel &lt;CHANNELS&gt;</code></p> <p>The channel / label to upload the package to (e.g. main / rc)</p> </li> <li> <p><code>-a</code>, <code>--api-key &lt;API_KEY&gt;</code></p> <p>The Anaconda API key, if none is provided, the token is read from the keychain / auth-file</p> </li> <li> <p><code>-u</code>, <code>--url &lt;URL&gt;</code></p> <p>The URL to the Anaconda server</p> </li> <li> <p><code>-f</code>, <code>--force</code></p> <p>Replace files on conflict</p> </li> </ul>"},{"location":"reference/cli/#s3","title":"<code>s3</code>","text":"<p>Options for uploading to S3</p> <p>Usage: <code>rattler-build upload s3 [OPTIONS] --channel &lt;CHANNEL&gt;</code></p>"},{"location":"reference/cli/#options_10","title":"Options:","text":"<ul> <li> <p><code>-c</code>, <code>--channel &lt;CHANNEL&gt;</code></p> <p>The channel URL in the S3 bucket to upload the package to, e.g., <code>s3://my-bucket/my-channel</code></p> </li> <li> <p><code>--force</code></p> <p>Replace files if it already exists</p> </li> </ul>"},{"location":"reference/cli/#s3-credentials","title":"S3 Credentials","text":"<ul> <li> <p><code>--endpoint-url &lt;ENDPOINT_URL&gt;</code></p> <p>The endpoint URL of the S3 backend</p> </li> <li> <p><code>--region &lt;REGION&gt;</code></p> <p>The region of the S3 backend</p> </li> <li> <p><code>--access-key-id &lt;ACCESS_KEY_ID&gt;</code></p> <p>The access key ID for the S3 bucket</p> </li> <li> <p><code>--secret-access-key &lt;SECRET_ACCESS_KEY&gt;</code></p> <p>The secret access key for the S3 bucket</p> </li> <li> <p><code>--session-token &lt;SESSION_TOKEN&gt;</code></p> <p>The session token for the S3 bucket</p> </li> <li> <p><code>--addressing-style &lt;ADDRESSING_STYLE&gt;</code></p> <p>How to address the bucket</p> <ul> <li>Default value: <code>virtual-host</code></li> <li>Possible values: <code>virtual-host</code>, <code>path</code></li> </ul> </li> </ul>"},{"location":"reference/cli/#completion","title":"<code>completion</code>","text":"<p>Generate shell completion script</p> <p>Usage: <code>rattler-build completion --shell &lt;SHELL&gt;</code></p>"},{"location":"reference/cli/#options_11","title":"Options:","text":"<ul> <li> <p><code>-s</code>, <code>--shell &lt;SHELL&gt;</code></p> <p>Specifies the shell for which the completions should be generated</p> <ul> <li>Possible values:<ul> <li><code>bash</code>:     Bourne Again SHell (bash)</li> <li><code>elvish</code>:     Elvish shell</li> <li><code>fish</code>:     Friendly Interactive SHell (fish)</li> <li><code>nushell</code>:     Nushell</li> <li><code>powershell</code>:     PowerShell</li> <li><code>zsh</code>:     Z SHell (zsh)</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/cli/#generate-recipe","title":"<code>generate-recipe</code>","text":"<p>Generate a recipe from PyPI, CRAN, CPAN, or LuaRocks</p> <p>Usage: <code>rattler-build generate-recipe &lt;COMMAND&gt;</code></p>"},{"location":"reference/cli/#subcommands_2","title":"Subcommands:","text":"<ul> <li><code>pypi</code> \u2014 Generate a recipe for a Python package from PyPI</li> <li><code>cran</code> \u2014 Generate a recipe for an R package from CRAN</li> <li><code>cpan</code> \u2014 Generate a recipe for a Perl package from CPAN</li> <li><code>luarocks</code> \u2014 Generate a recipe for a Lua package from LuaRocks</li> </ul>"},{"location":"reference/cli/#pypi","title":"<code>pypi</code>","text":"<p>Generate a recipe for a Python package from PyPI</p> <p>Usage: <code>rattler-build generate-recipe pypi [OPTIONS] &lt;PACKAGE&gt;</code></p>"},{"location":"reference/cli/#arguments_2","title":"Arguments:","text":"<ul> <li> <p><code>&lt;PACKAGE&gt;</code></p> <p>Name of the package to generate</p> </li> </ul>"},{"location":"reference/cli/#options_12","title":"Options:","text":"<ul> <li> <p><code>--version &lt;VERSION&gt;</code></p> <p>Select a version of the package to generate (defaults to latest)</p> </li> <li> <p><code>-w</code>, <code>--write</code></p> <p>Whether to write the recipe to a folder</p> </li> <li> <p><code>-u</code>, <code>--use-mapping</code></p> <p>Whether to use the conda-forge PyPI name mapping</p> </li> <li> <p><code>-t</code>, <code>--tree</code></p> <p>Whether to generate recipes for all dependencies</p> </li> <li> <p><code>--pypi-index-url &lt;PYPI_INDEX_URLS&gt;</code></p> <p>Specify the PyPI index URL(s) to use for recipe generation</p> <ul> <li>Default value: <code>https://pypi.org/pypi</code></li> </ul> </li> </ul>"},{"location":"reference/cli/#cran","title":"<code>cran</code>","text":"<p>Generate a recipe for an R package from CRAN</p> <p>Usage: <code>rattler-build generate-recipe cran [OPTIONS] &lt;PACKAGE&gt;</code></p>"},{"location":"reference/cli/#arguments_3","title":"Arguments:","text":"<ul> <li> <p><code>&lt;PACKAGE&gt;</code></p> <p>Name of the package to generate</p> </li> </ul>"},{"location":"reference/cli/#options_13","title":"Options:","text":"<ul> <li> <p><code>-u</code>, <code>--universe &lt;UNIVERSE&gt;</code></p> <p>The R Universe to fetch the package from (defaults to <code>cran</code>)</p> </li> <li> <p><code>-t</code>, <code>--tree</code></p> <p>Whether to create recipes for the whole dependency tree or not</p> </li> <li> <p><code>-w</code>, <code>--write</code></p> <p>Whether to write the recipe to a folder</p> </li> </ul>"},{"location":"reference/cli/#cpan","title":"<code>cpan</code>","text":"<p>Generate a recipe for a Perl package from CPAN</p> <p>Usage: <code>rattler-build generate-recipe cpan [OPTIONS] &lt;PACKAGE&gt;</code></p>"},{"location":"reference/cli/#arguments_4","title":"Arguments:","text":"<ul> <li> <p><code>&lt;PACKAGE&gt;</code></p> <p>Name of the package to generate</p> </li> </ul>"},{"location":"reference/cli/#options_14","title":"Options:","text":"<ul> <li> <p><code>--version &lt;VERSION&gt;</code></p> <p>Select a version of the package to generate (defaults to latest)</p> </li> <li> <p><code>-w</code>, <code>--write</code></p> <p>Whether to write the recipe to a folder</p> </li> <li> <p><code>-t</code>, <code>--tree</code></p> <p>Whether to generate recipes for all dependencies</p> </li> </ul>"},{"location":"reference/cli/#luarocks","title":"<code>luarocks</code>","text":"<p>Generate a recipe for a Lua package from LuaRocks</p> <p>Usage: <code>rattler-build generate-recipe luarocks [OPTIONS] &lt;ROCK&gt;</code></p>"},{"location":"reference/cli/#arguments_5","title":"Arguments:","text":"<ul> <li> <p><code>&lt;ROCK&gt;</code></p> <p>Luarocks package to generate recipe for. Can be specified as: - module (fetches latest version) - module/version - author/module/version - Direct rockspec URL</p> </li> </ul>"},{"location":"reference/cli/#options_15","title":"Options:","text":"<ul> <li> <p><code>-w</code>, <code>--write-to &lt;WRITE_TO&gt;</code></p> <p>Where to write the recipe to</p> <ul> <li>Default value: <code>.</code></li> </ul> </li> </ul>"},{"location":"reference/cli/#auth","title":"<code>auth</code>","text":"<p>Handle authentication to external channels</p> <p>Usage: <code>rattler-build auth &lt;COMMAND&gt;</code></p>"},{"location":"reference/cli/#subcommands_3","title":"Subcommands:","text":"<ul> <li><code>login</code> \u2014 Store authentication information for a given host</li> <li><code>logout</code> \u2014 Remove authentication information for a given host</li> </ul>"},{"location":"reference/cli/#login","title":"<code>login</code>","text":"<p>Store authentication information for a given host</p> <p>Usage: <code>rattler-build auth login [OPTIONS] &lt;HOST&gt;</code></p>"},{"location":"reference/cli/#arguments_6","title":"Arguments:","text":"<ul> <li> <p><code>&lt;HOST&gt;</code></p> <p>The host to authenticate with (e.g. prefix.dev)</p> </li> </ul>"},{"location":"reference/cli/#options_16","title":"Options:","text":""},{"location":"reference/cli/#oauthoidc-authentication","title":"OAuth/OIDC Authentication","text":"<ul> <li> <p><code>--oauth</code></p> <p>Use OAuth/OIDC authentication</p> </li> <li> <p><code>--oauth-issuer-url &lt;OAUTH_ISSUER_URL&gt;</code></p> <p>OIDC issuer URL (defaults to https://{host})</p> </li> <li> <p><code>--oauth-client-id &lt;OAUTH_CLIENT_ID&gt;</code></p> <p>OAuth client ID (defaults to \"rattler\")</p> </li> <li> <p><code>--oauth-client-secret &lt;OAUTH_CLIENT_SECRET&gt;</code></p> <p>OAuth client secret (for confidential clients)</p> </li> <li> <p><code>--oauth-flow &lt;OAUTH_FLOW&gt;</code></p> <p>OAuth flow: auto (default), auth-code, device-code</p> <ul> <li>Possible values: <code>auto</code>, <code>auth-code</code>, <code>device-code</code></li> </ul> </li> <li> <p><code>--oauth-scope &lt;OAUTH_SCOPES&gt;</code></p> <p>Additional OAuth scopes to request (repeatable)</p> </li> </ul>"},{"location":"reference/cli/#s3-authentication","title":"S3 Authentication","text":"<ul> <li> <p><code>--s3-access-key-id &lt;S3_ACCESS_KEY_ID&gt;</code></p> <p>The S3 access key ID</p> </li> <li> <p><code>--s3-secret-access-key &lt;S3_SECRET_ACCESS_KEY&gt;</code></p> <p>The S3 secret access key</p> </li> <li> <p><code>--s3-session-token &lt;S3_SESSION_TOKEN&gt;</code></p> <p>The S3 session token</p> </li> </ul>"},{"location":"reference/cli/#token-basic-authentication","title":"Token / Basic Authentication","text":"<ul> <li> <p><code>--token &lt;TOKEN&gt;</code></p> <p>The token to use (for authentication with prefix.dev)</p> </li> <li> <p><code>--username &lt;USERNAME&gt;</code></p> <p>The username to use (for basic HTTP authentication)</p> </li> <li> <p><code>--password &lt;PASSWORD&gt;</code></p> <p>The password to use (for basic HTTP authentication)</p> </li> <li> <p><code>--conda-token &lt;CONDA_TOKEN&gt;</code></p> <p>The token to use on anaconda.org / quetz authentication</p> </li> </ul>"},{"location":"reference/cli/#logout","title":"<code>logout</code>","text":"<p>Remove authentication information for a given host</p> <p>Usage: <code>rattler-build auth logout &lt;HOST&gt;</code></p>"},{"location":"reference/cli/#arguments_7","title":"Arguments:","text":"<ul> <li> <p><code>&lt;HOST&gt;</code></p> <p>The host to remove authentication for</p> </li> </ul>"},{"location":"reference/cli/#debug","title":"<code>debug</code>","text":"<p>Debug a recipe build.</p> <p>Subcommands: setup     - Set up a debug environment from a recipe shell     - Open an interactive debug shell host-add  - Install additional packages into the host prefix build-add - Install additional packages into the build prefix</p> <p>Usage: <code>rattler-build debug &lt;COMMAND&gt;</code></p>"},{"location":"reference/cli/#subcommands_4","title":"Subcommands:","text":"<ul> <li><code>setup</code> \u2014 Set up a debug environment from a recipe</li> <li><code>shell</code> \u2014 Open an interactive debug shell in an existing build environment</li> <li><code>host-add</code> \u2014 Install additional packages into the host prefix</li> <li><code>build-add</code> \u2014 Install additional packages into the build prefix</li> <li><code>workdir</code> \u2014 Print the work directory path</li> <li><code>run</code> \u2014 Re-run the build script in an existing debug environment</li> <li><code>create-patch</code> \u2014 Create a patch from changes in the work directory</li> </ul>"},{"location":"reference/cli/#setup","title":"<code>setup</code>","text":"<p>Set up a debug environment from a recipe.</p> <p>Resolves dependencies, downloads sources, applies patches, installs build/host environments, and creates the build script \u2014 then stops. Use <code>debug shell</code> or <code>debug run</code> afterwards to work in the environment.</p> <p>Usage: <code>rattler-build debug setup [OPTIONS]</code></p>"},{"location":"reference/cli/#options_17","title":"Options:","text":"<ul> <li> <p><code>-r</code>, <code>--recipe &lt;RECIPE&gt;</code></p> <p>Recipe file or directory to debug</p> <ul> <li>Default value: <code>.</code></li> </ul> </li> <li> <p><code>--target-platform &lt;TARGET_PLATFORM&gt;</code></p> <p>The target platform to build for</p> </li> <li> <p><code>--host-platform &lt;HOST_PLATFORM&gt;</code></p> <p>The host platform to build for (defaults to target_platform)</p> </li> <li> <p><code>--build-platform &lt;BUILD_PLATFORM&gt;</code></p> <p>The build platform to build for (defaults to current platform)</p> </li> <li> <p><code>-c</code>, <code>--channel &lt;CHANNELS&gt;</code></p> <p>Channels to use when building</p> </li> <li> <p><code>--output-name &lt;OUTPUT_NAME&gt;</code></p> <p>Name of the specific output to debug (only required when a recipe has multiple outputs)</p> </li> <li> <p><code>--experimental</code></p> <p>Enable experimental features</p> </li> <li> <p><code>--allow-insecure-host &lt;ALLOW_INSECURE_HOST&gt;</code></p> <p>List of hosts for which SSL certificate verification should be skipped</p> </li> <li> <p><code>--channel-priority &lt;CHANNEL_PRIORITY&gt;</code></p> <p>Channel priority to use when solving</p> </li> </ul>"},{"location":"reference/cli/#modifying-result_4","title":"Modifying result","text":"<ul> <li> <p><code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory for build artifacts.</p> </li> </ul>"},{"location":"reference/cli/#shell","title":"<code>shell</code>","text":"<p>Open an interactive debug shell in an existing build environment.</p> <p>By default, reads the work directory from the last build in rattler-build-log.txt. You can also specify --work-dir explicitly.</p> <p>Usage: <code>rattler-build debug shell [OPTIONS]</code></p>"},{"location":"reference/cli/#options_18","title":"Options:","text":"<ul> <li> <p><code>--work-dir &lt;WORK_DIR&gt;</code></p> <p>Work directory to use (reads from last build in rattler-build-log.txt if not specified)</p> </li> <li> <p><code>--experimental</code></p> <p>Enable experimental features</p> </li> <li> <p><code>--allow-insecure-host &lt;ALLOW_INSECURE_HOST&gt;</code></p> <p>List of hosts for which SSL certificate verification should be skipped</p> </li> <li> <p><code>--channel-priority &lt;CHANNEL_PRIORITY&gt;</code></p> <p>Channel priority to use when solving</p> </li> </ul>"},{"location":"reference/cli/#modifying-result_5","title":"Modifying result","text":"<ul> <li> <p><code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory for build artifacts.</p> </li> </ul>"},{"location":"reference/cli/#host-add","title":"<code>host-add</code>","text":"<p>Install additional packages into the host prefix</p> <p>This command resolves and installs the specified packages into the host environment of an existing debug build. Useful for iterating on dependencies without re-running the full debug setup.</p> <p>Usage: <code>rattler-build debug host-add [OPTIONS] &lt;SPECS&gt;...</code></p>"},{"location":"reference/cli/#arguments_8","title":"Arguments:","text":"<ul> <li> <p><code>&lt;SPECS&gt;</code></p> <p>Package specs to install (e.g. \"python&gt;=3.11\", \"cmake\", \"numpy 1.26.*\")</p> </li> </ul>"},{"location":"reference/cli/#options_19","title":"Options:","text":"<ul> <li> <p><code>-c</code>, <code>--channel &lt;CHANNELS&gt;</code></p> <p>Channels to search for packages in</p> </li> <li> <p><code>--work-dir &lt;WORK_DIR&gt;</code></p> <p>Work directory to use (reads from last build in rattler-build-log.txt if not specified)</p> </li> <li> <p><code>-o</code>, <code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory containing rattler-build-log.txt</p> <ul> <li>Default value: <code>./output</code></li> </ul> </li> </ul>"},{"location":"reference/cli/#build-add","title":"<code>build-add</code>","text":"<p>Install additional packages into the build prefix</p> <p>This command resolves and installs the specified packages into the build environment of an existing debug build. Useful for adding build tools without re-running the full debug setup.</p> <p>Usage: <code>rattler-build debug build-add [OPTIONS] &lt;SPECS&gt;...</code></p>"},{"location":"reference/cli/#arguments_9","title":"Arguments:","text":"<ul> <li> <p><code>&lt;SPECS&gt;</code></p> <p>Package specs to install (e.g. \"python&gt;=3.11\", \"cmake\", \"numpy 1.26.*\")</p> </li> </ul>"},{"location":"reference/cli/#options_20","title":"Options:","text":"<ul> <li> <p><code>-c</code>, <code>--channel &lt;CHANNELS&gt;</code></p> <p>Channels to search for packages in</p> </li> <li> <p><code>--work-dir &lt;WORK_DIR&gt;</code></p> <p>Work directory to use (reads from last build in rattler-build-log.txt if not specified)</p> </li> <li> <p><code>-o</code>, <code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory containing rattler-build-log.txt</p> <ul> <li>Default value: <code>./output</code></li> </ul> </li> </ul>"},{"location":"reference/cli/#workdir","title":"<code>workdir</code>","text":"<p>Print the work directory path.</p> <p>Prints the absolute path to the work directory from the last debug setup (or the directory given by --work-dir). Useful for scripts and AI agents that need to locate the build directory.</p> <p>Usage: <code>rattler-build debug workdir [OPTIONS]</code></p>"},{"location":"reference/cli/#options_21","title":"Options:","text":"<ul> <li> <p><code>--work-dir &lt;WORK_DIR&gt;</code></p> <p>Work directory to use (reads from last build in rattler-build-log.txt if not specified)</p> </li> <li> <p><code>--experimental</code></p> <p>Enable experimental features</p> </li> <li> <p><code>--allow-insecure-host &lt;ALLOW_INSECURE_HOST&gt;</code></p> <p>List of hosts for which SSL certificate verification should be skipped</p> </li> <li> <p><code>--channel-priority &lt;CHANNEL_PRIORITY&gt;</code></p> <p>Channel priority to use when solving</p> </li> </ul>"},{"location":"reference/cli/#modifying-result_6","title":"Modifying result","text":"<ul> <li> <p><code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory for build artifacts.</p> </li> </ul>"},{"location":"reference/cli/#run","title":"<code>run</code>","text":"<p>Re-run the build script in an existing debug environment.</p> <p>Sources <code>build_env.sh</code> and executes <code>conda_build.sh</code> (or <code>.bat</code> on Windows). Use --trace to enable <code>bash -x</code> for verbose output. The exit code of the build script is propagated.</p> <p>Usage: <code>rattler-build debug run [OPTIONS]</code></p>"},{"location":"reference/cli/#options_22","title":"Options:","text":"<ul> <li> <p><code>--work-dir &lt;WORK_DIR&gt;</code></p> <p>Work directory to use (reads from last build in rattler-build-log.txt if not specified)</p> </li> <li> <p><code>--trace</code></p> <p>Enable shell tracing (bash -x) for verbose build output</p> </li> <li> <p><code>--experimental</code></p> <p>Enable experimental features</p> </li> <li> <p><code>--allow-insecure-host &lt;ALLOW_INSECURE_HOST&gt;</code></p> <p>List of hosts for which SSL certificate verification should be skipped</p> </li> <li> <p><code>--channel-priority &lt;CHANNEL_PRIORITY&gt;</code></p> <p>Channel priority to use when solving</p> </li> </ul>"},{"location":"reference/cli/#modifying-result_7","title":"Modifying result","text":"<ul> <li> <p><code>--output-dir &lt;OUTPUT_DIR&gt;</code></p> <p>Output directory for build artifacts.</p> </li> </ul>"},{"location":"reference/cli/#create-patch","title":"<code>create-patch</code>","text":"<p>Create a patch from changes in the work directory.</p> <p>Generates a unified diff between the original sources and your modifications. The patch file is written to the recipe directory so you can add it to the recipe's <code>patches:</code> list.</p> <p>Usage: <code>rattler-build debug create-patch [OPTIONS]</code></p>"},{"location":"reference/cli/#options_23","title":"Options:","text":"<ul> <li> <p><code>-d</code>, <code>--directory &lt;DIRECTORY&gt;</code></p> <p>Directory where we want to create the patch. Defaults to current directory if not specified</p> </li> <li> <p><code>--name &lt;NAME&gt;</code></p> <p>The name for the patch file to create</p> <ul> <li>Default value: <code>changes</code></li> </ul> </li> <li> <p><code>--overwrite</code></p> <p>Whether to overwrite the patch file if it already exists</p> </li> <li> <p><code>--patch-dir &lt;DIR&gt;</code></p> <p>Optional directory where the patch file should be written. Defaults to the recipe directory determined from <code>.source_info.json</code> if not provided</p> </li> <li> <p><code>--exclude &lt;EXCLUDE&gt;</code></p> <p>Comma-separated list of file names (or glob patterns) that should be excluded from the diff</p> </li> <li> <p><code>--add &lt;ADD&gt;</code></p> <p>Include new files matching these glob patterns (e.g., \".txt\", \"src//.rs\")</p> </li> <li> <p><code>--include &lt;INCLUDE&gt;</code></p> <p>Only include modified files matching these glob patterns (e.g., \".c\", \"src//.rs\") If not specified, all modified files are included (subject to --exclude)</p> </li> <li> <p><code>--dry-run</code></p> <p>Perform a dry-run: analyze changes and log the diff, but don't write the patch file</p> </li> </ul>"},{"location":"reference/cli/#package","title":"<code>package</code>","text":"<p>Package-related subcommands</p> <p>Usage: <code>rattler-build package &lt;COMMAND&gt;</code></p>"},{"location":"reference/cli/#subcommands_5","title":"Subcommands:","text":"<ul> <li><code>inspect</code> \u2014 Inspect and display information about a built package</li> <li><code>extract</code> \u2014 Extract a conda package to a directory</li> </ul>"},{"location":"reference/cli/#inspect","title":"<code>inspect</code>","text":"<p>Inspect and display information about a built package</p> <p>Usage: <code>rattler-build package inspect [OPTIONS] &lt;PACKAGE_FILE&gt;</code></p>"},{"location":"reference/cli/#arguments_10","title":"Arguments:","text":"<ul> <li> <p><code>&lt;PACKAGE_FILE&gt;</code></p> <p>Path to the package file (.conda, .tar.bz2)</p> </li> </ul>"},{"location":"reference/cli/#options_24","title":"Options:","text":"<ul> <li> <p><code>--paths</code></p> <p>Show detailed file listing with hashes and sizes</p> </li> <li> <p><code>--about</code></p> <p>Show extended about information</p> </li> <li> <p><code>--run-exports</code></p> <p>Show run exports</p> </li> <li> <p><code>--all</code></p> <p>Show all available information</p> </li> <li> <p><code>--json</code></p> <p>Output as JSON</p> </li> </ul>"},{"location":"reference/cli/#extract","title":"<code>extract</code>","text":"<p>Extract a conda package to a directory</p> <p>Usage: <code>rattler-build package extract [OPTIONS] &lt;PACKAGE_FILE&gt;</code></p>"},{"location":"reference/cli/#arguments_11","title":"Arguments:","text":"<ul> <li> <p><code>&lt;PACKAGE_FILE&gt;</code></p> <p>Path to the package file (.conda, .tar.bz2) or a URL to download from</p> </li> </ul>"},{"location":"reference/cli/#options_25","title":"Options:","text":"<ul> <li> <p><code>-d</code>, <code>--dest &lt;DEST&gt;</code></p> <p>Destination directory for extraction (defaults to package name without extension)</p> </li> </ul>"},{"location":"reference/cli/#bump-recipe","title":"<code>bump-recipe</code>","text":"<p>Bump a recipe to a new version</p> <p>This command updates the version and SHA256 checksum(s) in a recipe file. It can either use a specified version or auto-detect the latest version from supported providers (GitHub, PyPI, crates.io).</p> <p>Usage: <code>rattler-build bump-recipe [OPTIONS]</code></p>"},{"location":"reference/cli/#options_26","title":"Options:","text":"<ul> <li> <p><code>-r</code>, <code>--recipe &lt;RECIPE&gt;</code></p> <p>Path to the recipe file (recipe.yaml). Defaults to current directory</p> <ul> <li>Default value: <code>.</code></li> </ul> </li> <li> <p><code>--version &lt;VERSION&gt;</code></p> <p>The new version to bump to. If not specified, will auto-detect the latest version from the source URL's provider (GitHub, PyPI, crates.io)</p> </li> <li> <p><code>--include-prerelease</code></p> <p>Include pre-release versions when auto-detecting (e.g., alpha, beta, rc)</p> </li> <li> <p><code>--check-only</code></p> <p>Only check for updates without modifying the recipe</p> </li> <li> <p><code>--dry-run</code></p> <p>Perform a dry-run: show what would be changed without writing to the file</p> </li> <li> <p><code>--keep-build-number</code></p> <p>Keep the current build number instead of resetting it to 0</p> </li> </ul>"},{"location":"reference/cli/#migrate-recipe","title":"<code>migrate-recipe</code>","text":"<p>Migrate a recipe from the deprecated <code>cache:</code> format to <code>staging:</code> outputs</p> <p>Usage: <code>rattler-build migrate-recipe [OPTIONS]</code></p>"},{"location":"reference/cli/#options_27","title":"Options:","text":"<ul> <li> <p><code>-r</code>, <code>--recipe &lt;RECIPE&gt;</code></p> <p>Path to the recipe file or directory containing recipe.yaml. Defaults to current directory</p> <ul> <li>Default value: <code>.</code></li> </ul> </li> <li> <p><code>--dry-run</code></p> <p>Perform a dry-run: show the migrated recipe without writing to the file</p> </li> </ul> <p>     This document was generated automatically by     <code>clap-markdown</code>. </p>"},{"location":"reference/jinja/","title":"Jinja","text":"<p><code>rattler-build</code> comes with a couple of useful Jinja functions and filters that can be used in the recipe.</p>"},{"location":"reference/jinja/#functions","title":"Functions","text":""},{"location":"reference/jinja/#the-compiler-function","title":"The compiler function","text":"<p>The compiler function can be used to put together a compiler that works for the current platform and the compilation \"<code>target_platform</code>\". The syntax looks like: <code>${{ compiler('c') }}</code> where <code>'c'</code> signifies the programming language that is used.</p> <p>This function evaluates to <code>&lt;compiler&gt;_&lt;target_platform&gt; &lt;compiler_version&gt;</code>. For example, when compiling on <code>linux</code> and to <code>linux-64</code>, this function evaluates to <code>gcc_linux-64</code>.</p> <p>The values can be influenced by the <code>variant_configuration</code>. The <code>&lt;lang&gt;_compiler</code> and <code>&lt;lang&gt;_compiler_version</code> variables are the keys with influence. See below for an example:</p>"},{"location":"reference/jinja/#usage-in-a-recipe","title":"Usage in a recipe","text":"recipe.yaml<pre><code>requirements:\n  build:\n    - ${{ compiler('c') }}\n</code></pre> <p>With a corresponding variant_configuration:</p> variant_configuration.yaml<pre><code>c_compiler:\n- clang\nc_compiler_version:\n- 9.0\n</code></pre> <p>The variables shown above would select the <code>clang</code> compiler in version <code>9.0</code>. Note that the final output will still contain the <code>target_platform</code>, so that the full compiler will read <code>clang_linux-64 9.0</code> when compiling with <code>--target-platform linux-64</code>.</p> <p><code>rattler-build</code> defines some default compilers for the following languages (inherited from <code>conda-build</code>):</p> <ul> <li><code>c</code>: <code>gcc</code> on Linux, <code>clang</code> on <code>osx</code> and <code>vs2017</code> on Windows</li> <li><code>cxx</code>: <code>gxx</code> on Linux, <code>clangxx</code> on <code>osx</code> and <code>vs2017</code> on Windows</li> <li><code>fortran</code>: <code>gfortran</code> on Linux, <code>gfortran</code> on <code>osx</code> and <code>vs2017</code> on Windows</li> <li><code>rust</code>: <code>rust</code></li> </ul>"},{"location":"reference/jinja/#the-stdlib-function","title":"The <code>stdlib</code> function","text":"<p>The <code>stdlib</code> function closely mirrors the compiler function. It can be used to put together a standard library that works for the current platform and the compilation \"<code>target_platform</code>\".</p> <p>Usage: <code>${{ stdlib('c') }}</code></p> <p>Results in <code>&lt;stdlib&gt;_&lt;target_platform&gt; &lt;stdlib_version&gt;</code>. And uses the variant variables <code>&lt;lang&gt;_stdlib</code> and <code>&lt;lang&gt;_stdlib_version</code> to influence the output.</p>"},{"location":"reference/jinja/#usage-in-a-recipe_1","title":"Usage in a recipe:","text":"recipe.yaml<pre><code>requirements:\n  build:\n    # these are usually paired!\n    - ${{ compiler('c') }}\n    - ${{ stdlib('c') }}\n</code></pre> <p>With a corresponding variant_configuration:</p> variant_configuration.yaml<pre><code># these are the values `conda-forge` uses in their pinning file\n# found at https://github.com/conda-forge/conda-forge-pinning-feedstock/blob/main/recipe/conda_build_config.yaml\nc_stdlib:\n- sysroot\nc_stdlib_version:\n- 2.17\n</code></pre>"},{"location":"reference/jinja/#the-pin-functions","title":"The <code>pin</code> functions","text":"<p>A pin is created based on the version input (from a subpackage or a package resolution).</p> <p>The pin functions take the following three arguments:</p> <ul> <li><code>lower_bound</code> (default: <code>\"x.x.x.x.x.x\"</code>): The lower bound pin expression to be   used. When set to <code>None</code>, no lower bound is set.</li> <li><code>upper_bound</code> (default: <code>\"x\"</code>): The maximum pin to be used. When set to   <code>None</code>, no upper bound is set.</li> </ul> <p>The lower bound and upper bound can either be a \"pin expression\" (only <code>x</code> and <code>.</code> are allowed) or a hard-coded version string.</p> <p>A \"pin expression\" is applied to the version input to create the lower and upper bounds. For example, if the version is <code>3.10.5</code> with a  <code>lower_bound=\"x.x\", upper_bound=\"x.x.x\"</code>, the lower bound will be <code>3.10</code> and the upper bound will be <code>3.10.6.0a0</code>. A pin expression for the <code>upper_bound</code> will increment the last selected segment of the version by <code>1</code>, and append <code>.0a0</code> to the end to prevent any alpha versions from being selected.</p> <p>If the last segment of the version contains a letter (e.g. <code>9e</code> or <code>1.1.1j</code>), then incrementing the version will set that letter to <code>a</code>, e.g. <code>9e</code> will become <code>10a</code>, and <code>1.1.1j</code> will become <code>1.1.2a</code>. In this case, also no <code>0a0</code> is appended to the end.</p> <p>Sometimes you want to strongly connect your outputs. This can be achieved with the following input:</p> <ul> <li><code>exact=True</code> (default: <code>False</code>): This will pin the version exactly to the   version of the output, incl. the build string.</li> </ul> <p>To override the lower or upper bound with a hard-coded value, you can use the following input:</p> <ul> <li><code>lower_bound</code> (default: <code>None</code>): This will override the lower bound with the   given value.</li> <li><code>upper_bound</code> (default: <code>None</code>): This will override the upper bound with the   given value.</li> </ul> <p>Both <code>lower_bound</code> and <code>upper_bound</code> expect a valid version string (e.g. <code>1.2.3</code>).</p> <p>To add an build-string matching expression, you can use the <code>build</code> argument:</p> <ul> <li><code>build</code> (default: <code>None</code>): This will add a build string matching expression to   the pin. The build string matching expression is a string that is used to   match the build string with the match spec. For example, if the build string is   <code>py38_0</code>, the build string matching expression could be <code>py38*</code> or to match   exactly <code>py38_0</code>. The <code>build</code> and <code>exact</code> options are mutually exclusive.</li> </ul>"},{"location":"reference/jinja/#the-pin_subpackage-function","title":"The <code>pin_subpackage</code> function","text":"<ul> <li><code>${{ pin_subpackage(\"mypkg\", lower_bound=\"x.x\", upper_bound=\"x.x\") }}</code> creates a pin   to another output in the recipe. With an input of <code>3.1.5</code>, this would create a   pin of <code>mypkg &gt;=3.1,&lt;3.2.0a0</code>.</li> <li><code>${{ pin_subpackage(\"other_output\", exact=True) }}</code> creates a pin to another   output in the recipe with an exact version.</li> <li><code>${{ pin_subpackage(\"other_output\", lower_bound=\"1.2.3\", upper_bound=\"1.2.4\")   }}</code> creates a pin to another output in the recipe with a lower bound of   <code>1.2.3</code> and an upper bound of <code>1.2.4</code>. This is equivalent to writing   <code>other_output &gt;=1.2.3,&lt;1.2.4</code>.</li> <li><code>${{ pin_subpackage(\"foo\", build=\"py38*\") }}</code> creates a matchspec like <code>foo &gt;=3.1,&lt;3.2.0a0 py38*</code>.</li> </ul>"},{"location":"reference/jinja/#the-pin_compatible-function","title":"The <code>pin_compatible</code> function","text":"<p>The pin compatible function works exactly as the <code>pin_subpackage</code> function, but it pins the package in the run requirements based on the resolved package of the <code>host</code> or <code>build</code> section.</p> <ul> <li><code>pin_compatible</code> pins a package in the run requirements based on the resolved   package of the <code>host</code> or <code>build</code> section.</li> </ul>"},{"location":"reference/jinja/#the-cdt-function","title":"The <code>cdt</code> function","text":"<ul> <li><code>${{ cdt(\"mypkg\") }}</code> creates a cross-dependency to another output in the   recipe.</li> </ul> <p>This function helps add Core Dependency Tree packages as dependencies by converting packages as required according to hard-coded logic. See below for an example of how this function can be used:</p> <pre><code># on x86_64 system\ncdt('package-name') # outputs: package-name-cos6-x86_64\n# on aarch64 system\ncdt('package-name') # outputs: package-name-cos6-aarch64\n</code></pre>"},{"location":"reference/jinja/#the-match-function","title":"The <code>match</code> function","text":"<p>The <code>match</code> function allows you to perform version comparisons using conda's version matching syntax. This is particularly useful for conditionally including dependencies or skipping builds based on variants.</p> <p>Syntax: <code>match(version, version_spec)</code></p> <p>Parameters: - <code>version</code>: A version string (typically from a variant variable like <code>python</code>) - <code>version_spec</code>: A conda version specification string supporting operators like <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, wildcards (<code>*</code>), and comma-separated combinations (e.g., <code>\"&gt;=3.8\"</code>, <code>\"3.14.*\"</code>, <code>\"&gt;=3.7,&lt;3.9\"</code>)</p> <p>The function returns <code>true</code> if the version matches the specification, <code>false</code> otherwise.</p>"},{"location":"reference/jinja/#usage-examples","title":"Usage examples","text":"<p>Using <code>match</code> to conditionally skip builds:</p> recipe.yaml<pre><code>build:\n  skip: match(python, \"&lt;3.8\")  # skip builds for Python &lt; 3.8\n</code></pre> <p>Using <code>match</code> with conditional dependencies:</p> recipe.yaml<pre><code>requirements:\n  host:\n    - if: match(python, \"&gt;=3.9\")\n      then: some-package\n</code></pre> <p>Note</p> <p>When using <code>match</code> for conditional dependencies, these conditions are resolved during package build time, not when the package is installed. The resulting package will have fixed dependencies based on the variant configuration used during the build.</p> <p>Checking exact version matches:</p> recipe.yaml<pre><code>build:\n  skip: match(root_base, \"&lt;6.36\")  # skip if root_base is older than 6.36\n</code></pre> <p>Using version ranges:</p> recipe.yaml<pre><code>requirements:\n  run:\n    - if: match(python, \"&gt;=3.8,&lt;3.11\")\n      then: backport-package\n</code></pre> <p>Using wildcard patterns:</p> recipe.yaml<pre><code>requirements:\n  run:\n    - if: match(python, \"3.14.*\")\n      then: python-3.14-specific-package\n</code></pre> <p>Note: The <code>match</code> function follows conda's standard version matching rules, making it more reliable than manual string parsing or comparison operations.</p>"},{"location":"reference/jinja/#the-hash-variable","title":"The <code>hash</code> variable","text":"<ul> <li><code>${{ hash }}</code> is the variant hash and is useful in the build string   computation.</li> </ul>"},{"location":"reference/jinja/#the-version_to_buildstring-function","title":"The <code>version_to_buildstring</code> function","text":"<ul> <li><code>${{ python | version_to_buildstring }}</code> converts a version from the variant   to a build string (it removes the <code>.</code> character and takes only the first two   elements of the version).</li> </ul>"},{"location":"reference/jinja/#the-env-object","title":"The <code>env</code> object","text":"<p>You can use the <code>env</code> object to retrieve environment variables and forward them to your build script. <code>${{ env.get(\"MY_ENV_VAR\") }}</code> will return the value of the environment variable <code>MY_ENV_VAR</code> or throw an error if it is not set.</p> <p>To supply a default value when the environment variable is not set, you can use <code>${{ env.get(\"MY_ENV_VAR\", default=\"default_value\") }}</code>. In this case, if <code>MY_ENV_VAR</code> is not set, the value <code>default_value</code> will be returned (and no error is thrown).</p> <p>You can also check for the existence of an environment variable:</p> <ul> <li><code>${{ env.exists(\"MY_ENV_VAR\") }}</code> will return <code>true</code> if the environment   variable <code>MY_ENV_VAR</code> is set and <code>false</code> otherwise.</li> </ul>"},{"location":"reference/jinja/#tests","title":"Tests","text":"<p>You can write tests using minijinja to check whether objects have certain properties. The syntax for a test is <code>${{ variable is test_name }}</code>.</p> <ul> <li><code>undefined</code>: Check whether a variable is undefined.</li> <li><code>defined</code>: Check whether a variable is defined.</li> <li><code>none</code>: Check whether a variable is none.</li> <li><code>safe</code>: Check whether a variable is safe.</li> <li><code>escaped</code>: Check whether a variable is escaped. Same as <code>is safe</code>.</li> <li><code>odd</code>: Check whether a number is odd.</li> <li><code>even</code>: Check whether a number is even.</li> <li><code>number</code>: Check whether a variable is a number.</li> <li><code>integer</code>: Check whether a variable is an integer.</li> <li><code>int</code>: Check whether a variable is an integer. Same as <code>is integer</code>.</li> <li><code>float</code>: Check whether a variable is a float.</li> <li><code>string</code>: Check whether a variable is a string.</li> <li><code>sequence</code>: Check whether a variable is a sequence.</li> <li><code>boolean</code>: Check whether a variable is a boolean.</li> <li><code>startingwith</code>: Check whether a variable is starting with another string: <code>${{ python is startingwith('3.12') }}</code></li> <li><code>endingwith</code>: Check whether a variable is starting with another string: <code>${{ python is endingwith('.*') }}</code></li> </ul>"},{"location":"reference/jinja/#filters","title":"Filters","text":"<p>A feature of <code>jinja</code> is called \"filters\". Filters are functions that can be applied to variables in a template expression.</p> <p>The syntax for a filter is <code>${{ variable | filter_name }}</code>. A filter can also take arguments, such as <code>... | replace('foo', 'bar')</code>.</p> <p>The following Jinja filters are available, taken from the upstream <code>minijinja</code> library:</p> <ul> <li><code>replace</code>: replace a string with another string (e.g. <code>\"${{ 'foo' | replace('oo', 'aa') }}\"</code> will return <code>\"faa\"</code>)</li> <li><code>lower</code>: convert a string to lowercase (e.g. <code>\"${{ 'FOO' | lower }}\"</code> will return <code>\"foo\"</code>)</li> <li><code>upper</code>: convert a string to uppercase (e.g. <code>\"${{ 'foo' | upper }}\"</code> will return <code>\"FOO\"</code>)</li> <li><code>int</code>: convert a string to an integer (e.g. <code>\"${{ '42' | int }}\"</code> will return <code>42</code>)</li> <li><code>abs</code>: return the absolute value of a number (e.g. <code>\"${{ -42 | abs }}\"</code> will return <code>42</code>)</li> <li><code>bool</code>: convert a value to a boolean (e.g. <code>\"${{ 'foo' | bool }}\"</code> will return <code>true</code>)</li> <li><code>default</code>: return a default value if the value is falsy (e.g. <code>\"${{ '' | default('foo') }}\"</code> will return <code>\"foo\"</code>)</li> <li><code>first</code>: return the first element of a list (e.g. <code>\"${{ [1, 2, 3] | first }}\"</code> will return <code>1</code>)</li> <li><code>last</code>: return the last element of a list (e.g. <code>\"${{ [1, 2, 3] | last }}\"</code> will return <code>3</code>)</li> <li><code>length</code>: return the length of a list (e.g. <code>\"${{ [1, 2, 3] | length }}\"</code> will return <code>3</code>)</li> <li><code>list</code>: convert a string to a list (e.g. <code>\"${{ 'foo' | list }}\"</code> will return <code>['f', 'o', 'o']</code>)</li> <li><code>join</code>: join a list with a separator (e.g. <code>\"${{ [1, 2, 3] | join('.') }}\"</code> will return <code>\"1.2.3\"</code>)</li> <li><code>min</code>: return the minimum value of a list (e.g. <code>\"${{ [1, 2, 3] | min }}\"</code> will return <code>1</code>)</li> <li><code>max</code>: return the maximum value of a list (e.g. <code>\"${{ [1, 2, 3] | max }}\"</code> will return <code>3</code>)</li> <li><code>reverse</code>: reverse a list (e.g. <code>\"${{ [1, 2, 3] | reverse }}\"</code> will return <code>[3, 2, 1]</code>)</li> <li><code>sort</code>: sort a list (e.g. <code>\"${{ [3, 1, 2] | sort }}\"</code> will return <code>[1, 2, 3]</code>)</li> <li><code>trim</code>: remove leading and trailing whitespace from a string (e.g. <code>\"${{ ' foo ' | trim }}\"</code> will return <code>\"foo\"</code>)</li> <li><code>unique</code>: remove duplicates from a list (e.g. <code>\"${{ [1, 2, 1, 3] | unique }}\"</code> will return <code>[1, 2, 3]</code>)</li> <li><code>split</code>: split a string into a list (e.g. <code>\"${{ '1.2.3' | split('.') | list }}\"</code> will return <code>['1', '2', '3']</code>). By default, splits on whitespace.</li> </ul> Removed filters <p>The following filters are removed from the builtins:</p> <ul> <li><code>attr</code></li> <li><code>indent</code></li> <li><code>select</code></li> <li><code>selectattr</code></li> <li><code>dictsort</code></li> <li><code>reject</code></li> <li><code>rejectattr</code></li> <li><code>round</code></li> <li><code>map</code></li> <li><code>title</code></li> <li><code>capitalize</code></li> <li><code>urlencode</code></li> <li><code>escape</code></li> <li><code>pprint</code></li> <li><code>safe</code></li> <li><code>items</code></li> <li><code>float</code></li> <li><code>tojson</code></li> </ul>"},{"location":"reference/jinja/#extra-filters-for-recipes","title":"Extra filters for recipes","text":""},{"location":"reference/jinja/#the-version_to_buildstring-filter","title":"The <code>version_to_buildstring</code> filter","text":"<ul> <li><code>${{ python | version_to_buildstring }}</code> converts a version from the variant   to a build string (it removes the <code>.</code> character and takes only the first two   elements of the version).</li> </ul> <p>For example the following:</p> <pre><code>context:\n  cuda: \"11.2.0\"\n\nbuild:\n  string: ${{ hash }}_cuda${{ cuda_version | version_to_buildstring }}\n</code></pre> <p>Would evaluate to a <code>abc123_cuda112</code> (assuming the hash was <code>abc123</code>).</p>"},{"location":"reference/jinja/#various-remarks","title":"Various remarks","text":""},{"location":"reference/jinja/#inline-conditionals-with-jinja","title":"Inline conditionals with Jinja","text":"<p>The new recipe format allows for inline conditionals with Jinja. If they are falsey, and no <code>else</code> branch exists, they will render to an empty string (which is, for example in a list or dictionary, equivalent to a YAML <code>null</code>).</p> <p>When a recipe is rendered, all values that are <code>null</code> must be filtered from the resulting YAML.</p> <pre><code>requirements:\n  host:\n    - ${{ \"numpy\" if cuda == \"yes\" }}\n</code></pre> <p>If <code>cuda</code> is not equal to yes, the first item of the host requirements will be empty (null) and thus filtered from the final list.</p> <p>This must also work for dictionary values. For example:</p> <pre><code>build:\n  number: ${{ 100 if cuda == \"yes\" }}\n  # or an `else` branch can be used, of course\n  number: ${{ 100 if cuda == \"yes\" else 0 }}\n</code></pre>"},{"location":"reference/jinja/#comments","title":"Comments","text":"<p>Jinja comments use the standard <code>{# ... #}</code> syntax. Anything between <code>{#</code> and <code>#}</code> is stripped from the output and can span multiple lines.</p> <pre><code>context:\n  name: mypackage\n  version: \"1.0\"\n\npackage:\n  name: ${{ name }}  {# this comment will not appear in the output #}\n  version: ${{ version }}\n</code></pre> <p>Multiline comments are also supported:</p> <pre><code>package:\n  name: mypackage\n  {#\n    This is a multiline comment.\n    It will be completely removed from the output.\n  #}\n  version: \"1.0\"\n</code></pre>"},{"location":"reference/jinja/#slicing-lists","title":"Slicing lists","text":"<p>Lists can be spliced using the regular Python <code>[i:j]</code> syntax.  Note that when lists are obtained through using filters such as <code>split</code>, the whole filter expression needs to be parenthesized.</p> <p>For example, to slice a version string from <code>x.y.z</code> to <code>x.y</code>:</p> <pre><code>${{ (version | split('.'))[:2] | join('.') }}\n</code></pre>"},{"location":"reference/multi_output/","title":"Multi-Output Recipes","text":""},{"location":"reference/multi_output/#overview","title":"Overview","text":"<p>A multi-output recipe produces multiple packages from a single <code>recipe.yaml</code> file. Multi-output recipes are used when a single source tree produces multiple packages. Common examples include splitting a C library into runtime, development, and language binding packages.</p> <p>In a multi-output recipe each output is a self-contained recipe with its own <code>package</code>, <code>build</code>, <code>requirements</code>, <code>tests</code>, and <code>about</code> sections.</p>"},{"location":"reference/multi_output/#basic-structure","title":"Basic Structure","text":"<p>A minimal multi-output recipe with two package outputs:</p> <pre><code>recipe:\n  name: my-project\n  version: 1.0.0\n\nsource:\n  - url: https://example.com/my-project-1.0.0.tar.gz\n    sha256: abcdef...\n\noutputs:\n  - package:\n      name: my-lib\n    build:\n      script:\n        - mkdir -p $PREFIX/lib\n        - cp libfoo.so $PREFIX/lib/\n    requirements:\n      run:\n        - some-runtime-dep\n    tests:\n      - script:\n          - test -f $PREFIX/lib/libfoo.so\n\n  - package:\n      name: my-tool\n    requirements:\n      run:\n        - ${{ pin_subpackage('my-lib', upper_bound='x.x') }}\n    build:\n      script:\n        - mkdir -p $PREFIX/bin\n        - cp my-tool $PREFIX/bin/\n    tests:\n      - script:\n          - my-tool --version\n</code></pre>"},{"location":"reference/multi_output/#connecting-outputs-with-pin_subpackage","title":"Connecting outputs with <code>pin_subpackage</code>","text":"<p>Use <code>pin_subpackage()</code> to create a dependency from one output to another within the same recipe:</p> <pre><code>requirements:\n  run:\n    - ${{ pin_subpackage('my-lib', upper_bound='x.x') }}\n</code></pre> <p>With <code>exact=True</code>, the dependent package is injected as a variant. This means if <code>my-lib</code> has two variant builds (e.g., against <code>openssl 1</code> and <code>openssl 3</code>), <code>my-tool</code> will also be built twice \u2014 once for each <code>my-lib</code> variant:</p> <pre><code>outputs:\n  - package:\n      name: my-lib\n    requirements:\n      host:\n        - openssl\n  - package:\n      name: my-tool\n    requirements:\n      run:\n        - ${{ pin_subpackage('my-lib', exact=True) }}\n</code></pre>"},{"location":"reference/multi_output/#topological-sorting","title":"Topological sorting","text":"<p>Outputs are topologically sorted based on their dependency relationships. If one output depends on another (for example via <code>pin_subpackage</code> or by referencing its name in requirements), the dependent output will be built after its dependency.</p> <p>The order of entries in <code>outputs:</code> does not affect build order.</p>"},{"location":"reference/multi_output/#inheritance-behavior","title":"Inheritance Behavior","text":"<p>Top-level sections are inherited by all outputs unless the output overrides them:</p> Section Inherited? Notes <code>source</code> Yes Available to all outputs <code>build</code> Yes <code>number</code>, <code>script</code>, etc. can be overridden <code>about</code> Yes Per-output <code>about</code> overrides top-level <code>tests</code> Yes Top-level tests are prepended to output tests <code>extra</code> Yes Merged into each output <code>context</code> Yes Variables are available during rendering of all outputs <p>The <code>package</code> and <code>requirements</code> keys are forbidden at the top level in multi-output recipes. Each output must define its own <code>package:</code> and <code>requirements:</code> sections.</p> <pre><code>recipe:\n  name: my-project\n  version: 2.0.0\n\n# These are inherited by all outputs:\nabout:\n  license: MIT\n  homepage: https://example.com\n\nbuild:\n  number: 0\n\noutputs:\n  - package:\n      name: output-a\n      # version defaults to 2.0.0 from recipe.version\n    # inherits about.license, about.homepage, build.number\n\n  - package:\n      name: output-b\n      version: 3.0.0  # overrides recipe.version\n    about:\n      license: Apache-2.0  # overrides inherited license\n</code></pre>"},{"location":"reference/multi_output/#staging-outputs-experimental","title":"Staging Outputs (Experimental)","text":"<p>Warning</p> <p>Staging outputs require the <code>--experimental</code> flag: <code>rattler-build build --experimental -r recipe.yaml</code></p> <p>A staging output compiles code once and caches the result. Package outputs then inherit from the staging cache and select subsets of the built files. This avoids rebuilding the same source for each package.</p>"},{"location":"reference/multi_output/#basic-staging-example","title":"Basic staging example","text":"<pre><code>recipe:\n  name: mylib\n  version: 2.0.0\n\nsource:\n  - url: https://example.com/mylib-2.0.0.tar.gz\n    sha256: abcdef...\n\noutputs:\n  # Staging: builds the library once\n  - staging:\n      name: mylib-build\n    requirements:\n      build:\n        - ${{ compiler('c') }}\n        - cmake\n        - ninja\n    build:\n      script:\n        - cmake -GNinja -DCMAKE_INSTALL_PREFIX=$PREFIX .\n        - ninja install\n\n  # Package: runtime library\n  - package:\n      name: libmylib\n    inherit: mylib-build\n    build:\n      files:\n        - lib/*\n    requirements:\n      run_exports:\n        - ${{ pin_subpackage('libmylib') }}\n\n  # Package: development headers\n  - package:\n      name: mylib-headers\n    inherit: mylib-build\n    build:\n      files:\n        - include/*\n    requirements:\n      run:\n        - ${{ pin_subpackage('libmylib', exact=True) }}\n</code></pre>"},{"location":"reference/multi_output/#the-inherit-key","title":"The <code>inherit</code> key","text":"<p>The <code>inherit:</code> key specifies which staging cache a package output inherits from.</p> <p>Short form \u2014 inherit all files and run exports:</p> <pre><code>inherit: mylib-build\n</code></pre> <p>Structured form \u2014 control run export inheritance:</p> <pre><code>inherit:\n  from: mylib-build\n  run_exports: false  # do not inherit run exports from staging\n</code></pre>"},{"location":"reference/multi_output/#run-exports-from-staging","title":"Run exports from staging","text":"<p>Run exports from the staging output's build/host dependencies are propagated to inheriting package outputs by default. Use <code>run_exports: false</code> in the structured <code>inherit:</code> form to suppress this.</p> <p>If the staging output has <code>ignore_run_exports</code>, those filters apply at the staging level. If an inheriting output also ignores run exports, both filters apply.</p>"},{"location":"reference/multi_output/#source-handling-with-staging","title":"Source handling with staging","text":"<p>The top-level <code>source:</code> is available to the staging output and all package outputs. Each output restores the (dirty) source from the staging directory, so outputs can continue from where the staging build left off (e.g., running <code>cmake install</code> after staging already ran <code>cmake build</code>).</p> <p>Outputs can add additional sources on top of the staging source:</p> <pre><code>outputs:\n  - package:\n      name: py-mylib\n    inherit: mylib-build\n    source:\n      - path: ../README.md\n        file_name: extra_file.md\n</code></pre>"},{"location":"reference/multi_output/#file-selection","title":"File Selection","text":"<p>In multi-output recipes, use <code>build: files:</code> to select which files from the prefix end up in each package. This is especially important with staging outputs to avoid packaging the same files in multiple packages.</p> <pre><code>build:\n  files:\n    - lib/*.so\n    - lib/*.so.*\n</code></pre> <p>For more advanced selection with include/exclude patterns, see the build options documentation.</p>"},{"location":"reference/recipe_file/","title":"The recipe spec","text":"<p><code>rattler-build</code> implements a new recipe spec, different from the traditional \"<code>meta.yaml</code>\" file used in <code>conda-build</code>. A recipe has to be stored as a <code>recipe.yaml</code> file.</p>"},{"location":"reference/recipe_file/#history","title":"History","text":"<p>A discussion was started on what a new recipe spec could or should look like. The fragments of this discussion can be found here.</p> <p>The reason for a new spec are:</p> <ul> <li>make it easier to parse (i.e. \"pure YAML\"); <code>conda-build</code> uses a mix of comments   and Jinja to achieve a great deal of flexibility, but it's hard to parse the   recipe with a computer</li> <li>iron out some inconsistencies around multiple outputs (<code>build</code> vs. <code>build/script</code>   and more)</li> <li>remove any need for recursive parsing &amp; solving</li> <li>finally, the initial implementation in <code>boa</code> relied on <code>conda-build</code>;   <code>rattler-build</code> removes any dependency on Python or <code>conda-build</code> and   reimplements everything in Rust</li> </ul>"},{"location":"reference/recipe_file/#major-differences-from-conda-build","title":"Major differences from <code>conda-build</code>","text":"<ul> <li>recipe filename is <code>recipe.yaml</code>, not <code>meta.yaml</code></li> <li>outputs have less complicated behavior, keys are same as top-level recipe   (e.g. <code>build/script</code>, not just <code>script</code> and <code>package/name</code>, not just <code>name</code>)</li> <li>no implicit meta-packages in outputs</li> <li>no full Jinja2 support: no conditional or <code>{% set ...</code> support, only string   interpolation; variables can be set in the toplevel \"context\" which is valid   YAML</li> <li>Jinja string interpolation needs to be preceded by a dollar sign at the   beginning of a string, e.g. <code>- ${{ version }}</code> in order for it to be valid   YAML</li> <li> <p>selectors use a YAML dictionary style (vs. comments in conda-build). Instead   of <code>- somepkg  #[osx]</code> we use:   <pre><code>if: osx\nthen:\n  - somepkg\n</code></pre></p> </li> <li> <p><code>skip</code> instruction uses a list of skip conditions and not the selector syntax   from <code>conda-build</code> (e.g. <code>skip: [\"osx\", \"win and py37\"]</code>)</p> </li> </ul>"},{"location":"reference/recipe_file/#spec","title":"Spec","text":"<p>The recipe spec has the following parts:</p> <ul> <li> <code>context</code>: to set up variables that can later be used in Jinja string   interpolation</li> <li> <code>package</code>: defines name, version etc. of the top-level package</li> <li> <code>source</code>: points to the sources that need to be downloaded in order to   build the recipe</li> <li> <code>build</code>: defines how to build the recipe and what build number to use</li> <li> <code>requirements</code>: defines requirements of the top-level package</li> <li> <code>tests</code>: defines tests for the top-level package</li> <li> <code>outputs</code>: a recipe can have multiple outputs. Each output can and should   have a <code>package</code>, <code>requirements</code> and <code>test</code> section</li> </ul>"},{"location":"reference/recipe_file/#spec-reference","title":"Spec reference","text":"<p>The spec is also made available through a JSON Schema (which is used for validation). The schema (and <code>pydantic</code> source file) can be found in this repository: <code>recipe-format</code></p> <p>See more in the automatic linting chapter.</p>"},{"location":"reference/recipe_file/#examples","title":"Examples","text":"recipe.yaml<pre><code># this sets up \"context variables\" (in this case name and version) that\n# can later be used in Jinja expressions\ncontext:\n  version: 1.1.0\n  name: imagesize\n\n# top level package information (name and version)\npackage:\n  name: ${{ name }}\n  version: ${{ version }}\n\n# location to get the source from\nsource:\n  url: https://pypi.io/packages/source/${{ name[0] }}/${{ name }}/${{ name }}-${{ version }}.tar.gz\n  sha256: f3832918bc3c66617f92e35f5d70729187676313caa60c187eb0f28b8fe5e3b5\n\n# build number (should be incremented if a new build is made, but version is not incrementing)\nbuild:\n  number: 1\n  script: python -m pip install .\n\n# the requirements at build and runtime\nrequirements:\n  host:\n    - python\n    - pip\n  run:\n    - python\n\n# tests to validate that the package works as expected\ntests:\n  - python:\n      imports:\n        - imagesize\n\n# information about the package\nabout:\n  homepage: https://github.com/shibukawa/imagesize_py\n  license: MIT\n  summary: \"Getting image size from png/jpeg/jpeg2000/gif file\"\n  description: |\n    This module analyzes jpeg/jpeg2000/png/gif image header and\n    return image size.\n  repository: https://github.com/shibukawa/imagesize_py\n  documentation: https://pypi.python.org/pypi/imagesize\n\n# the below is conda-forge specific!\nextra:\n  recipe-maintainers:\n    - somemaintainer\n</code></pre>"},{"location":"reference/recipe_file/#package-section","title":"Package section","text":"<p>Specifies package information.</p> <pre><code>package:\n  name: bsdiff4\n  version: \"2.1.4\"\n</code></pre> <ul> <li>name: The lower case name of the package. It may contain \"<code>-</code>\", but no   spaces.</li> <li>version: The version number of the package. Use the PEP-386 verlib   conventions. Cannot contain \"<code>-</code>\". YAML interprets version numbers such as 1.0   as floats, meaning that 0.10 will be the same as 0.1. To avoid this, put the   version number in quotes so that it is interpreted as a string.</li> </ul>"},{"location":"reference/recipe_file/#source-section","title":"Source section","text":"<p>Specifies where the source code of the package is coming from. The source may come from a tarball file, <code>git</code>, <code>hg</code>, or <code>svn</code>. It may be a local path and it may contain patches.</p>"},{"location":"reference/recipe_file/#source-from-tarball-or-zip-archive","title":"Source from tarball or <code>zip</code> archive","text":"<pre><code>source:\n  url: https://pypi.python.org/packages/source/b/bsdiff4/bsdiff4-1.1.4.tar.gz\n  md5: 29f6089290505fc1a852e176bd276c43\n  sha1: f0a2c9a30073449cfb7d171c57552f3109d93894\n  sha256: 5a022ff4c1d1de87232b1c70bde50afbb98212fd246be4a867d8737173cf1f8f\n</code></pre> <p>If an extracted archive contains only 1 folder at its top level, its contents will be moved 1 level up, so that the extracted package contents sit in the root of the work folder.</p>"},{"location":"reference/recipe_file/#specifying-a-file-name","title":"Specifying a file name","text":"<p>For URL and local path sources, <code>file_name</code> renames the downloaded file in the work directory. The primary use case is giving a clean name to pre-built binaries whose URL path segments are not descriptive:</p> <pre><code>source:\n  url: https://github.com/owner/project/releases/download/v1.0.0/project-v1.0.0-linux-amd64\n  sha256: &lt;sha256&gt;\n  file_name: project  # rename to a clean, platform-independent name\n</code></pre> <p>Setting <code>file_name</code> disables automatic archive extraction</p> <p>When <code>file_name</code> is set on an archive source (<code>.tar.gz</code>, <code>.zip</code>, <code>.7z</code>, etc.), the archive is not extracted \u2014 it is placed in the work directory as-is under the given name. This is true even if <code>file_name</code> is set to the same name the archive would have had by default:</p> <pre><code>source:\n  url: https://pypi.python.org/packages/source/b/bsdiff4/bsdiff4-1.1.4.tar.gz\n  sha256: 5a022ff4c1d1de87232b1c70bde50afbb98212fd246be4a867d8737173cf1f8f\n  # The archive is NOT extracted \u2014 it is placed as bsdiff4-1.1.4.tar.gz in the work directory\n  file_name: bsdiff4-1.1.4.tar.gz\n</code></pre> <p>To download an archive and have it extracted automatically (the default behaviour), omit <code>file_name</code>:</p> <pre><code>source:\n  url: https://pypi.python.org/packages/source/b/bsdiff4/bsdiff4-1.1.4.tar.gz\n  sha256: 5a022ff4c1d1de87232b1c70bde50afbb98212fd246be4a867d8737173cf1f8f\n  # file_name is not set \u2014 the archive is extracted into the work directory\n</code></pre>"},{"location":"reference/recipe_file/#source-from-git","title":"Source from <code>git</code>","text":"<pre><code>source:\n  git: https://github.com/ilanschnell/bsdiff4.git\n  # branch: master # note: defaults to fetching the repo's default branch\n</code></pre> <p>You can use <code>rev</code> to pin the commit version directly:</p> <pre><code>source:\n  git: https://github.com/ilanschnell/bsdiff4.git\n  rev: \"50a1f7ed6c168eb0815d424cba2df62790f168f0\"\n</code></pre> <p>Or you can use the <code>tag</code>:</p> <pre><code>source:\n  git: https://github.com/ilanschnell/bsdiff4.git\n  tag: \"1.1.4\"\n</code></pre> <p><code>git</code> can also be a relative path to the recipe directory:</p> <pre><code>source:\n  git: ../../bsdiff4/.git\n  tag: \"1.1.4\"\n</code></pre> <p>Furthermore, if you want to fetch just the current \"<code>HEAD</code>\" (this may result in non-deterministic builds), then you can use <code>depth</code>.</p> <pre><code>source:\n  git: https://github.com/ilanschnell/bsdiff4.git\n  depth: 1 # note: the behaviour defaults to -1\n</code></pre> <p>Note: <code>tag</code> or <code>rev</code> may not be available within commit depth range, hence we don't allow using <code>rev</code> or the <code>tag</code> and <code>depth</code> of them together if not set to <code>-1</code>.</p> <pre><code>source:\n  git: https://github.com/ilanschnell/bsdiff4.git\n  tag: \"1.1.4\"\n  depth: 1 # error: use of `depth` with `rev` is invalid, they are mutually exclusive\n</code></pre> <p>When you want to use <code>git-lfs</code>, you need to set <code>lfs: true</code>. This will also pull the <code>lfs</code> files from the repository.</p> <pre><code>source:\n  git: ../../bsdiff4/.git\n  tag: \"1.1.4\"\n  lfs: true # note: defaults to false\n</code></pre> <p>By default, rattler-build will recursively initialize and update all git submodules. For repositories with large or numerous submodules that aren't needed for the build, you can disable this by setting <code>submodules: false</code>:</p> <pre><code>source:\n  git: https://github.com/riscv-collab/riscv-gnu-toolchain.git\n  tag: \"2024.09.03\"\n  submodules: false # note: defaults to true\n</code></pre> <p>If you need only specific submodules, set <code>submodules: false</code> and initialize them manually in your build script.</p>"},{"location":"reference/recipe_file/#verifying-commit-hash-with-expected_commit","title":"Verifying commit hash with <code>expected_commit</code>","text":"<p>Note</p> <p>This feature is only available with <code>--experimental</code> as it was not part of the standardization yet.</p> <p>For security and reproducibility, you can specify an <code>expected_commit</code> field to verify that the checked out commit matches the expected SHA hash. This is useful to detect if a tag or branch has been moved to point to a different commit:</p> <pre><code>source:\n  git: https://github.com/ilanschnell/bsdiff4.git\n  tag: \"1.1.4\"\n  expected_commit: 50a1f7ed6c168eb0815d424cba2df62790f168f0\n</code></pre> <p>If the actual commit does not match the expected commit, the build will fail with an error message indicating the mismatch. This feature is inspired by Wolfi/Melange and provides an additional layer of security for your builds.</p>"},{"location":"reference/recipe_file/#source-from-a-local-path","title":"Source from a local path","text":"<p>If the path is relative, it is taken relative to the recipe directory. The source is copied to the work directory before building.</p> <pre><code>  source:\n    path: ../src\n    use_gitignore: false # note: defaults to true\n</code></pre> <p>By default, all files in the local path that are ignored by <code>git</code> are also ignored by <code>rattler-build</code>. You can disable this behavior by setting <code>use_gitignore</code> to <code>false</code>.</p>"},{"location":"reference/recipe_file/#patches","title":"Patches","text":"<p>Patches may optionally be applied to the source.</p> <pre><code>  source:\n    #[source information here]\n    patches:\n      - my.patch # the patch file is expected to be found in the recipe\n</code></pre>"},{"location":"reference/recipe_file/#destination-path","title":"Destination path","text":"<p>Within <code>rattler-build</code>'s work directory, you may specify a particular folder to place the source into. <code>rattler-build</code> will always drop you into the same folder (<code>[build folder]/work</code>), but it's up to you whether you want your source extracted into that folder, or nested deeper. This feature is particularly useful when dealing with multiple sources, but can apply to recipes with single sources as well.</p> <pre><code>source:\n  #[source information here]\n  target_directory: my-destination/folder\n</code></pre>"},{"location":"reference/recipe_file/#attestation-verification-experimental","title":"Attestation verification (experimental)","text":"<p>Note</p> <p>This feature requires the <code>--experimental</code> flag.</p> <p>For URL sources, you can specify an <code>attestation</code> block to verify that the downloaded archive was built by an expected publisher using Sigstore attestations.</p> <pre><code>source:\n  url: https://files.pythonhosted.org/packages/.../flask-3.1.1.tar.gz\n  sha256: \"...\"\n  attestation:\n    publishers:\n      - github:pallets/flask\n</code></pre> <p>The attestation config has the following fields:</p> <ul> <li><code>publishers</code> - A list of publisher identities in <code>github:owner/repo</code> format. At least one   publisher must match for verification to succeed.</li> <li><code>bundle_url</code> (optional) - URL to the Sigstore bundle file. For PyPI sources, this is   automatically derived from the PyPI attestation API. For GitHub releases, use the pattern   <code>https://github.com/{owner}/{repo}/releases/download/{tag}/{filename}.sigstore.json</code>.</li> </ul> <p>See the Sigstore source attestation documentation for more details and examples.</p>"},{"location":"reference/recipe_file/#source-from-multiple-sources","title":"Source from multiple sources","text":"<p>Some software is most easily built by aggregating several pieces.</p> <p>The syntax is a list of source dictionaries. Each member of this list follows the same rules as the single source. All features for each member are supported.</p> <p>Example:</p> <pre><code>source:\n  - url: https://package1.com/a.tar.bz2\n    target_directory: stuff\n  - url: https://package1.com/b.tar.bz2\n    target_directory: stuff\n  - git: https://github.com/mamba-org/boa\n    target_directory: boa\n</code></pre> <p>Here, the two URL tarballs will go into one folder, and the <code>git</code> repo is checked out into its own space. <code>git</code> will not clone into a non-empty folder.</p>"},{"location":"reference/recipe_file/#include-only-certain-files-from-source","title":"Include only certain files from source","text":"<p>While you can specify only the files you need from a source, <code>source.filter</code> gives you the option to filter with globs instead.</p> recipe.yaml<pre><code>source:\n  path: /path/to/source\n  filter:\n    - list\n    - of\n    - globs\n</code></pre> <p>Glob patterns throughout the recipe file can also use a flexible <code>include</code> / <code>exclude</code> pair, such as:</p> recipe.yaml<pre><code>source:\n  path: /path/to/source\n  filter:\n    include:\n      - include/**/*.h\n    exclude:\n      - include/**/private.h\n</code></pre>"},{"location":"reference/recipe_file/#build-section","title":"Build section","text":"<p>Specifies build information.</p> <p>Each field that expects a path can also handle a glob pattern. The matching is performed from the top of the build environment, so to match files inside your project you can use a pattern similar to the following one: <code>\"**/myproject/**/*.txt\"</code>. This pattern will match any <code>.txt</code> file found in your project. Quotation marks (<code>\"\"</code>) are required for patterns that start with a <code>*</code>.</p> <p>Recursive globbing using <code>**</code> is also supported.</p>"},{"location":"reference/recipe_file/#build-number-and-string","title":"Build number and string","text":"<p>The build number should be incremented for new builds of the same version. The number defaults to <code>0</code>. The build string cannot contain \"<code>-</code>\". The string defaults to the default <code>rattler-build</code> build string plus the build number.</p> <pre><code>build:\n  number: 1\n  string: abc\n</code></pre>"},{"location":"reference/recipe_file/#dynamic-linking","title":"Dynamic linking","text":"<p>This section contains settings for the shared libraries and executables.</p> <pre><code>build:\n  dynamic_linking:\n    rpath_allowlist: [\"/usr/lib/**\"]\n</code></pre>"},{"location":"reference/recipe_file/#script","title":"Script","text":"<p>By default, <code>rattler-build</code> uses a <code>build.sh</code> file on Unix (macOS and Linux) and a <code>build.bat</code> file on Windows, if they exist in the same folder as the <code>recipe.yaml</code> file. With the script parameter you can either supply a different filename or write out short build scripts. You may need to use selectors to use different scripts for different platforms.</p> <pre><code>build:\n  # A very simple build script\n  script: pip install .\n\n  # The build script can also be a list\n  script:\n    - pip install .\n    - echo \"hello world\"\n    - if: unix\n      then:\n        - echo \"unix\"\n</code></pre> <p>There are many other configurable settings, such as environment variables and secrets. Please see Build script for more information.</p>"},{"location":"reference/recipe_file/#skipping-builds","title":"Skipping builds","text":"<p>Lists conditions under which <code>rattler-build</code> should skip the build of this recipe. Particularly useful for defining recipes that are platform-specific. By default, a build is never skipped.</p> <pre><code>build:\n  skip:\n    - win\n    ...\n</code></pre>"},{"location":"reference/recipe_file/#architecture-independent-packages","title":"Architecture-independent packages","text":"<p>Allows you to specify \"no architecture\" when building a package, thus making it compatible with all platforms and architectures. Architecture-independent packages can be installed on any platform.</p> <p>Assigning the <code>noarch</code> key as <code>generic</code> tells <code>conda</code> to not try any manipulation of the contents.</p> <pre><code>build:\n  noarch: generic\n</code></pre> <p><code>noarch: generic</code> is most useful for packages such as static JavaScript assets and source archives. For pure Python packages (similar to <code>none-any</code> wheels) that can run on any Python version, you can use the <code>noarch: python</code> value instead:</p> <pre><code>build:\n  noarch: python\n</code></pre> <p>Note</p> <p>At the time of this writing, <code>noarch</code> packages should not make use of preprocess-selectors: <code>noarch</code> packages are built with the directives which evaluate to <code>true</code> in the platform it is built on, which probably will result in incorrect/incomplete installation in other platforms.</p>"},{"location":"reference/recipe_file/#include-only-certain-files-in-the-package","title":"Include only certain files in the package","text":"<p>Sometimes you may want to include only a subset of the files installed by the build process in your package. For this, the <code>files</code> key can be used. Only new files are considered for inclusion (ie. files that were not in the host environment beforehand).</p> recipe.yaml<pre><code>build:\n  # select files to be included in the package\n  # this can be used to remove files from the package, even if they are installed in the\n  # environment\n  files:\n    - list\n    - of\n    - globs\n</code></pre> <p>Glob patterns throughout the recipe file can also use a flexible <code>include</code> / <code>exclude</code> pair, such as:</p> recipe.yaml<pre><code>build:\n  files:\n    include:\n      - include/**/*.h\n    exclude:\n      - include/**/private.h\n</code></pre>"},{"location":"reference/recipe_file/#python-specific-options","title":"Python specific options","text":""},{"location":"reference/recipe_file/#entry-points","title":"Entry points","text":"<p>The following example creates a Python entry point named \"<code>bsdiff4</code>\" that calls <code>bsdiff4.cli.main_bsdiff4()</code>. This is needed in <code>noarch: python</code> packages to create OS specific entry points at installation time.</p> <pre><code>build:\n  python:\n    entry_points:\n      - bsdiff4 = bsdiff4.cli:main_bsdiff4\n      - bspatch4 = bsdiff4.cli:main_bspatch4\n</code></pre>"},{"location":"reference/recipe_file/#version-independent-abi3-packages","title":"Version independent (ABI3) packages","text":"<p>Since rattler-build 0.35.0 and CEP 20 you can create version-independent Python packages that still contain compiled code.</p> <p>ABI3 packages support building a native Python extension using a specific Python version and running it against any later Python version. ABI3 or stable ABI is supported by only CPython - the reference Python implementation with the Global Interpreter Lock (GIL) enabled.</p> <pre><code>build:\n  python:\n    version_independent: true  # defaults to false\n</code></pre>"},{"location":"reference/recipe_file/#include-build-recipe","title":"Include build recipe","text":"<p>The recipe and rendered <code>recipe.yaml</code> file are included in the <code>package_metadata</code> by default. You can disable this by passing <code>--no-include-recipe</code> on the command line.</p> <p>Note</p> <p>There are many more options in the build section. These additional options control how variants are computed, prefix replacements, and more. See the full build options for more information.</p>"},{"location":"reference/recipe_file/#requirements-section","title":"Requirements section","text":"<p>Specifies the build and runtime requirements. Dependencies of these requirements are included automatically.</p> <p>Versions for requirements must follow the <code>conda</code>/<code>mamba</code> match specification. See <code>build-version-spec</code>.</p>"},{"location":"reference/recipe_file/#build","title":"Build","text":"<p>Tools required to build the package.</p> <p>These packages are run on the build system and include things such as version control systems (<code>git</code>, <code>svn</code>) make tools (GNU make, Autotool, CMake) and compilers (real cross, pseudo-cross, or native when not cross-compiling), and any source pre-processors.</p> <p>Packages which provide \"<code>sysroot</code>\" files, like the <code>CDT</code> packages (see below), also belong in the <code>build</code> section.</p> <pre><code>requirements:\n  build:\n    - git\n    - cmake\n</code></pre>"},{"location":"reference/recipe_file/#host","title":"Host","text":"<p>Represents packages that need to be specific to the target platform when the target platform is not necessarily the same as the native build platform. For example, in order for a recipe to be \"cross-capable\", shared libraries requirements must be listed in the <code>host</code> section, rather than the <code>build</code> section, so that the shared libraries that get linked are ones for the target platform, rather than the native build platform. You should also include the base interpreter for packages that need one. In other words, a Python package would list <code>python</code> here and an R package would list <code>mro-base</code> or <code>r-base</code>.</p> <pre><code>requirements:\n  build:\n    - ${{ compiler('c') }}\n    - if: linux\n      then:\n        - ${{ cdt('xorg-x11-proto-devel') }}\n  host:\n    - python\n</code></pre> <p>Note</p> <p>When both \"<code>build</code>\" and \"<code>host</code>\" sections are defined, the <code>build</code> section can be thought of as \"build tools\" - things that run on the native platform, but output results for the target platform (e.g. a cross-compiler that runs on <code>linux-64</code>, but targets <code>linux-armv7</code>).</p> <p>The <code>PREFIX</code> environment variable points to the host prefix. With respect to activation during builds, both the host and build environments are activated. The build prefix is activated before the host prefix so that the host prefix has priority over the build prefix. Executables that don't exist in the host prefix should be found in the build prefix.</p> <p>The <code>build</code> and <code>host</code> prefixes are always separate when both are defined, or when <code>${{ compiler() }}</code> Jinja2 functions are used. The only time that <code>build</code> and <code>host</code> are merged is when the <code>host</code> section is absent, and no <code>${{ compiler() }}</code> Jinja2 functions are used in <code>meta.yaml</code>.</p>"},{"location":"reference/recipe_file/#run","title":"Run","text":"<p>Packages required to run the package.</p> <p>These are the dependencies that are installed automatically whenever the package is installed. Package names should follow the package match specifications.</p> <pre><code>requirements:\n  run:\n    - python\n    - six &gt;=1.8.0\n</code></pre> <p>To build a recipe against different versions of NumPy and ensure that each version is part of the package dependencies, list <code>numpy</code> as a requirement in <code>recipe.yaml</code> and use a <code>conda_build_config.yaml</code> file with multiple NumPy versions.</p>"},{"location":"reference/recipe_file/#run-constraints","title":"Run constraints","text":"<p>Packages that are optional at runtime but must obey the supplied additional constraint if they are installed.</p> <p>Package names should follow the package match specifications.</p> <pre><code>requirements:\n  run_constraints:\n    - optional-subpackage ==${{ version }}\n</code></pre> <p>For example, let's say we have an environment that has package \"a\" installed at version 1.0. If we install package \"b\" that has a <code>run_constraints</code> entry of \"<code>a &gt;1.0</code>\", then <code>mamba</code> would need to upgrade \"a\" in the environment in order to install \"b\".</p> <p>This is especially useful in the context of virtual packages, where the <code>run_constraints</code> dependency is not a package that <code>mamba</code> manages, but rather a virtual package that represents a system property that <code>mamba</code> can't change. For example, a package on Linux may impose a <code>run_constraints</code> dependency on <code>__glibc &gt;=2.12</code>. This is the version bound consistent with CentOS 6. Software built against glibc 2.12 will be compatible with CentOS 6. This <code>run_constraints</code> dependency helps <code>mamba</code>, <code>conda</code> or <code>pixi</code> tell the user that a given package can't be installed if their system glibc version is too old.</p>"},{"location":"reference/recipe_file/#run-exports","title":"Run exports","text":"<p>Packages may have runtime requirements such as shared libraries (e.g. <code>zlib</code>), which are required for linking at build time, and for resolving the link at run time. With <code>run_exports</code> packages runtime requirements can be implicitly added. <code>run_exports</code> are weak by default, these two requirements for the <code>zlib</code> package are therefore equivalent:</p> recipe.yaml for zlib<pre><code>  requirements:\n    run_exports:\n      - ${{ pin_subpackage('libzlib', exact=True) }}\n</code></pre> recipe.yaml for zlib<pre><code>  requirements:\n    run_exports:\n      weak:\n        - ${{ pin_subpackage('libzlib', exact=True) }}\n</code></pre> <p>The alternative to <code>weak</code> is <code>strong</code>. For <code>gcc</code> this would look like this:</p> recipe.yaml for gcc<pre><code>  requirements:\n    run_exports:\n      strong:\n        - ${{ pin_subpackage('libgcc', exact=True) }}\n</code></pre> <p><code>weak</code> exports will only be implicitly added as runtime requirement, if the package is a host dependency. <code>strong</code> exports will be added for both build and host dependencies. In the following example you can see the implicitly added runtime dependencies.</p> recipe.yaml of some package using gcc and zlib<pre><code>  requirements:\n    build:\n      - gcc            # has a strong run export\n    host:\n      - zlib           # has a (weak) run export\n      # - libgcc       &lt;-- implicitly added by gcc\n    run:\n      # - libgcc       &lt;-- implicitly added by gcc\n      # - libzlib      &lt;-- implicitly added by libzlib\n</code></pre>"},{"location":"reference/recipe_file/#ignore-run-exports","title":"Ignore run exports","text":"<p>There maybe cases where an upstream package has a problematic <code>run_exports</code> constraint. You can ignore it in your recipe by listing the upstream package name in the <code>ignore_run_exports</code> section in <code>requirements</code>.</p> <p>You can ignore them by package name, or by naming the runtime dependency directly.</p> <pre><code>  requirements:\n    ignore_run_exports:\n      from_package:\n        - zlib\n</code></pre> <p>Using a runtime dependency name:</p> <pre><code>  requirements:\n    ignore_run_exports:\n      by_name:\n        - libzlib\n</code></pre> <p>Note</p> <p><code>ignore_run_exports</code> only applies to runtime dependencies coming from an upstream package.</p>"},{"location":"reference/recipe_file/#tests-section","title":"Tests section","text":"<p><code>rattler-build</code> supports four different types of tests. The \"script test\" installs the package and runs a list of commands. The \"Python test\" attempts to import a list of Python modules and runs <code>pip check</code>. The \"downstream test\" runs the tests of a downstream package that reverse depends on the package being built. And lastly, the \"package content test\" checks if the built package contains the mentioned items.</p> <p>The <code>tests</code> section is a list of these items:</p> <pre><code>tests:\n  - script:\n      - echo \"hello world\"\n    requirements:\n      run:\n        - pytest\n    files:\n      source:\n        - test-data.txt\n\n  - python:\n      imports:\n        - bsdiff4\n      pip_check: true  # this is the default\n  - downstream: numpy\n</code></pre>"},{"location":"reference/recipe_file/#script-test","title":"Script test","text":"<p>The script test has 3 top-level keys: <code>script</code>, <code>files</code> and <code>requirements</code>. Only the <code>script</code> key is required.</p>"},{"location":"reference/recipe_file/#test-commands","title":"Test commands","text":"<p>Commands that are run as part of the test.</p> <pre><code>tests:\n  - script:\n      - echo \"hello world\"\n      - bsdiff4 -h\n      - bspatch4 -h\n</code></pre>"},{"location":"reference/recipe_file/#external-scripts","title":"External scripts","text":"<p>You can also easily run a script from your recipe directory. Note that your package should either depend on the interpreter (e.g. Python or R) or you need to add a <code>requirements</code> section to the test that installs the interpreter.</p> <pre><code>tests:\n  - script: tests/run_test.py\n  - script: tests/run_test.R\n  - script: tests/run_test.sh\n</code></pre>"},{"location":"reference/recipe_file/#extra-test-files","title":"Extra test files","text":"<p>Test files that are copied from the source work directory into the temporary test directory and are needed during testing (note that the source work directory is otherwise not available at all during testing).</p> <p>You can also include files that come from the <code>recipe</code> folder. They are copied into the test directory as well.</p> <p>At test execution time, the test directory is the current working directory.</p> <pre><code>tests:\n  - script:\n      - ls\n    files:\n      source:\n        - myfile.txt\n        - tests/\n        - some/directory/pattern*.sh\n      recipe:\n        - extra-file.txt\n</code></pre>"},{"location":"reference/recipe_file/#test-requirements","title":"Test requirements","text":"<p>In addition to the runtime requirements, you can specify requirements needed during testing. The runtime requirements that you specified in the \"<code>run</code>\" section described above are automatically included during testing (because the built package is installed as it regularly would be).</p> <p>In the <code>build</code> section you can specify additional requirements that are only needed on the build system for cross-compilation (e.g. emulators or compilers).</p> <pre><code>tests:\n  - script:\n      - echo \"hello world\"\n    requirements:\n      build:\n        - myemulator\n      run:\n        - nose\n</code></pre>"},{"location":"reference/recipe_file/#python-tests","title":"Python tests","text":"<p>For this test type you can list a set of Python modules that need to be importable. The test will fail if any of the modules cannot be imported.</p> <p>The test will also automatically run <code>pip check</code> to check for any broken dependencies. This can be disabled by setting <code>pip_check: false</code> in the YAML.</p> <pre><code>tests:\n  - python:\n      imports:\n        - bsdiff4\n        - bspatch4\n      pip_check: true  # can be left out because this is the default\n      python_version: 3.12.*  # optional: use list for multiple versions, default resolves to environment\n</code></pre> <p>Internally this will write a small Python script that imports the modules:</p> <pre><code>import bsdiff4\nimport bspatch4\n</code></pre>"},{"location":"reference/recipe_file/#perl-tests","title":"Perl tests","text":"<p>For this test type you can list a set of Perl modules that need to be importable. The test will fail if any of the modules cannot be imported.</p> <pre><code>tests:\n  - perl:\n      uses:\n        - Call::Context\n</code></pre> <p>Internally this will write a small Perl script that imports the modules:</p> <pre><code>use Call::Context;\n</code></pre>"},{"location":"reference/recipe_file/#r-tests","title":"R tests","text":"<p>For this test type you can list a set of R modules that need to be importable. The test will fail if any of the modules cannot be imported.</p> <pre><code>- r:\n    libraries:\n      - knitr\n</code></pre> <p>Internally this will write a small R script that imports the modules:</p> <pre><code>library(knitr)\n</code></pre>"},{"location":"reference/recipe_file/#check-for-package-contents","title":"Check for package contents","text":"<p>Checks if the built package contains the mentioned items. These checks are executed directly at the end of the build process to make sure that all expected files are present in the package.</p> <pre><code>tests:\n  - package_contents:\n      # checks for the existence of files inside $PREFIX or %PREFIX%\n      # or, checks that there is at least one file matching the specified `glob`\n      # pattern inside the prefix\n      files:\n        - etc/libmamba/test.txt\n        - etc/libmamba\n        - etc/libmamba/*.mamba.txt\n\n      # For more advanced cases, you can use the expanded form with exists and not_exists:\n      # files:\n      #   exists:\n      #     - etc/libmamba/test.txt\n      #     - etc/libmamba\n      #     - etc/libmamba/*.mamba.txt\n      #   not_exists:\n      #     - etc/libmamba/unwanted.txt\n\n      # checks for the existence of `mamba/api/__init__.py` inside of the\n      # Python site-packages directory (note: also see Python import checks)\n      site_packages:\n        - mamba.api\n\n\n      # looks in $PREFIX/bin/mamba for unix and %PREFIX%\\Library\\bin\\mamba.exe on Windows\n      # note: also check the `commands` and execute something like `mamba --help` to make\n      # sure things work fine\n      bin:\n        - mamba\n\n      # enable strict mode: error if any file in the package is not matched by one of the globs\n      # (default: false)\n      strict: true\n\n      # searches for `$PREFIX/lib/libmamba.so` or `$PREFIX/lib/libmamba.dylib` on Linux or macOS,\n      # on Windows for %PREFIX%\\Library\\lib\\mamba.dll &amp; %PREFIX%\\Library\\bin\\mamba.bin\n      lib:\n        - mamba\n\n      # searches for `$PREFIX/include/libmamba/mamba.hpp` on unix, and\n      # on Windows for `%PREFIX%\\Library\\include\\libmamba\\mamba.hpp`\n      include:\n        - libmamba/mamba.hpp\n</code></pre>"},{"location":"reference/recipe_file/#downstream-tests","title":"Downstream tests","text":"<p>A downstream test can mention a single package that has a dependency on the package being built. The test will install the package and run the tests of the downstream package with our current package as a dependency.</p> <p>Sometimes downstream packages do not resolve. In this case, the test is ignored.</p> <pre><code>tests:\n  - downstream: numpy\n</code></pre>"},{"location":"reference/recipe_file/#outputs-section","title":"Outputs section","text":"<p>Tip</p> <p>For a complete guide including staging outputs and examples, see Multi-Output Recipes.</p> <p>Explicitly specifies packaging steps. This section supports multiple outputs, as well as different package output types. The format is a list of mappings.</p> <p>When using multiple outputs, certain top-level keys are \"forbidden\": <code>package</code> and <code>requirements</code>. Instead of <code>package</code>, a top-level <code>recipe</code> key can be defined. The <code>recipe.name</code> is ignored but the <code>recipe.version</code> key is used as default version for each output. Other \"top-level\" keys are merged into each output (e.g. the <code>about</code> section) to avoid repetition. Each output is a complete recipe, and can have its own <code>build</code>, <code>requirements</code>, and <code>test</code> sections.</p> <pre><code>recipe:\n  # the recipe name is ignored\n  name: some\n  version: 1.0\n\noutputs:\n  - package:\n      # version is taken from recipe.version (1.0)\n      name: some-subpackage\n\n  - package:\n      name: some-other-subpackage\n      version: 2.0\n</code></pre> <p>Each output acts like an independent recipe and can have their own <code>script</code>, <code>build_number</code>, and so on.</p> <pre><code>outputs:\n  - package:\n      name: subpackage-name\n    build:\n      script: install-subpackage\n</code></pre> <p>If <code>script</code> lacks a file extension, the appropriate extension for the platform will be appended, e.g. the above will run <code>install-subpackage.sh</code> in <code>bash</code> on most platforms and <code>install-subpackage.bat</code> in <code>cmd.exe</code> on Windows.</p> <p>Each output is built independently. You should take care of not packaging the same files twice.</p>"},{"location":"reference/recipe_file/#subpackage-requirements","title":"Subpackage requirements","text":"<p>Like a top-level recipe, a subpackage may have zero or more dependencies listed as build, host or run requirements.</p> <p>The dependencies listed as subpackage build requirements are available only during the packaging phase of that subpackage.</p> <pre><code>outputs:\n  - package:\n      name: subpackage-name\n    requirements:\n      build:\n        - some-dep\n      run:\n        - some-dep\n</code></pre> <p>You can also use the <code>pin_subpackage</code> function to pin another output from the same recipe.</p> <pre><code>outputs:\n  - package:\n      name: libtest\n  - package:\n      name: test\n    requirements:\n      build:\n        - ${{ pin_subpackage('libtest', upper_bound='x.x') }}\n</code></pre> <p>The outputs are topologically sorted by the dependency graph which is taking the <code>pin_subpackage</code> invocations into account. When using <code>pin_subpackage(name, exact=True)</code> a special behavior is used where the <code>name</code> package is injected as a \"variant\" and the variant matrix is expanded appropriately. For example, when you have the following situation, with a <code>variant_config.yaml</code> file that contains <code>openssl: [1, 3]</code>:</p> <pre><code>outputs:\n  - package:\n      name: libtest\n    requirements:\n      host:\n        - openssl\n  - package:\n      name: test\n    requirements:\n      build:\n        - ${{ pin_subpackage('libtest', exact=True) }}\n</code></pre> <p>Due to the variant config file, this will build two versions of <code>libtest</code>. We will also build two versions of <code>test</code>, one that depends on <code>libtest (openssl 1)</code> and one that depends on <code>libtest (openssl 3)</code>.</p>"},{"location":"reference/recipe_file/#staging-outputs","title":"Staging outputs","text":"<p>Note</p> <p>Staging outputs are an experimental feature. You need to pass the <code>--experimental</code> flag or set <code>RATTLER_BUILD_EXPERIMENTAL=true</code> to use them. See the staging outputs guide for a full walkthrough.</p> <p>A staging output builds code once and caches the results. Other package outputs can inherit from a staging cache to receive the built files directly in their <code>$PREFIX</code> without rebuilding. Staging outputs do not produce package artifacts themselves.</p> <pre><code>outputs:\n  - staging:\n      name: my-staging-cache   # required, follows package name rules\n    source:                     # optional, additional sources\n      - url: https://example.com/src.tar.gz\n        sha256: abc123...\n    requirements:\n      build:                    # build-time dependencies\n        - ${{ compiler('c') }}\n        - cmake\n      host:                     # host dependencies\n        - zlib\n      ignore_run_exports:       # optional, filter run exports at the staging level\n        from_package:\n          - zlib\n    build:\n      script:                   # build script (only field allowed under build)\n        - cmake -B build\n        - cmake --build build --target install\n</code></pre> <p>The <code>staging:</code> output supports:</p> <ul> <li><code>staging.name</code> \u2014 required, the cache name that inheriting packages reference</li> <li><code>source</code> \u2014 optional source sections (in addition to top-level sources)</li> <li><code>requirements</code> \u2014 <code>build</code>, <code>host</code>, and <code>ignore_run_exports</code> (no <code>run</code> requirements)</li> <li><code>build.script</code> \u2014 the build script to execute</li> </ul>"},{"location":"reference/recipe_file/#inheriting-from-staging","title":"Inheriting from staging","text":"<p>Package outputs use the <code>inherit:</code> key to receive files from a staging cache. Two forms are supported:</p> <pre><code>outputs:\n  - staging:\n      name: my-build\n    build:\n      script:\n        - make install\n\n  # Short form \u2014 inherits all files and run exports\n  - package:\n      name: mylib\n    inherit: my-build\n    build:\n      files:\n        - lib/**\n\n  # Extended form \u2014 control run exports inheritance\n  - package:\n      name: mylib-dev\n    inherit:\n      from: my-build\n      run_exports: false   # do not inherit run exports from staging deps\n    build:\n      files:\n        - include/**\n</code></pre> <p>When a package inherits from staging:</p> <ol> <li>The staging cache's prefix files are copied into the package's <code>$PREFIX</code></li> <li>The staging cache's work directory is restored (allowing incremental builds)</li> <li>Run exports from staging dependencies are added to the package's run    requirements (unless <code>run_exports: false</code> is set)</li> <li>The <code>files</code> globs select which subset of the inherited files end up in the    final package</li> </ol>"},{"location":"reference/recipe_file/#top-level-inheritance","title":"Top-level inheritance","text":"<p>In recipes that have both a top-level <code>build:</code> section and staging outputs, package outputs can choose to inherit from the top-level build instead of from staging by setting <code>inherit: null</code>:</p> <pre><code>build:\n  script:\n    - echo \"top-level\" &gt; $PREFIX/share/data.txt\n\noutputs:\n  - staging:\n      name: compile-stage\n    build:\n      script:\n        - echo \"compiled\" &gt; $PREFIX/lib/compiled.so\n\n  - package:\n      name: compiled-pkg\n    inherit: compile-stage       # gets files from staging\n    build:\n      files:\n        - lib/**\n\n  - package:\n      name: data-pkg\n    inherit: null                # gets files from top-level build\n    build:\n      files:\n        - share/**\n</code></pre>"},{"location":"reference/recipe_file/#about-section","title":"About section","text":"<p>Specifies identifying information about the package. The information displays in the package server.</p> <pre><code>about:\n  homepage: https://example.com/bsdiff4\n  license: BSD-3-Clause # (1)!\n  license_file: LICENSE\n  summary: binary diff and patch using the BSDIFF4-format\n  description: |\n    Long description of bsdiff4 ...\n  repository: https://github.com/ilanschnell/bsdiff4\n  documentation: https://docs.com\n</code></pre> <ol> <li>Only the SPDX specifiers are allowed, more info here: SPDX     If you want another license type <code>LicenseRef-&lt;YOUR-LICENSE&gt;</code> can be used, e.g. <code>license: LicenseRef-Proprietary</code></li> </ol>"},{"location":"reference/recipe_file/#license-file","title":"License file","text":"<p>Adds a file containing the software license to the package metadata. Many licenses require the license statement to be distributed with the package. The filename is relative to the source or recipe directory. The value can be a single filename or a YAML list for multiple license files. Values can also point to directories with license information. Directory entries must end with a <code>/</code> suffix (this is to lessen unintentional inclusion of non-license files; all the directory's contents will be unconditionally and recursively added).</p> <p>If a license file is found in both the source and recipe directories, the file from the recipe directory is used (you should see a warning about this in the build log).</p> <pre><code>about:\n  license_file:\n    - LICENSE\n    - vendor-licenses/\n</code></pre>"},{"location":"reference/recipe_file/#extra-section","title":"Extra section","text":"<p>A schema-free area for storing non-<code>conda</code>-specific metadata in standard YAML form.</p> Example: To store recipe maintainers information <pre><code>extra:\n  maintainers:\n   - name of maintainer\n</code></pre>"},{"location":"reference/recipe_file/#templating-with-jinja","title":"Templating with Jinja","text":"<p><code>rattler-build</code> supports limited Jinja templating in the <code>recipe.yaml</code> file.</p> <p>You can set up Jinja variables in the <code>context</code> section:</p> <pre><code>context:\n  name: \"test\"\n  version: \"5.1.2\"\n  # later keys can reference previous keys\n  # and use jinja functions to compute new values\n  major_version: ${{ (version | split('.'))[0] }}\n  tests_to_skip:\n    # fails for one reason\n    - test_foo\n    # fails for another reason\n    - test_bar\n</code></pre> <p>Later in your <code>recipe.yaml</code> you can use these values in string interpolation with Jinja:</p> <pre><code>source:\n  url: https://github.com/mamba-org/${{ name }}/v${{ version }}.tar.gz\n\ntests:\n  - script:\n    - pytest -k \"not (${{ tests_to_skip | join(\" or \")\" }})\"\n</code></pre> <p>Jinja has built-in support for some common string manipulations.</p> <p>In rattler-build, complex Jinja is completely disallowed as we try to produce YAML that is valid at all times. So you should not use any <code>{% if ... %}</code> or similar Jinja constructs that produce invalid YAML. Furthermore, instead of plain double curly brackets Jinja statements need to be prefixed by <code>$</code>, e.g. <code>${{ ... }}</code>:</p> <pre><code>package:\n  name: {{ name }}   # WRONG: invalid yaml\n  name: ${{ name }} # correct\n</code></pre> <p>For more information, see the Jinja template documentation and the list of available environment variables <code>env-vars</code>.</p> <p>Jinja templates are evaluated during the build process.</p>"},{"location":"reference/recipe_file/#additional-jinja2-functionality-in-rattler-build","title":"Additional Jinja2 functionality in rattler-build","text":"<p>Besides the default Jinja2 functionality, additional Jinja functions are available during the <code>rattler-build</code> process: <code>pin_compatible</code>, <code>pin_subpackage</code>, and <code>compiler</code>.</p> <p>The compiler function takes <code>c</code>, <code>cxx</code>, <code>fortran</code> and other values as argument and automatically selects the right (cross-)compiler for the target platform.</p> <pre><code>build:\n  - ${{ compiler('c') }}\n</code></pre> <p>The <code>pin_subpackage</code> function pins another package produced by the recipe with the supplied parameters.</p> <p>Similarly, the <code>pin_compatible</code> function will pin a package according to the specified rules.</p>"},{"location":"reference/recipe_file/#pin-expressions","title":"Pin expressions","text":"<p><code>rattler-build</code> knows pin expressions. A pin expression can have a <code>lower_bound</code>, <code>upper_bound</code> and <code>exact</code> value. A <code>upper_bound</code> and <code>lower_bound</code> are specified with a string containing only <code>x</code> and <code>.</code>, e.g. <code>upper_bound=\"x.x.x\"</code> would signify to pin the given package to <code>&lt;1.2.3</code> (if the package version is <code>1.2.2</code>, for example).</p> <p>A pin with <code>lower_bound=\"x.x\",upper_bound=\"x.x\"</code> for a package of version <code>1.2.2</code> would evaluate to <code>&gt;=1.2,&lt;1.3.0a0</code>.</p> <p>If <code>exact=true</code>, then the <code>hash</code> is included, and the package is pinned exactly, e.g. <code>==1.2.2 h1234</code>. This is a unique package variant that cannot exist more than once, and thus is \"exactly\" pinned.</p> <p>You can also hard-code version strings into <code>lower_bound</code> and <code>upper_bound</code>. See the Jinja Reference for more information.</p>"},{"location":"reference/recipe_file/#pin-subpackage","title":"Pin subpackage","text":"<p>Pin subpackage refers to another package from the same recipe file. It is commonly used in the <code>requirements/run_exports</code> section to export a run export from the package, or with multiple outputs to refer to a previous build.</p> <p>It looks something like:</p> <pre><code>package:\n  name: mypkg\n  version: \"1.2.3\"\n\nrequirements:\n  run_exports:\n    # this will evaluate to `mypkg &lt;1.3`\n    - ${{ pin_subpackage(name, upper_bound='x.x') }}\n</code></pre>"},{"location":"reference/recipe_file/#pin-compatible","title":"Pin compatible","text":"<p>Pin compatible lets you pin a package based on the version retrieved from the variant file (if the pinning from the variant file needs customization).</p> <p>For example, if the variant specifies a pin for <code>numpy: 1.11</code>, one can use <code>pin_compatible</code> to relax it:</p> <pre><code>requirements:\n  host:\n    # this will select numpy 1.11\n    - numpy\n  run:\n    # this will export `numpy &gt;=1.11,&lt;2`, instead of the stricter `1.11` pin\n    - ${{ pin_compatible('numpy', min_pin='x.x', upper_bound='x') }}\n</code></pre>"},{"location":"reference/recipe_file/#the-env-jinja-functions","title":"The env Jinja functions","text":"<p>You can access the environment variables set outside the build script using the <code>env</code> object in Jinja.</p> <p>There are three functions:</p> <ul> <li><code>env.get(\"ENV_VAR\")</code> will insert the value of \"ENV_VAR\" into the recipe.</li> <li><code>env.get(\"ENV_VAR\", default=\"undefined\")</code> will insert the value of <code>ENV_VAR</code>   into the recipe or, if <code>ENV_VAR</code> is not defined, the specified default value   (in this case \"undefined\")</li> <li><code>env.exists(\"ENV_VAR\")</code> returns a boolean true of false if the env var is set   to any value</li> </ul> <p>This can be used for some light templating, for example:</p> <pre><code>build:\n  string: ${{ env.get(\"GIT_BUILD_STRING\") }}_${{ hash }}\n</code></pre>"},{"location":"reference/recipe_file/#match-function","title":"<code>match</code> function","text":"<p>This function matches the first argument (the package version) against the second argument (the version spec) and returns the resulting boolean. This only works for packages defined in the \"variant_config.yaml\" file.</p> recipe.yaml<pre><code>match(python, '&gt;=3.4')\n</code></pre> <p>For example, you could require a certain dependency only for builds against python 3.4 and above:</p> recipe.yaml<pre><code>requirements:\n  build:\n    - if: match(python, '&gt;=3.4')\n      then:\n        - some-dep\n</code></pre> <p>With a corresponding variant config that looks like the following:</p> variant_config.yaml<pre><code>python: [\"3.2\", \"3.4\", \"3.6\"]\n</code></pre> <p>Example: <code>match</code> usage example</p>"},{"location":"reference/recipe_file/#cdt-function","title":"<code>cdt</code> function","text":"<p>This function helps add Core Dependency Tree packages as dependencies by converting packages as required according to hard-coded logic.</p> <pre><code># on x86_64 system\ncdt('package-name') # outputs: package-name-cos6-x86_64\n# on aarch64 system\ncdt('package-name') # outputs: package-name-cos6-aarch64\n</code></pre> <p>Example: <code>cdt</code> usage example</p>"},{"location":"reference/recipe_file/#preprocessing-selectors","title":"Preprocessing selectors","text":"<p>You can add selectors to any item, and the selector is evaluated in a preprocessing stage. If a selector evaluates to <code>true</code>, the item is flattened into the parent element. If a selector evaluates to <code>false</code>, the item is removed.</p> <p>Selectors can use <code>if ... then ... else</code> as follows:</p> <pre><code>source:\n  - if: not win\n    then:\n      - url: http://path/to/unix/source\n    else:\n      - url: http://path/to/windows/source\n\n# or the equivalent with two if conditions:\n\nsource:\n  - if: unix\n    then:\n      - url: http://path/to/unix/source\n  - if: win\n    then:\n      - url: http://path/to/windows/source\n</code></pre> <p>A selector is a valid Python statement that is executed. You can read more about them in the \"Selectors in recipes\" chapter.</p> <p>The use of the Python version selectors, <code>py27</code>, <code>py34</code>, etc. is discouraged in favor of the more general comparison operators. Additional selectors in this series will not be added to <code>conda-build</code>.</p> <p>Because the selector is any valid Python expression, complicated logic is possible:</p> <pre><code>- if: unix and not win\n  then: ...\n- if: (win or linux) and not py27\n  then: ...\n</code></pre> <p>Lists are automatically \"merged\" upwards, so it is possible to group multiple items under a single selector:</p> <pre><code>tests:\n  - script:\n    - if: unix\n      then:\n      - test -d ${PREFIX}/include/xtensor\n      - test -f ${PREFIX}/lib/cmake/xtensor/xtensorConfigVersion.cmake\n    - if: win\n      then:\n      - if not exist %LIBRARY_PREFIX%\\include\\xtensor\\xarray.hpp (exit 1)\n      - if not exist %LIBRARY_PREFIX%\\lib\\cmake\\xtensor\\xtensorConfigVersion.cmake (exit 1)\n\n# On unix this is rendered to:\ntests:\n  - script:\n    - test -d ${PREFIX}/include/xtensor\n    - test -f ${PREFIX}/lib/cmake/xtensor/xtensorConfigVersion.cmake\n</code></pre>"},{"location":"reference/recipe_file/#experimental-features","title":"Experimental features","text":"<p>Warning</p> <p>These are experimental features of <code>rattler-build</code> and may change or go away completely.</p>"},{"location":"reference/recipe_file/#jinja-functions","title":"Jinja functions","text":"<ul> <li><code>load_from_file</code></li> <li><code>git.*</code> functions</li> </ul>"},{"location":"tutorials/","title":"Examples","text":"<p>This section contains examples for packaging software in different languages with <code>rattler-build</code>. Each example walks you through creating a recipe for a specific language ecosystem.</p> Example Description Python Build pure Python packages with <code>noarch: python</code> and compiled packages like NumPy C++ Package header-only and compiled C++ libraries using CMake JavaScript Create packages for NodeJS applications using NPM Rust Build Rust packages with proper license bundling using <code>cargo-bundle-licenses</code> Go Package Go applications with <code>go-cgo</code> or <code>go-nocgo</code> compilers Perl Build Perl packages from CPAN with <code>noarch: generic</code> support R Package R libraries from CRAN Repackaging Repackage existing pre-built binaries for distribution Converting from conda-build Migrate existing <code>meta.yaml</code> recipes to the <code>rattler-build</code> format"},{"location":"tutorials/cpp/","title":"Packaging a C++ package","text":"<p>This tutorial will guide you though making a C++ package with <code>rattler-build</code>.</p>"},{"location":"tutorials/cpp/#building-a-header-only-library","title":"Building a Header-only Library","text":"<p>To build a package for the header-only library <code>xtensor</code>, you need to manage dependencies and ensure proper installation paths.</p>"},{"location":"tutorials/cpp/#key-steps","title":"Key Steps","text":"<ol> <li> <p>Dependencies:    Ensure <code>cmake</code>, <code>ninja</code>, and a <code>compiler</code> are available as dependencies.</p> </li> <li> <p>CMake Installation Prefix:    Use the <code>CMAKE_INSTALL_PREFIX</code> setting to instruct <code>CMake</code> to install the headers in the correct location.</p> </li> <li> <p>Unix Systems:        Follow the standard Unix prefix:        <pre><code>$PREFIX/include\n$PREFIX/lib\n</code></pre></p> </li> <li> <p>Windows Systems:      Use a Unix-like prefix but nested in a <code>Library</code> directory:      <pre><code>$PREFIX/Library/include\n$PREFIX/Library/lib\n</code></pre>      Utilize the handy variables <code>%LIBRARY_PREFIX%</code> and <code>%LIBRARY_BIN%</code> to guide <code>CMake</code> to install the headers and libraries correctly.</p> </li> </ol> <p>This approach ensures that the headers and libraries are installed in the correct directories on both Unix and Windows systems.</p>"},{"location":"tutorials/cpp/#recipe","title":"Recipe","text":"recipe.yaml<pre><code>context:\n  version: \"0.24.6\"\n\npackage:\n  name: xtensor\n  version: ${{ version }}\n\nsource:\n  url: https://github.com/xtensor-stack/xtensor/archive/${{ version }}.tar.gz\n  sha256: f87259b51aabafdd1183947747edfff4cff75d55375334f2e81cee6dc68ef655\n\nbuild:\n  number: 0\n  script:\n    - if: win # (1)!\n      then: |\n        cmake -GNinja ^\n            -D BUILD_TESTS=OFF -DCMAKE_INSTALL_PREFIX=%LIBRARY_PREFIX% ^\n            %SRC_DIR%\n        ninja install\n      else: |\n        cmake -GNinja \\\n              -DBUILD_TESTS=OFF -DCMAKE_INSTALL_PREFIX=$PREFIX \\\n              $SRC_DIR\n        ninja install\n\nrequirements:\n  build:\n    - ${{ compiler('cxx') }} # (2)!\n    - cmake\n    - ninja\n  host:\n    - xtl &gt;=0.7,&lt;0.8\n  run:\n    - xtl &gt;=0.7,&lt;0.8\n  run_constraints: # (3)!\n    - xsimd &gt;=8.0.3,&lt;10\n\ntests:\n  - package_contents:\n      include: # (4)!\n        - xtensor/xarray.hpp\n      files: # (5)!\n        exists:\n          - ${{ \"Library/\" if win }}share/cmake/xtensor/xtensorConfig.cmake\n          - ${{ \"Library/\" if win }}share/cmake/xtensor/xtensorConfigVersion.cmake\n\nabout:\n  homepage: https://github.com/xtensor-stack/xtensor\n  license: BSD-3-Clause\n  license_file: LICENSE\n  summary: The C++ tensor algebra library\n  description: Multi dimensional arrays with broadcasting and lazy computing\n  documentation: https://xtensor.readthedocs.io\n  repository: https://github.com/xtensor-stack/xtensor\n\nextra:\n  recipe-maintainers:\n    - some-maintainer\n</code></pre> <ol> <li>The <code>if:</code> condition allows the user to switch behavior of the build based on some checks like, the operating system.</li> <li>The <code>compiler</code> function is used to get the C++ compiler for the build system.</li> <li>The <code>run_constraints</code> section specifies the version range of a package which the package can run \"with\". But which the package doesn't depend on itself.</li> <li>The <code>include</code> section specifies the header file to tested for existence.</li> <li>The <code>files</code> section specifies the files to be tested for existence, using a glob pattern.</li> </ol> <p><code>CMAKE_ARGS</code></p> <p>It can be tedious to remember all the different variables one needs to pass to CMake to create the perfect build. The <code>cmake</code> package on conda-forge introduces the<code>CMAKE_ARGS</code> environment variable. This variable contains the necessary flags to make the package build correctly, also when cross-compiling from one machine to another. Therefore, it is often not necessary to pass any additional flags to the <code>cmake</code> command. However, because this is a tutorial we will show how to pass the necessary flags to <code>cmake</code> manually.</p> <p>For more information please refer to the conda-forge documentation.</p>"},{"location":"tutorials/cpp/#building-a-c-application","title":"Building A C++ application","text":"<p>In this example, we'll build <code>poppler</code>, a C++ application for manipulating PDF files from the command line. The final package will install several tools into the <code>bin/</code> folder. We'll use external build scripts and run actual scripts in the test.</p>"},{"location":"tutorials/cpp/#key-steps_1","title":"Key Steps","text":"<ol> <li> <p>Dependencies:</p> <ul> <li>Build Dependencies: These are necessary for the building process, including <code>cmake</code>, <code>ninja</code>, and <code>pkg-config</code>.</li> <li>Host Dependencies: These are the libraries <code>poppler</code> links against, such as <code>cairo</code>, <code>fontconfig</code>, <code>freetype</code>, <code>glib</code>, and others.</li> </ul> </li> <li> <p>Compiler Setup:    We use the <code>compiler</code> function to obtain the appropriate C and C++ compilers.</p> </li> <li> <p>Build Script:    The <code>build.script</code> field points to an external script (<code>poppler-build.sh</code>) which contains the build commands.</p> </li> <li> <p>Testing:    Simple tests are included to verify that the installed tools (<code>pdfinfo</code>, <code>pdfunite</code>, <code>pdftocairo</code>) are working correctly by running them, and expecting an exit code <code>0</code>.</p> </li> </ol>"},{"location":"tutorials/cpp/#recipe_1","title":"Recipe","text":"recipe.yaml<pre><code>context:\n  version: \"24.01.0\"\n\npackage:\n  name: poppler\n  version: ${{ version }}\n\nsource:\n  url: https://poppler.freedesktop.org/poppler-${{ version }}.tar.xz\n  sha256: c7def693a7a492830f49d497a80cc6b9c85cb57b15e9be2d2d615153b79cae08\n\nbuild:\n  script: poppler-build.sh\n\nrequirements:\n  build:\n    - ${{ compiler('c') }} # (1)!\n    - ${{ compiler('cxx') }}\n    - pkg-config\n    - cmake\n    - ninja\n  host:\n    - cairo # (2)!\n    - fontconfig\n    - freetype\n    - glib\n    - libboost-headers\n    - libjpeg-turbo\n    - lcms2\n    - libiconv\n    - libpng\n    - libtiff\n    - openjpeg\n    - zlib\n\ntests:\n  - script:\n      - pdfinfo -listenc # (3)!\n      - pdfunite --help\n      - pdftocairo --help\n</code></pre> <ol> <li>The <code>compiler</code> jinja function to get the correct compiler for C and C++ on the build system.</li> <li>These are all the dependencies that the library links against.</li> <li>The script test just executes some of the installed tools to check if they    are working. These can be as complex as you want. (<code>bash</code> or <code>cmd.exe</code>)</li> </ol>"},{"location":"tutorials/cpp/#external-build-script","title":"External Build Script","text":"<p>We've defined an external build script in the recipe. This will be searched next to the recipe by the file name given, or the default name <code>build.sh</code> on <code>unix</code> or <code>build.bat</code> on windows are searched for.</p> poppler-build.sh<pre><code>#! /bin/bash\n\nextra_cmake_args=(\n    -GNinja\n    -DCMAKE_INSTALL_LIBDIR=lib\n    -DENABLE_UNSTABLE_API_ABI_HEADERS=ON\n    -DENABLE_GPGME=OFF\n    -DENABLE_LIBCURL=OFF\n    -DENABLE_LIBOPENJPEG=openjpeg2\n    -DENABLE_QT6=OFF\n    -DENABLE_QT5=OFF\n    -DENABLE_NSS3=OFF\n)\n\nmkdir build &amp;&amp; cd build\n\ncmake ${CMAKE_ARGS} \"${extra_cmake_args[@]}\" \\\n    -DCMAKE_PREFIX_PATH=$PREFIX \\\n    -DCMAKE_INSTALL_PREFIX=$PREFIX \\\n    -DTIFF_INCLUDE_DIR=$PREFIX/include \\\n    $SRC_DIR\n\nninja\n\n# The `install` command will take care of copying the files to the right place\nninja install\n</code></pre>"},{"location":"tutorials/cpp/#parsing-the-rattler-build-build-output","title":"Parsing the <code>rattler-build build</code> Output","text":"<p>When running the <code>rattler-build</code> command, you might notice some interesting information in the output. Our package will have some <code>run</code> dependencies, even if we didn't specify any.</p> <p>These come from the <code>run-exports</code> of the packages listed in the <code>host</code> section of the recipe. This is indicated by <code>\"RE of [host: package]\"</code> in the output.</p> <p>For example, <code>libcurl</code> specifies that if you depend on it in the host section, you should also depend on it during runtime with specific version ranges. This ensures proper linking to shared libraries.</p> <pre><code>Run dependencies:\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Name                  \u2506 Spec                                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 libcurl               \u2506 &gt;=8.5.0,&lt;9.0a0 (RE of [host: libcurl])       \u2502\n\u2502 fontconfig            \u2506 &gt;=2.14.2,&lt;3.0a0 (RE of [host: fontconfig])   \u2502\n\u2502 fonts-conda-ecosystem \u2506 (RE of [host: fontconfig])                   \u2502\n\u2502 lcms2                 \u2506 &gt;=2.16,&lt;3.0a0 (RE of [host: lcms2])          \u2502\n\u2502 gettext               \u2506 &gt;=0.21.1,&lt;1.0a0 (RE of [host: gettext])      \u2502\n\u2502 freetype              \u2506 &gt;=2.12.1,&lt;3.0a0 (RE of [host: freetype])     \u2502\n\u2502 openjpeg              \u2506 &gt;=2.5.0,&lt;3.0a0 (RE of [host: openjpeg])      \u2502\n\u2502 libiconv              \u2506 &gt;=1.17,&lt;2.0a0 (RE of [host: libiconv])       \u2502\n\u2502 cairo                 \u2506 &gt;=1.18.0,&lt;2.0a0 (RE of [host: cairo])        \u2502\n\u2502 libpng                \u2506 &gt;=1.6.42,&lt;1.7.0a0 (RE of [host: libpng])     \u2502\n\u2502 libzlib               \u2506 &gt;=1.2.13,&lt;1.3.0a0 (RE of [host: zlib])       \u2502\n\u2502 libtiff               \u2506 &gt;=4.6.0,&lt;4.7.0a0 (RE of [host: libtiff])     \u2502\n\u2502 libjpeg-turbo         \u2506 &gt;=3.0.0,&lt;4.0a0 (RE of [host: libjpeg-turbo]) \u2502\n\u2502 libglib               \u2506 &gt;=2.78.3,&lt;3.0a0 (RE of [host: glib])         \u2502\n\u2502 libcxx                \u2506 &gt;=16 (RE of [build: clangxx_osx-arm64])      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>You can also see \"linking\" information in the output, for example on macOS:</p> <pre><code>[lib/libpoppler-glib.8.26.0.dylib] links against:\n \u251c\u2500 @rpath/libgio-2.0.0.dylib\n \u251c\u2500 @rpath/libgobject-2.0.0.dylib\n \u251c\u2500 /usr/lib/libSystem.B.dylib\n \u251c\u2500 @rpath/libglib-2.0.0.dylib\n \u251c\u2500 @rpath/libpoppler.133.dylib\n \u251c\u2500 @rpath/libfreetype.6.dylib\n \u251c\u2500 @rpath/libc++.1.dylib\n \u251c\u2500 @rpath/libpoppler-glib.8.dylib\n \u2514\u2500 @rpath/libcairo.2.dylib\n</code></pre> <p><code>rattler-build</code> ensures that:</p> <ol> <li>All shared libraries linked against are present in the run dependencies. Missing libraries trigger an <code>overlinking</code> warning.</li> <li>You don't require any packages in the host that you are not linking against. This triggers an <code>overdepending</code> warning.</li> </ol>"},{"location":"tutorials/go/","title":"Packaging a Go package","text":"<p>This tutorial will guide you through making a Go package with <code>rattler-build</code>.</p> <p>When building a recipe for Go, most Go dependencies are linked statically. That means, we should collect their licenses and add them in the package. The <code>go-licenses</code> tool can help you with this task - as shown in the example below.</p>"},{"location":"tutorials/go/#the-different-go-compilers","title":"The different Go compilers","text":"<p>The <code>conda-forge</code> ecosystem provides two go compilers: <code>go-cgo</code> and <code>go-nocgo</code>.</p> <p>By default, if you do not need to link against C libraries, it's recommended to use the <code>go-nocgo</code> compiler. It generates fat binaries without libc dependencies. The compiler activation scripts will set your <code>CC</code>, <code>CXX</code> and related flags to invalid values.</p> <p>The <code>go-cgo</code> compiler can generate fat binaries that depend on conda-forge's libc. You should use this compiler if the underlying program needs to link against other C libraries, in which case make sure to add <code>${{ compiler('c') }}</code> (<code>cxx</code>, <code>fortran</code>, ...) for unix and the <code>m2w64</code> equivalent for windows.</p>"},{"location":"tutorials/go/#example-go-recipe","title":"Example Go recipe","text":"<p>This example shows how to package the Temporal CLI.</p> recipe.yaml<pre><code>context:\n  version: \"0.13.1\"\n\npackage:\n  name: temporal\n  version: ${{ version }}\n\nsource:\n  url: https://github.com/temporalio/cli/archive/refs/tags/v${{ version }}.tar.gz\n  sha256: 9d8812c96d3404490659fec3915dcd23c4142b421ef4cb7e9622bd9a459e1f74\n\nbuild:\n  number: 0\n\nrequirements:\n  build:\n    - ${{ compiler('go-nocgo') }}\n    - go-licenses\n\ntests:\n  - script:\n      - temporal --version\n\nabout:\n  homepage: https://temporal.io\n  repository: https://github.com/temporalio/cli\n  documentation: https://docs.temporal.io/cli\n  summary: Temporal CLI\n  description: |\n    Command-line interface for running Temporal Server and interacting with\n    Workflows, Activities, Namespaces, and other parts of Temporal.\n  license: MIT\n  license_file:\n    - LICENSE\n    # These license files are generated at build time in the `build.sh` script\n    # from all the dependencies of `temporal.io`.\n    - license-files/\n</code></pre> <p>The build script (on Unix) should look something like this:</p> build.sh<pre><code># The LDFLAGS are used to set the version of the `temporal` binary. This is a common practice in Go.\nexport LDFLAGS=\"${LDFLAGS} -s -w -X github.com/temporalio/cli/temporalcli.Version=${PKG_VERSION}\"\n\n# Build the `temporal` binary and store it in the `$PREFIX/bin` directory.\ngo build -ldflags \"$LDFLAGS\" -o $PREFIX/bin/temporal ./cmd/temporal\n\n# Store the license files in a separate directory in the $SRC_DIR. These are embedded in the package\n# in the `license_file` section.\ngo-licenses save ./cmd/temporal --save_path=\"$SRC_DIR/license-files/\" || true\n</code></pre>"},{"location":"tutorials/javascript/","title":"Packaging a Javascript (NPM/NodeJS) package","text":"<p>This tutorial will guide you though making a NodeJS package with <code>rattler-build</code>. Please note that, while packaging executable applications is possible, the conda ecosystem is not ideal for NPM libraries. NPM supports a number of features that cannot easily be modeled in the conda ecosystem, such as peer dependencies, optional dependencies, and the ability to install multiple versions of the same package.</p> <p>However, if you need to package a NodeJS application, <code>rattler-build</code> can help!</p>"},{"location":"tutorials/javascript/#building-a-nodejs-package","title":"Building a NodeJS Package","text":"<p>In this example, we will build a package for the NodeJS package <code>bibtex-tidy</code>. We use <code>nodejs</code> in build and run requirements, and install the package using <code>npm</code>. NPM comes as part of the NodeJS installation, so we do not need to install it separately.</p> recipe.yaml<pre><code>context:\n  version: \"1.14.0\"\n\npackage:\n  name: bibtex-tidy\n  version: ${{ version }}\n\nsource:\n  url: https://registry.npmjs.org/bibtex-tidy/-/bibtex-tidy-${{ version }}.tgz\n  sha256: 0a2c1bb73911a7cee36a30ce1fc86feffe39b2d39acd4c94d02aac6f84a00285\n  # we do not extract the source code and install the tarball directly as that works better\n  file_name: bibtex-tidy-${{ version }}.tgz\n\nbuild:\n  number: 0\n  script:\n    # we use NPM to globally install the bibtex-tidy package\n    - npm install -g bibtex-tidy-${{ version }}.tgz --prefix ${{ PREFIX }}\n\nrequirements:\n  build:\n    - nodejs\n  run:\n    - nodejs\n\ntests:\n  - script:\n      - bibtex-tidy --version\n</code></pre>"},{"location":"tutorials/perl/","title":"Packaging a Perl (CPAM) package","text":"<p>Packaging a Perl package is similar to packaging a Python package!</p>"},{"location":"tutorials/perl/#building-a-perl-package","title":"Building a Perl Package","text":""},{"location":"tutorials/perl/#a-perl-noarch-generic-package","title":"A perl <code>noarch: generic</code> package","text":"<p>The following recipe is for the Perl package <code>Call::Context</code>. We use <code>perl</code> in the <code>host</code> requirements, and install the package using <code>make</code>. The <code>noarch: generic</code> is used to indicate that the package is architecture-independent - since this is a pure Perl package, it can be installed and run on any platform (<code>noarch</code>).</p> recipe.yaml<pre><code>context:\n  version: 0.03\n\npackage:\n  name: perl-call-context\n  version: ${{ version }}\n\nsource:\n  url: https://cpan.metacpan.org/authors/id/F/FE/FELIPE/Call-Context-${{ version }}.tar.gz\n  sha256: 0ee6bf46bc72755adb7a6b08e79d12e207de5f7809707b3c353b58cb2f0b5a26\n\nbuild:\n  number: 0\n  noarch: generic\n  script:\n    - perl Makefile.PL INSTALLDIRS=vendor NO_PERLLOCAL=1 NO_PACKLIST=1\n    - make\n    - make test\n    - make install\n\nrequirements:\n  build:\n    - make\n  host:\n    - perl\n\ntests:\n  - perl:\n      uses:\n        - Call::Context\n\nabout:\n  license: GPL-1.0-or-later OR Artistic-1.0-Perl\n  summary: Sanity-check calling context\n  homepage: http://metacpan.org/pod/Call-Context\n</code></pre>"},{"location":"tutorials/perl/#a-perl-package-with-a-c-extension","title":"A perl package with a C extension","text":"<p>Some <code>perl</code> packages have native code extensions. In this example, we will build a package for the Perl package <code>Data::Dumper</code> using the <code>C</code> compiler. The <code>c</code> compiler and <code>make</code> are required at build time in the <code>build</code> requirements to compile the native code extension. We use <code>perl</code> in the <code>host</code> requirements, and install the package using <code>make</code>.</p> recipe.yaml<pre><code>context:\n  version: \"2.183\"\n\npackage:\n  name: \"perl-data-dumper\"\n  version: ${{ version }}\n\nsource:\n  url: https://cpan.metacpan.org/authors/id/N/NW/NWCLARK/Data-Dumper-${{ version }}.tar.gz\n  sha256: e42736890b7dae1b37818d9c5efa1f1fdc52dec04f446a33a4819bf1d4ab5ad3\n\nbuild:\n  number: 0\n  script:\n    - perl Makefile.PL INSTALLDIRS=vendor NO_PERLLOCAL=1 NO_PACKLIST=1\n    - make\n    - make test\n    - make install VERBINST=1\n\nrequirements:\n  build:\n    - ${{ compiler('c') }}\n    - make\n  host:\n    - perl\n    - perl-extutils-makemaker\n\ntests:\n  - perl:\n      uses:\n        - Data::Dumper\n\nabout:\n  homepage: https://metacpan.org/pod/Data::Dumper\n  license: GPL-1.0-or-later OR Artistic-1.0-Perl\n  summary: \"seeds germane, yet not germinated\"\n</code></pre>"},{"location":"tutorials/python/","title":"Writing a Python package","text":"<p>Writing a Python package is fairly straightforward, especially for \"Python-only\" packages. In the second example we will build a package for <code>numpy</code> which contains compiled code.</p>"},{"location":"tutorials/python/#generating-a-starter-recipe","title":"Generating a starter recipe","text":"<p>Rattler-build provides a command to generate a recipe for a package from PyPI. The generated recipe can be used as a starting point for your recipe. The recipe generator will fetch the metadata from PyPI and generate a recipe that will build the package from the <code>sdist</code> source distribution.</p> <pre><code>rattler-build generate-recipe pypi ipywidgets\n# select an older version of the package\nrattler-build generate-recipe pypi ipywidgets --version 8.0.0\n</code></pre>"},{"location":"tutorials/python/#a-python-only-package","title":"A Python-only package","text":"<p>The following recipe uses the <code>noarch: python</code> setting to build a <code>noarch</code> package that can be installed on any platform without modification. This is very handy for packages that are pure Python and do not contain any compiled extensions.</p> <p>Additionally, <code>noarch: python</code> packages work with a range of Python versions (contrary to packages with compiled extensions that are tied to a specific Python version).</p> recipe.yaml<pre><code>context:\n  version: \"8.1.2\"\n\npackage:\n  name: ipywidgets\n  version: ${{ version }}\n\nsource:\n  url: https://pypi.io/packages/source/i/ipywidgets/ipywidgets-${{ version }}.tar.gz\n  sha256: d0b9b41e49bae926a866e613a39b0f0097745d2b9f1f3dd406641b4a57ec42c9\n\nbuild:\n  noarch: python # (1)!\n  script: pip install . -v\n\nrequirements:\n  # note that there is no build section\n  host:\n    - pip\n    - python &gt;=3.7\n    - setuptools\n    - wheel\n  run:\n    - comm &gt;=0.1.3\n    - ipython &gt;=6.1.0\n    - jupyterlab_widgets &gt;=3.0.10,&lt;3.1.0\n    - python &gt;=3.7\n    - traitlets &gt;=4.3.1\n    - widgetsnbextension &gt;=4.0.10,&lt;4.1.0\n\ntests:\n  - python:\n      imports:\n        - ipywidgets # (2)!\n\nabout:\n  homepage: https://github.com/ipython/ipywidgets\n  license: BSD-3-Clause\n  license_file: LICENSE\n  summary: Jupyter Interactive Widgets\n  description: |\n    ipywidgets are interactive HTML widgets for Jupyter notebooks and the IPython kernel.\n  documentation: https://ipywidgets.readthedocs.io/en/latest/\n</code></pre> <ol> <li>The <code>noarch: python</code> line tells <code>rattler-build</code> that this package is pure    Python and can be one-size-fits-all. <code>noarch</code> packages can be installed on any    platform without modification which is very handy.</li> <li>The <code>imports</code> section in the tests is used to check that the package is    installed correctly and can be imported.</li> </ol>"},{"location":"tutorials/python/#running-the-recipe","title":"Running the recipe","text":"<p>To build this recipe, simply run:</p> <pre><code>rattler-build build --recipe ./ipywidgets\n</code></pre>"},{"location":"tutorials/python/#a-python-package-with-compiled-extensions","title":"A Python package with compiled extensions","text":"<p>We will build a package for <code>numpy</code> \u2013 which contains compiled code. Since compiled code is <code>python</code> version-specific, we will need to specify the <code>python</code> version explicitly.</p> <p>The best way to do this is with a \"variants.yaml\" file. The variant config file allows us to easily compile the package against multiple Python versions.</p> variants.yaml<pre><code>python:\n  - 3.11\n  - 3.12\n</code></pre> <p>This will replace any <code>python</code> found in the recipe with the versions specified in the <code>variants.yaml</code> file.</p> recipe.yaml<pre><code>context:\n  version: 2.0.1\n  default_abi_level: 1.21\n\npackage:\n  name: numpy\n  version: ${{ version }}\n\nsource:\n  - url: https://github.com/numpy/numpy/releases/download/v${{ version }}/numpy-${{ version }}.tar.gz\n    sha256: 485b87235796410c3519a699cfe1faab097e509e90ebb05dcd098db2ae87e7b3\n\nbuild:\n  python:\n    entry_points:\n      - f2py = numpy.f2py.f2py2e:main # [win]\n      - numpy-config = numpy._configtool:main\n\nrequirements:\n  build:\n    - ${{ compiler('c') }}\n    - ${{ compiler('cxx') }}\n    # note: some `host` dependencies that run at build time (e.g., `cython`, `meson-python`)\n    #       should ideally be in `build` instead, this is because cross compilation of\n    #       Python packages in conda-forge uses `crossenv` rather than regular cross compilation.\n  host:\n    # note: variant is injected here!\n    - python\n    - pip\n    - meson-python\n    - pkg-config\n    - python-build\n    - cython\n    - libblas\n    - libcblas\n    - liblapack\n  run:\n    - python\n  run_exports:\n    - numpy &gt;=${{ default_abi_level }},&lt;3.0.0a0\n\ntests:\n  - python:\n      imports:\n        - numpy\n        - numpy.fft\n        - numpy.linalg\n        - numpy.random\n        - numpy.ctypeslib\n\n  - script:\n      - f2py -v\n      - numpy-config --cflags\n\nabout:\n  homepage: http://numpy.org/\n  license: BSD-3-Clause\n  license_file: LICENSE.txt\n  summary: The fundamental package for scientific computing with Python.\n  documentation: https://numpy.org/doc/stable/\n  repository: https://github.com/numpy/numpy\n</code></pre> <p>The build script for Unix:</p> build.sh<pre><code>mkdir builddir\n\n$PYTHON -m build -w -n -x \\\n    -Cbuilddir=builddir \\\n    -Csetup-args=-Dblas=blas \\\n    -Csetup-args=-Dlapack=lapack\n\n$PYTHON -m pip install dist/numpy*.whl\n</code></pre> <p>The build script for Windows:</p> build.bat<pre><code>mkdir builddir\n\n%PYTHON% -m build -w -n -x ^\n    -Cbuilddir=builddir ^\n    -Csetup-args=-Dblas=blas ^\n    -Csetup-args=-Dlapack=lapack\nif %ERRORLEVEL% neq 0 exit 1\n\n:: `pip install dist\\numpy*.whl` does not work on windows,\n:: so use a loop; there's only one wheel in dist/ anyway\nfor /f %%f in ('dir /b /S .\\dist') do (\n    pip install %%f\n    if %ERRORLEVEL% neq 0 exit 1\n)\n</code></pre>"},{"location":"tutorials/python/#running-the-recipe_1","title":"Running the recipe","text":"<p>Running this recipe with the variant config file will build a total of 2 <code>numpy</code> packages:</p> <pre><code>rattler-build build --recipe ./numpy\n</code></pre> <p>At the beginning of the build process, <code>rattler-build</code> will print the following message to show you the variants it found:</p> <pre><code>Found variants:\n\nnumpy-1.26.4-py311h5f8ada8_0\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Variant         \u2506 Version   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 python          \u2506 3.11      \u2502\n\u2502 target_platform \u2506 osx-arm64 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nnumpy-1.26.4-py312h440f24a_0\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Variant         \u2506 Version   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 python          \u2506 3.12      \u2502\n\u2502 target_platform \u2506 osx-arm64 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"tutorials/python/#an-abi3-compatible-package","title":"An ABI3-compatible package","text":"<p>Certain packages contain compiled code that is compatible with multiple Python versions. This is the case e.g. for a lot of Rust / PyO3 based Python extensions.</p> <p>In this case, you can use the special <code>abi3</code> settings to build a package that is specific to a certain operating system and architecture, but compatible with multiple Python versions.</p> <p>Note: this feature relies on the <code>python-abi3</code> package which exists in the <code>conda-forge</code> channel. The full recipe can be found on <code>conda-forge/py-rattler-feedstock</code></p> recipe.yaml<pre><code>context:\n  name: py-rattler\n  python_name: py_rattler\n  version: \"0.11.0\"\n  python_min: \"3.8\"\n\npackage:\n  name: py-rattler\n  version: ${{ version }}\n\nsource:\n  url: https://pypi.org/packages/source/${{ name[0] }}/${{ name }}/${{ python_name }}-${{ version }}.tar.gz\n  sha256: b00f91e19863741ce137a504eff3082c0b0effd84777444919bd83357530867f\n\nbuild:\n  number: 0\n  script: build.sh\n  python:\n    version_independent: true\n\nrequirements:\n  build:\n    - ${{ compiler('c') }}\n    - ${{ compiler('rust') }}\n    - cargo-bundle-licenses\n  host:\n    - python      ${{ python_min }}.*\n    - python-abi3 ${{ python_min }}.* # (1)!\n    - maturin &gt;=1.2.2,&lt;2\n    - pip\n    - if: unix\n      then:\n        - openssl\n  run:\n    - python &gt;=${{ python_min }}\n\ntests:\n  - python:\n      imports:\n        - rattler\n      python_version: ${{ python_min }}.* # (2)!\n  # You could run `abi3audit` here, but it is not necessary\n  # - script:\n  #     - abi3audit ${{ SP_DIR }}/spam.abi3.so -s -v --assume-minimum-abi3 ${{ python_min }}\n  #   requirements:\n  #     run:\n  #       - abi3audit\n\nabout:\n  homepage: https://github.com/conda/rattler\n  license: BSD-3-Clause\n  license_file:\n    - LICENSE\n    - py-rattler/THIRDPARTY.yml\n  summary: A blazing fast library to work with the conda ecosystem\n  description: |\n    Rattler is a library that provides common functionality used within the conda\n    ecosystem. The goal of the library is to enable programs and other libraries to\n    easily interact with the conda ecosystem without being dependent on Python. Its\n    primary use case is as a library that you can use to provide conda related\n    workflows in your own tools.\n  repository: https://github.com/conda/rattler\n</code></pre> <ol> <li>The <code>python-abi3</code> package is a special package that ensures that the   run dependencies    are compatible with the ABI3 standard.</li> <li>The <code>python_version</code> setting is used to test against the oldest compatible Python version.</li> </ol>"},{"location":"tutorials/python/#testing-python-packages","title":"Testing Python packages","text":"<p>Testing Python packages is done using the <code>tests</code> section of the recipe. We can either use a special \"python\" test or a regular script test to test the package.</p> <p>All tests will have the current package and all it's run dependencies installed in an isolated environment.</p> recipe.yaml<pre><code># contents of the recipe.yaml file\ntests:\n  - python:\n      # The Python test type will simply import packages as a sanity check.\n      imports:\n        - rattler\n        - rattler.version.Version\n      pip_check: true # (4)!\n      # You can select different Python versions to test against.\n      python_version: [\"${{ python_min ~ '.*' }}\", \"3.12.*\"]  # (1)!\n\n  # You can run a script test to run arbitrary code.\n  - script:\n      - pytest ./tests\n    requirements:  # (2)!\n      run:\n         - pytest\n    files:  # (3)!\n      source:\n        - tests/\n  # You can also directly execute a Python script and run some tests from it.\n  # The script is searched in the `recipe` directory.\n  - script: mytest.py\n</code></pre> <ol> <li>The <code>python_version</code> setting is used to test against different Python versions. It is useful to test against the minimum version of Python that the package supports.</li> <li>We can add additional requirements for the test run. such as pytest, pytest-cov, ... \u2013 you can also specify a <code>python</code> version here by adding e.g. <code>python 3.12.*</code> to the run requirements.</li> <li>This will copy over the tests from the source directory into the package. Note that this makes the package larger, so you might want to use a different approach for larger packages.</li> <li>The <code>pip_check</code> will run <code>pip check</code> in the environment to make sure that all dependencies are installed correctly. By default, this is set to <code>true</code>.</li> </ol>"},{"location":"tutorials/r/","title":"Packaging a R (CRAN) package","text":"<p>Packaging a R package is similar to packaging a Python package!</p>"},{"location":"tutorials/r/#generating-a-starting-point","title":"Generating a starting point","text":"<p>You can use rattler-build to generate a starting point for your recipe from the metadata on CRAN.</p> <pre><code>rattler-build generate-recipe cran r-knitr\n</code></pre>"},{"location":"tutorials/r/#building-a-r-package","title":"Building a R Package","text":"recipe.yaml<pre><code>context:\n  version: \"1.47\"\n\npackage:\n  name: r-knitr\n  version: ${{ version }}\n\nsource:\n  - url: https://cran.r-project.org/src/contrib/Archive/knitr/knitr_${{ version }}.tar.gz\n    sha256: fadd849bf94a4e02520088a6626577c3c636227fe11c5cd7e8fcc5d51a7aa6cf\n\nbuild:\n  noarch: generic # (4)!\n  script: R CMD INSTALL --build . # (1)!\n\nrequirements:\n  host:\n    - r-base # (2)!\n    - r-evaluate &gt;=0.15\n    - r-highr &gt;=0.11\n    - r-xfun &gt;=0.44\n    - r-yaml &gt;=2.1.19\n  run:\n    - r-base\n    - r-evaluate &gt;=0.15\n    - r-highr &gt;=0.11\n    - r-xfun &gt;=0.44\n    - r-yaml &gt;=2.1.19\n\ntests:\n  # This is a shorthand test for R packages to ensure that the library loads correctly.\n  - r:\n      libraries:\n        - knitr\n  # You can also run arbitrary R code in the test section.\n  - script: test_package.R # (3)!\n\nabout:\n  homepage: https://yihui.org/knitr/\n  summary: A General-Purpose Package for Dynamic Report Generation in R\n  description: |-\n    Provides a general-purpose tool for dynamic report\n    generation in R using Literate Programming techniques.\n  license: GPL-2.0-only\n  repository: https://github.com/cran/knitr\n</code></pre> <ol> <li>The <code>script</code> section is where you specify the build commands to run. In this case, we are using <code>R CMD INSTALL --build .</code> to build the package.</li> <li>The <code>r-base</code> package is required to run R and is specified in the <code>host</code> requirements.</li> <li>The <code>script</code> key automatically detects the language based on the file extension. In the case of <code>.R</code>, it will execute the R script with <code>rscript</code>.</li> <li>The <code>noarch: generic</code> directive indicates that the package is architecture-independent. This is useful for R packages that do not contain compiled code and can run on any architecture. It allows the package to be installed on any platform without needing to rebuild it for each architecture.</li> </ol>"},{"location":"tutorials/repackaging/","title":"Repackaging existing software","text":"<p>It's totally possible to repackage existing software using rattler-build, and make it easy to install with conda, mamba or pixi.</p> <p>Repackaging existing binaries is not recommended on <code>conda-forge</code>, but totally acceptable for your own channels / repositories.</p>"},{"location":"tutorials/repackaging/#example-for-linkerd","title":"Example for <code>linkerd</code>","text":"<p>This example shows how to repackage the <code>linkerd</code> binary. The <code>linkerd</code> binary is a command line tool that is used to manage and monitor Kubernetes clusters, and a pre-built binary is available for download from Github releases. Alternatively, you could also follow the Go packaging tutorial to build linkerd from source!</p> <pre><code>package:\n  name: linkerd\n  version: 25.5.2\n\nsource:\n  - if: target_platform == \"linux-64\"\n    then:\n      url: https://github.com/linkerd/linkerd2/releases/download/edge-25.5.2/linkerd2-cli-edge-25.5.2-linux-amd64\n      sha256: 55e7721ab0eb48217f239628b55517b7d663a962df18cdab180e5d42e45f83cb\n      file_name: linkerd\n  - if: target_platform == \"osx-arm64\"\n    then:\n      url: https://github.com/linkerd/linkerd2/releases/download/edge-25.5.2/linkerd2-cli-edge-25.5.2-darwin-arm64\n      sha256: 405ddf3af0089bfece93d811c9bfb9f63e3a000e3f423163fc56690ef4d427cf\n      file_name: linkerd\n  # To support other platforms you can add more `if` statements here\n\nbuild:\n  script:\n    # make linkerd binary executable\n    - chmod +x linkerd\n    # make sure that the `$PREFIX/bin` directory exists\n    - mkdir -p $PREFIX/bin\n    # move or copy the binary to the `$PREFIX/bin` directory\n    - mv linkerd $PREFIX/bin/\n\ntests:\n  - script:\n      - linkerd version\n      # you can add more tests here\n\nabout:\n  homepage: https://linkerd.io/\n  license: Apache-2.0\n  summary: Linkerd is an ultralight service mesh for Kubernetes.\n  description: |\n    Linkerd is an ultralight service mesh for Kubernetes.\n    It adds observability, reliability, and security to your\n    applications without requiring any code changes.\n    Linkerd is open source and free to use.\n  # Note: since we are downloading a binary, we don't have a license file.\n  # You can put the license in the recipe directory, and it will be picked up from there.\n  license_file: LICENSE\n  # documentation: ...\n  repository: https://github.com/linkerd/linkerd2\n</code></pre> <p>Note</p> <p>To repackage the <code>linkerd</code> package on <code>osx-arm64</code> for <code>linux-64</code>, you can pass the <code>--target-platform</code> argument to <code>rattler-build</code>:</p> <pre><code>rattler-build build --target-platform linux-64 linkerd\n</code></pre>"},{"location":"tutorials/repackaging/#adding-system-requirements","title":"Adding system requirements","text":"<p>Some packages have system requirements (e.g. on <code>glibc</code> on Linux, or the macOS SDK on macOS).</p> <p>You can add system requirements like this to the <code>run</code> section by depending on virtual packages:</p> <pre><code>requirements:\n  run:\n    - ${{ \"__glibc &gt;=2.17\" if linux }}\n    - ${{ \"__osx &gt;=10.15\" if osx }}\n</code></pre>"},{"location":"tutorials/rust/","title":"Building a Rust package","text":"<p>We're using <code>rattler-build</code> to build a Rust package for the <code>cargo-edit</code> utility. This utility manages Cargo dependencies from the command line.</p> recipe.yaml<pre><code>context:\n  version: \"0.11.9\"\n\npackage:\n  name: cargo-edit\n  version: ${{ version }}\n\nsource:\n  url: https://github.com/killercup/cargo-edit/archive/refs/tags/v${{ version }}.tar.gz\n  sha256: 46670295e2323fc2f826750cdcfb2692fbdbea87122fe530a07c50c8dba1d3d7\n\nbuild:\n  script:\n    - cargo-bundle-licenses --format yaml --output ${SRC_DIR}/THIRDPARTY.yml # !(1)\n    - $BUILD_PREFIX/bin/cargo install --locked --bins --root ${PREFIX} --path .\n\nrequirements:\n  build:\n    - ${{ compiler('rust') }}\n    - cargo-bundle-licenses\n\ntests:\n  - script:\n      - cargo-upgrade --help # !(2)\n\nabout:\n  homepage: https://github.com/killercup/cargo-edit\n  license: MIT\n  license_file:\n    - LICENSE\n    - THIRDPARTY.yml\n  description: \"A utility for managing cargo dependencies from the command line.\"\n  summary: \"A utility for managing cargo dependencies from the command line.\"\n</code></pre> <p>Note</p> <p>The <code>${{ compiler(...) }}</code> functions are very useful in the context of cross-compilation. When the function is evaluated it will insert the correct compiler (as selected with the variant config) as well the <code>target_platform</code>. The \"rendered\" compiler will look like <code>rust_linux-64</code> when you are targeting the <code>linux-64</code> platform.</p> <p>You can read more about this in the cross-compilation section.</p> <ol> <li>The <code>cargo-bundle-licenses</code> utility is used to bundle all the licenses of the dependencies into a <code>THIRDPARTY.yml</code> file.    This file is then included in the package. You should always include this file in your package when you are redistributing it.</li> <li>Running scripts in <code>bash</code> or <code>cmd.exe</code> to test the package build well, expects an exit code of <code>0</code> to pass the test.</li> </ol> <p>To build this recipe, simply run:</p> <pre><code>rattler-build build \\\n    --recipe ./cargo-edit/recipe.yaml\n</code></pre>"}]}